{
  "courses": [
    {
      "id": "course-043",
      "slug": "solana-cross-chain-bridges",
      "title": "Cross-Chain Bridges and Wormhole",
      "description": "Build safer cross-chain integrations for Solana using Wormhole-style messaging, attestation verification, and deterministic bridge-state controls.",
      "difficulty": "advanced",
      "duration": "6 weeks",
      "totalXP": 2100,
      "tags": [
        "bridges",
        "wormhole",
        "cross-chain",
        "interoperability",
        "messaging"
      ],
      "imageUrl": "/images/courses/solana-bridges.svg",
      "modules": [
        {
          "id": "mod-43-1",
          "title": "Wormhole Messaging Fundamentals",
          "description": "Understand cross-chain messaging trust boundaries, guardian attestations, and deterministic verification pipelines.",
          "lessons": [
            {
              "id": "lesson-43-1-1",
              "type": "content",
              "title": "Cross-Chain Messaging Architecture",
              "content": "Cross-chain messaging is a trust-boundary problem before it is a transport problem. In Wormhole-style systems, messages are observed, attested, and consumed across different chain environments, each with independent failure modes.\n\nA robust architecture model includes:\n1) emitter semantics (what exactly is being attested),\n2) attestation verification (who signed and under what threshold),\n3) replay prevention (message uniqueness and consumption state),\n4) execution safety (what happens if target-chain state has changed).\n\nVerification must be deterministic and strict. Accepting malformed or weakly validated attestations is a direct safety risk.\n\nCross-chain systems should also expose explicit reason codes for rejects: invalid signatures, stale message, already-consumed message, unsupported payload schema. This improves operator response and audit quality.\n\nMessaging reliability depends on observability. Teams need deterministic logs linking source event IDs to target execution outcomes so they can reconcile partial or delayed flows.\n\nCross-chain engineering succeeds when attestation trust assumptions are transparent and enforced consistently at every consume path."
            },
            {
              "id": "lesson-43-1-2",
              "type": "challenge",
              "title": "VAA Verifier Challenge",
              "description": "Implement VAA (Verified Action Approval) signature verification.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct VAA {\n    pub version: u8,\n    pub guardian_set_index: u32,\n    pub signatures: Vec<GuardianSignature>,\n    pub timestamp: u32,\n    pub nonce: u32,\n    pub emitter_chain: u16,\n    pub emitter_address: [u8; 32],\n    pub sequence: u64,\n    pub consistency_level: u8,\n    pub payload: Vec<u8>,\n}\n\n#[derive(Debug, Clone)]\npub struct GuardianSignature {\n    pub guardian_index: u8,\n    pub signature: [u8; 65],\n}\n\npub struct VAAVerifier;\n\nimpl VAAVerifier {\n    pub const MIN_SIGNERS: usize = 13;  // 2/3 of 19 guardians\n\n    pub fn verify_signatures(vaa: &VAA, guardian_set: &[[u8; 20]]) -> bool {\n        // TODO: Verify that VAA has enough valid signatures from guardian set\n        // Check: signatures count >= MIN_SIGNERS\n        // Each signature must be from a valid guardian index\n        todo!(\"Implement verify_signatures\")\n    }\n\n    pub fn calculate_hash(vaa: &VAA) -> [u8; 32] {\n        // TODO: Calculate VAA body hash for verification\n        // Hash of: timestamp + nonce + emitter_chain + emitter_address + sequence + payload\n        todo!(\"Implement calculate_hash\")\n    }\n\n    pub fn is_sequence_valid(vaa: &VAA, last_sequence: u64) -> bool {\n        // TODO: Check if VAA sequence is greater than last processed\n        todo!(\"Implement is_sequence_valid\")\n    }\n\n    pub fn has_guardian_quorum(vaa: &VAA, total_guardians: usize) -> bool {\n        // TODO: Check if signatures reach 2/3 quorum\n        todo!(\"Implement has_guardian_quorum\")\n    }\n}",
              "solution": "#[derive(Debug, Clone)]\npub struct VAA {\n    pub version: u8,\n    pub guardian_set_index: u32,\n    pub signatures: Vec<GuardianSignature>,\n    pub timestamp: u32,\n    pub nonce: u32,\n    pub emitter_chain: u16,\n    pub emitter_address: [u8; 32],\n    pub sequence: u64,\n    pub consistency_level: u8,\n    pub payload: Vec<u8>,\n}\n\n#[derive(Debug, Clone)]\npub struct GuardianSignature {\n    pub guardian_index: u8,\n    pub signature: [u8; 65],\n}\n\npub struct VAAVerifier;\n\nimpl VAAVerifier {\n    pub const MIN_SIGNERS: usize = 13;\n\n    pub fn verify_signatures(vaa: &VAA, guardian_set: &[[u8; 20]]) -> bool {\n        if vaa.signatures.len() < Self::MIN_SIGNERS {\n            return false;\n        }\n\n        // Verify each signature is from a valid guardian index\n        for sig in &vaa.signatures {\n            if sig.guardian_index as usize >= guardian_set.len() {\n                return false;\n            }\n        }\n\n        true\n    }\n\n    pub fn calculate_hash(vaa: &VAA) -> [u8; 32] {\n        // Simplified hash calculation\n        let mut data = vec![];\n        data.extend_from_slice(&vaa.timestamp.to_be_bytes());\n        data.extend_from_slice(&vaa.nonce.to_be_bytes());\n        data.extend_from_slice(&vaa.emitter_chain.to_be_bytes());\n        data.extend_from_slice(&vaa.emitter_address);\n        data.extend_from_slice(&vaa.sequence.to_be_bytes());\n        data.extend_from_slice(&vaa.payload);\n\n        // Simple hash simulation\n        let mut hash = [0u8; 32];\n        for (i, byte) in data.iter().enumerate() {\n            hash[i % 32] ^= *byte;\n        }\n        hash\n    }\n\n    pub fn is_sequence_valid(vaa: &VAA, last_sequence: u64) -> bool {\n        vaa.sequence > last_sequence\n    }\n\n    pub fn has_guardian_quorum(vaa: &VAA, total_guardians: usize) -> bool {\n        let required = (total_guardians * 2 + 2) / 3;  // 2/3 rounded up\n        vaa.signatures.len() >= required\n    }\n}",
              "hints": [
                "Check signatures length against MIN_SIGNERS first",
                "Use to_be_bytes() for big-endian byte conversion",
                "Quorum is 2/3 of total guardians rounded up"
              ],
              "testCases": [
                {
                  "input": {
                    "signatures": 15,
                    "guardians": 19
                  },
                  "expected": {
                    "valid": true
                  }
                },
                {
                  "input": {
                    "signatures": 10,
                    "guardians": 19
                  },
                  "expected": {
                    "valid": false
                  }
                },
                {
                  "input": {
                    "sequence": 100,
                    "last": 99
                  },
                  "expected": {
                    "valid": true
                  }
                },
                {
                  "input": {
                    "signatures": 13,
                    "total": 19
                  },
                  "expected": {
                    "quorum": true
                  }
                }
              ]
            },
            {
              "id": "lesson-43-1-3",
              "type": "challenge",
              "title": "Message Emitter Challenge",
              "description": "Implement cross-chain message emission and tracking.",
              "starterCode": "pub struct MessageEmitter {\n    pub emitter_address: [u8; 32],\n    pub sequence: u64,\n    pub chain_id: u16,\n}\n\n#[derive(Debug, Clone)]\npub struct EmittedMessage {\n    pub sequence: u64,\n    pub nonce: u32,\n    pub payload: Vec<u8>,\n    pub timestamp: u64,\n}\n\nimpl MessageEmitter {\n    pub fn new(emitter_address: [u8; 32], chain_id: u16) -> Self {\n        Self {\n            emitter_address,\n            sequence: 0,\n            chain_id,\n        }\n    }\n\n    pub fn emit_message(&mut self, payload: Vec<u8>, nonce: u32) -> EmittedMessage {\n        // TODO: Emit a new message with incremented sequence\n        todo!(\"Implement emit_message\")\n    }\n\n    pub fn get_next_sequence(&self) -> u64 {\n        // TODO: Return the next sequence number to be used\n        todo!(\"Implement get_next_sequence\")\n    }\n\n    pub fn verify_message_origin(&self, message: &EmittedMessage) -> bool {\n        // TODO: Verify message was emitted by this emitter\n        todo!(\"Implement verify_message_origin\")\n    }\n\n    pub fn get_emitter_address(&self) -> [u8; 32] {\n        self.emitter_address\n    }\n}",
              "solution": "impl MessageEmitter {\n    pub fn new(emitter_address: [u8; 32], chain_id: u16) -> Self {\n        Self {\n            emitter_address,\n            sequence: 0,\n            chain_id,\n        }\n    }\n\n    pub fn emit_message(&mut self, payload: Vec<u8>, nonce: u32) -> EmittedMessage {\n        self.sequence += 1;\n        EmittedMessage {\n            sequence: self.sequence,\n            nonce,\n            payload,\n            timestamp: 0, // Would use current time in real implementation\n        }\n    }\n\n    pub fn get_next_sequence(&self) -> u64 {\n        self.sequence + 1\n    }\n\n    pub fn verify_message_origin(&self, message: &EmittedMessage) -> bool {\n        // In real implementation, would verify against stored emissions\n        // For now, just check sequence is within valid range\n        message.sequence > 0 && message.sequence <= self.sequence\n    }\n\n    pub fn get_emitter_address(&self) -> [u8; 32] {\n        self.emitter_address\n    }\n}",
              "hints": [
                "Increment sequence before creating message",
                "Next sequence is current + 1",
                "Verify message sequence is within emitted range"
              ],
              "testCases": [
                {
                  "input": {
                    "emit": "hello"
                  },
                  "expected": {
                    "sequence": 1
                  }
                },
                {
                  "input": {
                    "emit": "world"
                  },
                  "expected": {
                    "sequence": 2
                  }
                },
                {
                  "input": {
                    "next_sequence": true
                  },
                  "expected": {
                    "value": 3
                  }
                },
                {
                  "input": {
                    "verify": {
                      "sequence": 1
                    }
                  },
                  "expected": {
                    "valid": true
                  }
                }
              ]
            },
            {
              "id": "lesson-43-1-4",
              "type": "challenge",
              "title": "Replay Protection Challenge",
              "description": "Implement replay protection for cross-chain messages.",
              "starterCode": "pub struct ReplayProtector {\n    pub processed_sequences: Vec<u64>,\n    pub max_sequence: u64,\n}\n\npub struct ReplayProtection;\n\nimpl ReplayProtection {\n    pub fn new() -> ReplayProtector {\n        ReplayProtector {\n            processed_sequences: vec![],\n            max_sequence: 0,\n        }\n    }\n\n    pub fn is_processed(protector: &ReplayProtector, sequence: u64) -> bool {\n        // TODO: Check if sequence has already been processed\n        todo!(\"Implement is_processed\")\n    }\n\n    pub fn mark_processed(protector: &mut ReplayProtector, sequence: u64) -> Result<(), String> {\n        // TODO: Mark sequence as processed, prevent duplicates\n        todo!(\"Implement mark_processed\")\n    }\n\n    pub fn get_unprocessed<'a>(protector: &ReplayProtector, sequences: &'a [u64]) -> Vec<&'a u64> {\n        // TODO: Return sequences that haven't been processed yet\n        todo!(\"Implement get_unprocessed\")\n    }\n\n    pub fn prune_old_sequences(protector: &mut ReplayProtector, before: u64) {\n        // TODO: Remove sequences older than 'before' to save space\n        todo!(\"Implement prune_old_sequences\")\n    }\n}",
              "solution": "pub struct ReplayProtector {\n    pub processed_sequences: Vec<u64>,\n    pub max_sequence: u64,\n}\n\npub struct ReplayProtection;\n\nimpl ReplayProtection {\n    pub fn new() -> ReplayProtector {\n        ReplayProtector {\n            processed_sequences: vec![],\n            max_sequence: 0,\n        }\n    }\n\n    pub fn is_processed(protector: &ReplayProtector, sequence: u64) -> bool {\n        protector.processed_sequences.contains(&sequence)\n    }\n\n    pub fn mark_processed(protector: &mut ReplayProtector, sequence: u64) -> Result<(), String> {\n        if Self::is_processed(protector, sequence) {\n            return Err(\"Sequence already processed\".to_string());\n        }\n        protector.processed_sequences.push(sequence);\n        if sequence > protector.max_sequence {\n            protector.max_sequence = sequence;\n        }\n        Ok(())\n    }\n\n    pub fn get_unprocessed<'a>(protector: &ReplayProtector, sequences: &'a [u64]) -> Vec<&'a u64> {\n        sequences.iter().filter(|&&s| !Self::is_processed(protector, s)).collect()\n    }\n\n    pub fn prune_old_sequences(protector: &mut ReplayProtector, before: u64) {\n        protector.processed_sequences.retain(|&s| s >= before);\n    }\n}",
              "hints": [
                "Use contains() to check if sequence was processed",
                "Return error if trying to mark already-processed sequence",
                "Use retain() to filter out old sequences"
              ],
              "testCases": [
                {
                  "input": {
                    "mark": 1
                  },
                  "expected": {
                    "ok": true
                  }
                },
                {
                  "input": {
                    "mark": 1
                  },
                  "expected": {
                    "ok": false
                  }
                },
                {
                  "input": {
                    "check": 1
                  },
                  "expected": {
                    "processed": true
                  }
                },
                {
                  "input": {
                    "sequences": [
                      1,
                      2,
                      3,
                      4
                    ],
                    "processed": [
                      1,
                      2
                    ]
                  },
                  "expected": {
                    "unprocessed": [
                      3,
                      4
                    ]
                  }
                }
              ]
            }
          ]
        },
        {
          "id": "mod-43-2",
          "title": "Asset Bridging Patterns",
          "description": "Implement asset-bridging patterns with strict supply/accounting invariants, replay protection, and reconciliation workflows.",
          "lessons": [
            {
              "id": "lesson-43-2-1",
              "type": "content",
              "title": "Token Bridging Mechanics",
              "content": "Token bridging requires strict supply and state invariants. Lock-and-mint and burn-and-mint models both rely on one central rule: represented supply across chains must remain coherent.\n\nCritical controls include:\n- single-consume message semantics,\n- deterministic mint/unlock accounting,\n- paused-mode handling for incident containment,\n- reconciliation reports between source and target totals.\n\nA bridge flow should define state transitions explicitly: initiated, attested, executed, reconciled. Missing state transitions create operational blind spots.\n\nReplay and duplication are recurring bridge risks. Systems must key transfer intents deterministically and reject repeated execution attempts even under retries or delayed relays.\n\nProduction bridge operations also need runbooks: what to do on attestation delays, threshold signer issues, or target-chain execution failures.\n\nBridging quality is not just throughput; it is verifiable accounting integrity under adverse network conditions."
            },
            {
              "id": "lesson-43-2-2",
              "type": "challenge",
              "title": "Token Locker Challenge",
              "description": "Implement token locking for bridge deposits.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct LockedToken {\n    pub owner: String,\n    pub amount: u64,\n    pub token_mint: String,\n    pub unlock_time: u64,\n}\n\npub struct TokenLocker {\n    pub locks: Vec<LockedToken>,\n    pub total_locked: u64,\n}\n\npub struct TokenLockerImpl;\n\nimpl TokenLockerImpl {\n    pub fn new() -> TokenLocker {\n        TokenLocker {\n            locks: vec![],\n            total_locked: 0,\n        }\n    }\n\n    pub fn lock_tokens(locker: &mut TokenLocker, owner: String, amount: u64, token_mint: String) -> u64 {\n        // TODO: Lock tokens and return lock ID (index)\n        todo!(\"Implement lock_tokens\")\n    }\n\n    pub fn unlock_tokens(locker: &mut TokenLocker, lock_id: usize, requester: &str) -> Result<u64, String> {\n        // TODO: Unlock tokens if requester is owner\n        todo!(\"Implement unlock_tokens\")\n    }\n\n    pub fn get_locked_amount(locker: &TokenLocker, owner: &str) -> u64 {\n        // TODO: Get total locked amount for owner\n        todo!(\"Implement get_locked_amount\")\n    }\n\n    pub fn is_locked(locker: &TokenLocker, lock_id: usize) -> bool {\n        // TODO: Check if lock ID is valid and active\n        todo!(\"Implement is_locked\")\n    }\n}",
              "solution": "impl TokenLockerImpl {\n    pub fn new() -> TokenLocker {\n        TokenLocker {\n            locks: vec![],\n            total_locked: 0,\n        }\n    }\n\n    pub fn lock_tokens(locker: &mut TokenLocker, owner: String, amount: u64, token_mint: String) -> u64 {\n        let lock_id = locker.locks.len() as u64;\n        locker.locks.push(LockedToken {\n            owner,\n            amount,\n            token_mint,\n            unlock_time: 0,\n        });\n        locker.total_locked += amount;\n        lock_id\n    }\n\n    pub fn unlock_tokens(locker: &mut TokenLocker, lock_id: usize, requester: &str) -> Result<u64, String> {\n        if lock_id >= locker.locks.len() {\n            return Err(\"Invalid lock ID\".to_string());\n        }\n\n        let lock = &locker.locks[lock_id];\n        if lock.owner != requester {\n            return Err(\"Not lock owner\".to_string());\n        }\n\n        let amount = lock.amount;\n        locker.total_locked -= amount;\n        locker.locks.remove(lock_id);\n\n        Ok(amount)\n    }\n\n    pub fn get_locked_amount(locker: &TokenLocker, owner: &str) -> u64 {\n        locker.locks.iter().filter(|l| l.owner == owner).map(|l| l.amount).sum()\n    }\n\n    pub fn is_locked(locker: &TokenLocker, lock_id: usize) -> bool {\n        lock_id < locker.locks.len()\n    }\n}",
              "hints": [
                "Push lock to vector and return index as lock_id",
                "Verify requester matches owner before unlocking",
                "Use filter and sum to calculate owner's locked amount"
              ],
              "testCases": [
                {
                  "input": {
                    "lock": {
                      "owner": "alice",
                      "amount": 1000
                    }
                  },
                  "expected": {
                    "lock_id": 0
                  }
                },
                {
                  "input": {
                    "unlock": {
                      "id": 0,
                      "requester": "alice"
                    }
                  },
                  "expected": {
                    "amount": 1000
                  }
                },
                {
                  "input": {
                    "locked": "alice"
                  },
                  "expected": {
                    "after_unlock": 0
                  }
                },
                {
                  "input": {
                    "check": 0
                  },
                  "expected": {
                    "locked": false
                  }
                }
              ]
            },
            {
              "id": "lesson-43-2-3",
              "type": "challenge",
              "title": "Wrapped Token Mint Challenge",
              "description": "Manage wrapped token minting and supply tracking.",
              "starterCode": "pub struct WrappedToken {\n    pub original_chain: u16,\n    pub original_token: [u8; 32],\n    pub decimals: u8,\n    pub total_supply: u64,\n}\n\npub struct WrappedTokenManager {\n    pub tokens: Vec<WrappedToken>,\n}\n\npub struct WrappedTokenImpl;\n\nimpl WrappedTokenImpl {\n    pub fn new() -> WrappedTokenManager {\n        WrappedTokenManager { tokens: vec![] }\n    }\n\n    pub fn register_token(manager: &mut WrappedTokenManager, original_chain: u16, original_token: [u8; 32], decimals: u8) -> usize {\n        // TODO: Register a new wrapped token, return token index\n        todo!(\"Implement register_token\")\n    }\n\n    pub fn mint_wrapped(manager: &mut WrappedTokenManager, token_index: usize, amount: u64) -> Result<(), String> {\n        // TODO: Mint wrapped tokens, increasing supply\n        todo!(\"Implement mint_wrapped\")\n    }\n\n    pub fn burn_wrapped(manager: &mut WrappedTokenManager, token_index: usize, amount: u64) -> Result<(), String> {\n        // TODO: Burn wrapped tokens, decreasing supply\n        todo!(\"Implement burn_wrapped\")\n    }\n\n    pub fn get_supply(manager: &WrappedTokenManager, token_index: usize) -> Option<u64> {\n        // TODO: Get current supply of wrapped token\n        todo!(\"Implement get_supply\")\n    }\n}",
              "solution": "impl WrappedTokenImpl {\n    pub fn new() -> WrappedTokenManager {\n        WrappedTokenManager { tokens: vec![] }\n    }\n\n    pub fn register_token(manager: &mut WrappedTokenManager, original_chain: u16, original_token: [u8; 32], decimals: u8) -> usize {\n        let index = manager.tokens.len();\n        manager.tokens.push(WrappedToken {\n            original_chain,\n            original_token,\n            decimals,\n            total_supply: 0,\n        });\n        index\n    }\n\n    pub fn mint_wrapped(manager: &mut WrappedTokenManager, token_index: usize, amount: u64) -> Result<(), String> {\n        if token_index >= manager.tokens.len() {\n            return Err(\"Invalid token index\".to_string());\n        }\n        manager.tokens[token_index].total_supply += amount;\n        Ok(())\n    }\n\n    pub fn burn_wrapped(manager: &mut WrappedTokenManager, token_index: usize, amount: u64) -> Result<(), String> {\n        if token_index >= manager.tokens.len() {\n            return Err(\"Invalid token index\".to_string());\n        }\n        let token = &mut manager.tokens[token_index];\n        if token.total_supply < amount {\n            return Err(\"Insufficient supply\".to_string());\n        }\n        token.total_supply -= amount;\n        Ok(())\n    }\n\n    pub fn get_supply(manager: &WrappedTokenManager, token_index: usize) -> Option<u64> {\n        manager.tokens.get(token_index).map(|t| t.total_supply)\n    }\n}",
              "hints": [
                "Push token to vector and return index",
                "Check bounds before minting/burning",
                "Use get() and map() to safely retrieve supply"
              ],
              "testCases": [
                {
                  "input": {
                    "register": {
                      "chain": 1,
                      "decimals": 6
                    }
                  },
                  "expected": {
                    "index": 0
                  }
                },
                {
                  "input": {
                    "mint": {
                      "index": 0,
                      "amount": 10000
                    }
                  },
                  "expected": {
                    "supply": 10000
                  }
                },
                {
                  "input": {
                    "burn": {
                      "index": 0,
                      "amount": 3000
                    }
                  },
                  "expected": {
                    "supply": 7000
                  }
                },
                {
                  "input": {
                    "burn": {
                      "index": 0,
                      "amount": 10000
                    }
                  },
                  "expected": {
                    "error": "Insufficient"
                  }
                }
              ]
            },
            {
              "id": "lesson-43-2-4",
              "type": "challenge",
              "title": "Bridge Rate Limiter Challenge",
              "description": "Implement rate limiting for bridge withdrawals.",
              "starterCode": "pub struct RateLimitConfig {\n    pub max_amount_per_window: u64,\n    pub window_duration: u64,\n}\n\npub struct RateLimiter {\n    pub config: RateLimitConfig,\n    pub window_start: u64,\n    pub used_amount: u64,\n}\n\npub struct BridgeRateLimiter;\n\nimpl BridgeRateLimiter {\n    pub fn new(config: RateLimitConfig, current_time: u64) -> RateLimiter {\n        RateLimiter {\n            config,\n            window_start: current_time,\n            used_amount: 0,\n        }\n    }\n\n    pub fn check_and_consume(limiter: &mut RateLimiter, amount: u64, current_time: u64) -> bool {\n        // TODO: Check if amount is within rate limit and consume if allowed\n        todo!(\"Implement check_and_consume\")\n    }\n\n    pub fn reset_window(limiter: &mut RateLimiter, current_time: u64) {\n        // TODO: Reset rate limit window if duration has passed\n        todo!(\"Implement reset_window\")\n    }\n\n    pub fn remaining_allowance(limiter: &RateLimiter, current_time: u64) -> u64 {\n        // TODO: Calculate remaining amount allowed in current window\n        todo!(\"Implement remaining_allowance\")\n    }\n\n    pub fn time_until_reset(limiter: &RateLimiter, current_time: u64) -> u64 {\n        // TODO: Calculate time until next window\n        todo!(\"Implement time_until_reset\")\n    }\n}",
              "solution": "impl BridgeRateLimiter {\n    pub fn new(config: RateLimitConfig, current_time: u64) -> RateLimiter {\n        RateLimiter {\n            config,\n            window_start: current_time,\n            used_amount: 0,\n        }\n    }\n\n    pub fn check_and_consume(limiter: &mut RateLimiter, amount: u64, current_time: u64) -> bool {\n        Self::reset_window(limiter, current_time);\n\n        if limiter.used_amount + amount <= limiter.config.max_amount_per_window {\n            limiter.used_amount += amount;\n            true\n        } else {\n            false\n        }\n    }\n\n    pub fn reset_window(limiter: &mut RateLimiter, current_time: u64) {\n        if current_time >= limiter.window_start + limiter.config.window_duration {\n            limiter.window_start = current_time;\n            limiter.used_amount = 0;\n        }\n    }\n\n    pub fn remaining_allowance(limiter: &RateLimiter, current_time: u64) -> u64 {\n        if current_time >= limiter.window_start + limiter.config.window_duration {\n            limiter.config.max_amount_per_window\n        } else {\n            limiter.config.max_amount_per_window - limiter.used_amount\n        }\n    }\n\n    pub fn time_until_reset(limiter: &RateLimiter, current_time: u64) -> u64 {\n        let next_reset = limiter.window_start + limiter.config.window_duration;\n        if current_time >= next_reset {\n            0\n        } else {\n            next_reset - current_time\n        }\n    }\n}",
              "hints": [
                "Reset window before checking if duration passed",
                "Only consume if total won't exceed max",
                "Time until reset is next_reset - current_time"
              ],
              "testCases": [
                {
                  "input": {
                    "max": 10000,
                    "consume": 3000,
                    "time": 0
                  },
                  "expected": {
                    "allowed": true,
                    "used": 3000
                  }
                },
                {
                  "input": {
                    "consume": 8000,
                    "time": 0
                  },
                  "expected": {
                    "allowed": false
                  }
                },
                {
                  "input": {
                    "remaining": true,
                    "time": 0
                  },
                  "expected": {
                    "value": 7000
                  }
                },
                {
                  "input": {
                    "time_until": true,
                    "current": 0,
                    "duration": 3600
                  },
                  "expected": {
                    "value": 3600
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "course-044",
      "slug": "solana-oracle-pyth",
      "title": "Oracle Integration and Pyth Network",
      "description": "Integrate Solana oracle feeds safely: price validation, confidence/staleness policy, and multi-source aggregation for resilient protocol decisions.",
      "difficulty": "intermediate",
      "duration": "5 weeks",
      "totalXP": 1850,
      "tags": [
        "oracle",
        "pyth",
        "price-feeds",
        "data-validation",
        "aggregation"
      ],
      "imageUrl": "/images/courses/solana-oracle.svg",
      "modules": [
        {
          "id": "mod-44-1",
          "title": "Price Feed Fundamentals",
          "description": "Understand oracle data semantics (price, confidence, staleness) and enforce deterministic validation before business logic.",
          "lessons": [
            {
              "id": "lesson-44-1-1",
              "type": "content",
              "title": "Oracle Price Feeds",
              "content": "Oracle integration is a risk-control problem, not a data-fetch problem. Price feeds must be evaluated for freshness, confidence, and contextual fitness before they drive protocol decisions.\n\nA safe oracle validation pipeline checks:\n1) feed status and availability,\n2) staleness window compliance,\n3) confidence-band reasonableness,\n4) value bounds against protocol policy.\n\nUsing raw price without confidence or staleness checks can trigger invalid liquidations, bad quotes, or incorrect risk assessments.\n\nValidation outputs should be deterministic and structured (accept/reject with reason code). This helps downstream systems choose safe fallback behavior.\n\nProtocols should separate “data exists” from “data is usable.” A feed can be present but still unfit due to stale timestamp or extreme uncertainty.\n\nProduction reliability improves when oracle checks are versioned and fixture-tested across calm and stressed market scenarios."
            },
            {
              "id": "lesson-44-1-2",
              "type": "challenge",
              "title": "Price Validator Challenge",
              "description": "Validate oracle prices for correctness and freshness.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct PriceData {\n    pub price: i64,\n    pub conf: u64,\n    pub expo: i32,\n    pub publish_time: i64,\n    pub status: PriceStatus,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum PriceStatus {\n    Unknown,\n    Trading,\n    Halted,\n    Auction,\n}\n\npub struct PriceValidator {\n    pub max_staleness: i64,\n    pub max_confidence_ratio: f64,\n}\n\nimpl PriceValidator {\n    pub fn is_fresh(&self, price: &PriceData, current_time: i64) -> bool {\n        // TODO: Check if price is fresh (within staleness threshold)\n        todo!(\"Implement is_fresh\")\n    }\n\n    pub fn is_confidence_valid(&self, price: &PriceData) -> bool {\n        // TODO: Check if confidence is within acceptable ratio\n        // confidence / |price| < max_confidence_ratio\n        todo!(\"Implement is_confidence_valid\")\n    }\n\n    pub fn is_trading(&self, price: &PriceData) -> bool {\n        // TODO: Check if price status is Trading\n        todo!(\"Implement is_trading\")\n    }\n\n    pub fn validate(&self, price: &PriceData, current_time: i64) -> Result<(), String> {\n        // TODO: Full validation - fresh, valid confidence, trading\n        todo!(\"Implement validate\")\n    }\n}",
              "solution": "impl PriceValidator {\n    pub fn is_fresh(&self, price: &PriceData, current_time: i64) -> bool {\n        current_time - price.publish_time <= self.max_staleness\n    }\n\n    pub fn is_confidence_valid(&self, price: &PriceData) -> bool {\n        if price.price == 0 {\n            return false;\n        }\n        let price_abs = price.price.abs() as f64;\n        let conf = price.conf as f64;\n        (conf / price_abs) < self.max_confidence_ratio\n    }\n\n    pub fn is_trading(&self, price: &PriceData) -> bool {\n        matches!(price.status, PriceStatus::Trading)\n    }\n\n    pub fn validate(&self, price: &PriceData, current_time: i64) -> Result<(), String> {\n        if !self.is_trading(price) {\n            return Err(\"Price not trading\".to_string());\n        }\n        if !self.is_fresh(price, current_time) {\n            return Err(\"Price stale\".to_string());\n        }\n        if !self.is_confidence_valid(price) {\n            return Err(\"Confidence too high\".to_string());\n        }\n        Ok(())\n    }\n}",
              "hints": [
                "Freshness: current_time - publish_time <= max_staleness",
                "Confidence ratio: conf / |price| < threshold",
                "Use matches! for enum variant checking"
              ],
              "testCases": [
                {
                  "input": {
                    "publish": 1000,
                    "current": 1500,
                    "max": 1000
                  },
                  "expected": {
                    "fresh": true
                  }
                },
                {
                  "input": {
                    "price": 100000,
                    "conf": 500,
                    "ratio": 0.01
                  },
                  "expected": {
                    "valid": true
                  }
                },
                {
                  "input": {
                    "status": "Trading"
                  },
                  "expected": {
                    "trading": true
                  }
                },
                {
                  "input": {
                    "status": "Halted"
                  },
                  "expected": {
                    "valid": false
                  }
                }
              ]
            },
            {
              "id": "lesson-44-1-3",
              "type": "challenge",
              "title": "Price Normalizer Challenge",
              "description": "Normalize prices with different exponents to common scale.",
              "starterCode": "pub struct PriceNormalizer;\n\nimpl PriceNormalizer {\n    pub fn normalize_to_decimals(price: i64, expo: i32, target_decimals: u8) -> i64 {\n        // TODO: Normalize price to target decimal places\n        // expo = -8 means 8 decimals, target = 6 means 6 decimals\n        // Result = price * 10^(target - (-expo))\n        todo!(\"Implement normalize_to_decimals\")\n    }\n\n    pub fn convert_price(from_price: i64, from_expo: i32, to_expo: i32) -> i64 {\n        // TODO: Convert price from one exponent to another\n        todo!(\"Implement convert_price\")\n    }\n\n    pub fn calculate_value(amount: u64, price: i64, price_expo: i32, amount_decimals: u8) -> u64 {\n        // TODO: Calculate USD value of token amount\n        // value = amount * price / 10^(price_expo + amount_decimals)\n        todo!(\"Implement calculate_value\")\n    }\n\n    pub fn apply_spread(price: i64, spread_bps: u64, is_buy: bool) -> i64 {\n        // TODO: Apply spread to price (increase for buy, decrease for sell)\n        todo!(\"Implement apply_spread\")\n    }\n}",
              "solution": "pub struct PriceNormalizer;\n\nimpl PriceNormalizer {\n    pub fn normalize_to_decimals(price: i64, expo: i32, target_decimals: u8) -> i64 {\n        let expo_decimals = (-expo) as i32;\n        let diff = target_decimals as i32 - expo_decimals;\n\n        if diff >= 0 {\n            price * 10i64.pow(diff as u32)\n        } else {\n            price / 10i64.pow((-diff) as u32)\n        }\n    }\n\n    pub fn convert_price(from_price: i64, from_expo: i32, to_expo: i32) -> i64 {\n        let diff = to_expo - from_expo;\n        if diff >= 0 {\n            from_price * 10i64.pow(diff as u32)\n        } else {\n            from_price / 10i64.pow((-diff) as u32)\n        }\n    }\n\n    pub fn calculate_value(amount: u64, price: i64, price_expo: i32, amount_decimals: u8) -> u64 {\n        let expo_decimals = (-price_expo) as u32;\n        let total_decimals = expo_decimals + amount_decimals as u32;\n\n        ((amount as u128 * price as u128) / 10u128.pow(total_decimals)) as u64\n    }\n\n    pub fn apply_spread(price: i64, spread_bps: u64, is_buy: bool) -> i64 {\n        let adjustment = (price as i128 * spread_bps as i128 / 10000) as i64;\n        if is_buy {\n            price + adjustment\n        } else {\n            price - adjustment\n        }\n    }\n}",
              "hints": [
                "Calculate decimal difference and scale accordingly",
                "Use u128 for intermediate to prevent overflow",
                "Buy price increases, sell price decreases with spread"
              ],
              "testCases": [
                {
                  "input": {
                    "price": 50000,
                    "expo": -8,
                    "target": 6
                  },
                  "expected": {
                    "normalized": 500
                  }
                },
                {
                  "input": {
                    "amount": 1000000,
                    "price": 50000,
                    "expo": -8,
                    "decimals": 6
                  },
                  "expected": {
                    "value": 500
                  }
                },
                {
                  "input": {
                    "price": 100000,
                    "spread": 100,
                    "buy": true
                  },
                  "expected": {
                    "with_spread": 101000
                  }
                }
              ]
            },
            {
              "id": "lesson-44-1-4",
              "type": "challenge",
              "title": "EMA Calculator Challenge",
              "description": "Calculate Exponential Moving Average for price smoothing.",
              "starterCode": "pub struct EMAConfig {\n    pub period: u32,\n    pub smoothing: f64,  // Typically 2.0\n}\n\npub struct EMACalculator {\n    pub config: EMAConfig,\n    pub current_ema: Option<f64>,\n}\n\nimpl EMACalculator {\n    pub fn new(config: EMAConfig) -> Self {\n        Self {\n            config,\n            current_ema: None,\n        }\n    }\n\n    pub fn multiplier(&self) -> f64 {\n        // TODO: Calculate EMA multiplier: smoothing / (period + 1)\n        todo!(\"Implement multiplier\")\n    }\n\n    pub fn update(&mut self, price: f64) -> f64 {\n        // TODO: Update EMA with new price\n        // EMA = price * multiplier + EMA_prev * (1 - multiplier)\n        todo!(\"Implement update\")\n    }\n\n    pub fn get_ema(&self) -> Option<f64> {\n        self.current_ema\n    }\n\n    pub fn reset(&mut self) {\n        // TODO: Reset EMA to None\n        todo!(\"Implement reset\")\n    }\n}",
              "solution": "impl EMACalculator {\n    pub fn new(config: EMAConfig) -> Self {\n        Self {\n            config,\n            current_ema: None,\n        }\n    }\n\n    pub fn multiplier(&self) -> f64 {\n        self.config.smoothing / (self.config.period as f64 + 1.0)\n    }\n\n    pub fn update(&mut self, price: f64) -> f64 {\n        let mult = self.multiplier();\n\n        let new_ema = match self.current_ema {\n            None => price,\n            Some(prev_ema) => price * mult + prev_ema * (1.0 - mult),\n        };\n\n        self.current_ema = Some(new_ema);\n        new_ema\n    }\n\n    pub fn get_ema(&self) -> Option<f64> {\n        self.current_ema\n    }\n\n    pub fn reset(&mut self) {\n        self.current_ema = None;\n    }\n}",
              "hints": [
                "Multiplier formula: smoothing / (period + 1)",
                "First EMA equals first price",
                "Subsequent EMAs use weighted average formula"
              ],
              "testCases": [
                {
                  "input": {
                    "period": 10,
                    "smoothing": 2
                  },
                  "expected": {
                    "multiplier": 0.1818
                  }
                },
                {
                  "input": {
                    "update": 100
                  },
                  "expected": {
                    "ema": 100
                  }
                },
                {
                  "input": {
                    "update": 110
                  },
                  "expected": {
                    "ema": 101.82
                  }
                },
                {
                  "input": {
                    "reset": true
                  },
                  "expected": {
                    "ema": null
                  }
                }
              ]
            }
          ]
        },
        {
          "id": "mod-44-2",
          "title": "Multi-Oracle Aggregation",
          "description": "Design multi-oracle aggregation and consensus policies that reduce single-source failure risk while remaining explainable and testable.",
          "lessons": [
            {
              "id": "lesson-44-2-1",
              "type": "content",
              "title": "Oracle Aggregation Strategies",
              "content": "Multi-oracle aggregation reduces single-point dependency but adds policy complexity. The goal is not to average blindly; it is to produce a robust decision value with clear confidence in adverse conditions.\n\nCommon strategies include median, trimmed mean, and weighted consensus. Strategy choice should reflect threat model: outlier resistance, latency tolerance, and source diversity.\n\nAggregation policies should define:\n- minimum participating sources,\n- max divergence threshold,\n- fallback action when consensus fails.\n\nIf sources diverge beyond policy bounds, the safe action may be to halt sensitive operations rather than force a number.\n\nDeterministic aggregation reports should include contributing sources, excluded outliers, and final consensus rationale. This is essential for audits and incident response.\n\nA good oracle stack is transparent: every accepted value can be explained, replayed, and defended."
            },
            {
              "id": "lesson-44-2-2",
              "type": "challenge",
              "title": "Median Price Calculator Challenge",
              "description": "Calculate median price from multiple oracle sources.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct OraclePrice {\n    pub source: String,\n    pub price: i64,\n    pub weight: u32,\n}\n\npub struct MedianCalculator;\n\nimpl MedianCalculator {\n    pub fn calculate_median(prices: &[i64]) -> Option<f64> {\n        // TODO: Calculate median of price array\n        // For odd count: middle element\n        // For even count: average of two middle elements\n        todo!(\"Implement calculate_median\")\n    }\n\n    pub fn calculate_weighted_median(oracles: &[OraclePrice]) -> Option<i64> {\n        // TODO: Calculate weighted median\n        // Sort by price, find where cumulative weight reaches 50%\n        todo!(\"Implement calculate_weighted_median\")\n    }\n\n    pub fn remove_outliers(prices: &mut Vec<i64>, max_deviation_percent: f64) {\n        // TODO: Remove prices that deviate more than threshold from median\n        todo!(\"Implement remove_outliers\")\n    }\n\n    pub fn is_within_tolerance(price1: i64, price2: i64, tolerance_bps: u64) -> bool {\n        // TODO: Check if two prices are within tolerance (basis points)\n        todo!(\"Implement is_within_tolerance\")\n    }\n}",
              "solution": "impl MedianCalculator {\n    pub fn calculate_median(prices: &[i64]) -> Option<f64> {\n        if prices.is_empty() {\n            return None;\n        }\n\n        let mut sorted = prices.to_vec();\n        sorted.sort();\n\n        let mid = sorted.len() / 2;\n        if sorted.len() % 2 == 0 {\n            Some((sorted[mid - 1] as f64 + sorted[mid] as f64) / 2.0)\n        } else {\n            Some(sorted[mid] as f64)\n        }\n    }\n\n    pub fn calculate_weighted_median(oracles: &[OraclePrice]) -> Option<i64> {\n        if oracles.is_empty() {\n            return None;\n        }\n\n        let mut sorted: Vec<_> = oracles.iter().collect();\n        sorted.sort_by_key(|o| o.price);\n\n        let total_weight: u32 = sorted.iter().map(|o| o.weight).sum();\n        let target_weight = total_weight / 2;\n\n        let mut cumulative = 0;\n        for oracle in sorted {\n            cumulative += oracle.weight;\n            if cumulative >= target_weight {\n                return Some(oracle.price);\n            }\n        }\n\n        sorted.last().map(|o| o.price)\n    }\n\n    pub fn remove_outliers(prices: &mut Vec<i64>, max_deviation_percent: f64) {\n        if let Some(median) = Self::calculate_median(prices) {\n            prices.retain(|&p| {\n                let deviation = ((p as f64 - median).abs() / median) * 100.0;\n                deviation <= max_deviation_percent\n            });\n        }\n    }\n\n    pub fn is_within_tolerance(price1: i64, price2: i64, tolerance_bps: u64) -> bool {\n        let diff = (price1 - price2).abs() as u128;\n        let base = price1.abs() as u128;\n        (diff * 10000) <= (base * tolerance_bps as u128)\n    }\n}",
              "hints": [
                "Sort prices and find middle element(s) for median",
                "For weighted median, accumulate weights until reaching 50%",
                "Use retain() to filter out outliers"
              ],
              "testCases": [
                {
                  "input": {
                    "prices": [
                      100,
                      200,
                      300
                    ]
                  },
                  "expected": {
                    "median": 200
                  }
                },
                {
                  "input": {
                    "prices": [
                      100,
                      200,
                      300,
                      400
                    ]
                  },
                  "expected": {
                    "median": 250
                  }
                },
                {
                  "input": {
                    "oracles": [
                      {
                        "price": 100,
                        "weight": 1
                      },
                      {
                        "price": 200,
                        "weight": 3
                      }
                    ]
                  },
                  "expected": {
                    "median": 200
                  }
                },
                {
                  "input": {
                    "price1": 10000,
                    "price2": 10100,
                    "tolerance": 100
                  },
                  "expected": {
                    "within": true
                  }
                }
              ]
            },
            {
              "id": "lesson-44-2-3",
              "type": "challenge",
              "title": "Oracle Consensus Challenge",
              "description": "Implement consensus checking across multiple oracle sources.",
              "starterCode": "pub struct ConsensusConfig {\n    pub min_sources: usize,\n    pub max_deviation_bps: u64,\n    pub required_agreement_percent: u8,\n}\n\npub struct ConsensusResult {\n    pub agreed_price: Option<i64>,\n    pub agreeing_sources: Vec<String>,\n    pub rejected_sources: Vec<String>,\n    pub consensus_reached: bool,\n}\n\npub struct OracleConsensus;\n\nimpl OracleConsensus {\n    pub fn check_consensus(\n        oracles: &[OraclePrice],\n        config: &ConsensusConfig,\n    ) -> ConsensusResult {\n        // TODO: Check if enough oracles agree within deviation tolerance\n        todo!(\"Implement check_consensus\")\n    }\n\n    pub fn find_consensus_price(prices: &[i64], max_deviation_bps: u64) -> Option<i64> {\n        // TODO: Find a price that at least 50% of sources agree with\n        todo!(\"Implement find_consensus_price\")\n    }\n\n    pub fn calculate_agreement_percent(agreeing: usize, total: usize) -> u8 {\n        // TODO: Calculate agreement percentage\n        todo!(\"Implement calculate_agreement_percent\")\n    }\n\n    pub fn has_sufficient_consensus(result: &ConsensusResult, config: &ConsensusConfig) -> bool {\n        // TODO: Check if consensus result meets minimum requirements\n        todo!(\"Implement has_sufficient_consensus\")\n    }\n}",
              "solution": "impl OracleConsensus {\n    pub fn check_consensus(\n        oracles: &[OraclePrice],\n        config: &ConsensusConfig,\n    ) -> ConsensusResult {\n        if oracles.len() < config.min_sources {\n            return ConsensusResult {\n                agreed_price: None,\n                agreeing_sources: vec![],\n                rejected_sources: oracles.iter().map(|o| o.source.clone()).collect(),\n                consensus_reached: false,\n            };\n        }\n\n        // Find consensus price\n        let prices: Vec<i64> = oracles.iter().map(|o| o.price).collect();\n        let consensus_price = Self::find_consensus_price(&prices, config.max_deviation_bps);\n\n        let mut agreeing = vec![];\n        let mut rejected = vec![];\n\n        if let Some(target) = consensus_price {\n            for oracle in oracles {\n                if MedianCalculator::is_within_tolerance(oracle.price, target, config.max_deviation_bps) {\n                    agreeing.push(oracle.source.clone());\n                } else {\n                    rejected.push(oracle.source.clone());\n                }\n            }\n        }\n\n        let agreement_pct = Self::calculate_agreement_percent(agreeing.len(), oracles.len());\n        let consensus_reached = agreement_pct >= config.required_agreement_percent;\n\n        ConsensusResult {\n            agreed_price: consensus_price,\n            agreeing_sources: agreeing,\n            rejected_sources: rejected,\n            consensus_reached,\n        }\n    }\n\n    pub fn find_consensus_price(prices: &[i64], max_deviation_bps: u64) -> Option<i64> {\n        if prices.is_empty() {\n            return None;\n        }\n\n        // Try each price as potential consensus\n        for &candidate in prices {\n            let agreeing = prices.iter().filter(|&&p| {\n                MedianCalculator::is_within_tolerance(p, candidate, max_deviation_bps)\n            }).count();\n\n            if agreeing * 2 >= prices.len() {\n                return Some(candidate);\n            }\n        }\n\n        None\n    }\n\n    pub fn calculate_agreement_percent(agreeing: usize, total: usize) -> u8 {\n        if total == 0 {\n            return 0;\n        }\n        ((agreeing as f64 / total as f64) * 100.0) as u8\n    }\n\n    pub fn has_sufficient_consensus(result: &ConsensusResult, config: &ConsensusConfig) -> bool {\n        result.consensus_reached && result.agreeing_sources.len() >= config.min_sources\n    }\n}",
              "hints": [
                "Check minimum sources first",
                "Find a price that at least 50% of oracles agree with",
                "Agreement percent is (agreeing / total) * 100"
              ],
              "testCases": [
                {
                  "input": {
                    "oracles": 5,
                    "min": 3,
                    "agree": 3
                  },
                  "expected": {
                    "consensus": true
                  }
                },
                {
                  "input": {
                    "prices": [
                      100,
                      101,
                      102,
                      150
                    ],
                    "deviation": 500
                  },
                  "expected": {
                    "consensus": 101
                  }
                },
                {
                  "input": {
                    "agreeing": 7,
                    "total": 10
                  },
                  "expected": {
                    "percent": 70
                  }
                },
                {
                  "input": {
                    "agreeing": 2,
                    "min": 3
                  },
                  "expected": {
                    "sufficient": false
                  }
                }
              ]
            },
            {
              "id": "lesson-44-2-4",
              "type": "challenge",
              "title": "Fallback Oracle Manager Challenge",
              "description": "Manage primary and fallback oracle sources.",
              "starterCode": "#[derive(Debug, Clone)]\npub enum OracleSource {\n    Primary,\n    Fallback1,\n    Fallback2,\n}\n\npub struct FallbackManager {\n    pub sources: Vec<(OracleSource, String)>,\n    pub current_source: usize,\n}\n\npub struct FallbackOracle;\n\nimpl FallbackOracle {\n    pub fn new(primary: String, fallback1: String, fallback2: String) -> FallbackManager {\n        // TODO: Create manager with ordered fallback sources\n        todo!(\"Implement new\")\n    }\n\n    pub fn get_current_source(&self, manager: &FallbackManager) -> Option<&String> {\n        // TODO: Get current active oracle source\n        todo!(\"Implement get_current_source\")\n    }\n\n    pub fn switch_to_fallback(&mut self, manager: &mut FallbackManager) -> bool {\n        // TODO: Switch to next fallback source\n        todo!(\"Implement switch_to_fallback\")\n    }\n\n    pub fn reset_to_primary(&mut self, manager: &mut FallbackManager) {\n        // TODO: Reset to primary source\n        todo!(\"Implement reset_to_primary\")\n    }\n\n    pub fn is_using_fallback(&self, manager: &FallbackManager) -> bool {\n        // TODO: Check if currently using fallback (not primary)\n        todo!(\"Implement is_using_fallback\")\n    }\n}",
              "solution": "impl FallbackOracle {\n    pub fn new(primary: String, fallback1: String, fallback2: String) -> FallbackManager {\n        FallbackManager {\n            sources: vec![\n                (OracleSource::Primary, primary),\n                (OracleSource::Fallback1, fallback1),\n                (OracleSource::Fallback2, fallback2),\n            ],\n            current_source: 0,\n        }\n    }\n\n    pub fn get_current_source(&self, manager: &FallbackManager) -> Option<&String> {\n        manager.sources.get(manager.current_source).map(|(_, url)| url)\n    }\n\n    pub fn switch_to_fallback(&mut self, manager: &mut FallbackManager) -> bool {\n        if manager.current_source + 1 < manager.sources.len() {\n            manager.current_source += 1;\n            true\n        } else {\n            false\n        }\n    }\n\n    pub fn reset_to_primary(&mut self, manager: &mut FallbackManager) {\n        manager.current_source = 0;\n    }\n\n    pub fn is_using_fallback(&self, manager: &FallbackManager) -> bool {\n        manager.current_source > 0\n    }\n}",
              "hints": [
                "Store sources in priority order",
                "current_source index tracks which is active",
                "Fallback if index > 0 (not primary)"
              ],
              "testCases": [
                {
                  "input": {
                    "sources": [
                      "primary",
                      "fb1",
                      "fb2"
                    ]
                  },
                  "expected": {
                    "current": "primary"
                  }
                },
                {
                  "input": {
                    "switch": true
                  },
                  "expected": {
                    "switched": true,
                    "current": "fb1"
                  }
                },
                {
                  "input": {
                    "switch": true
                  },
                  "expected": {
                    "switched": true,
                    "current": "fb2"
                  }
                },
                {
                  "input": {
                    "switch": true
                  },
                  "expected": {
                    "switched": false
                  }
                },
                {
                  "input": {
                    "check_fallback": true
                  },
                  "expected": {
                    "is_fallback": true
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "course-045",
      "slug": "solana-dao-tooling",
      "title": "DAO Tooling and Autonomous Organizations",
      "description": "Build production-ready DAO systems on Solana: proposal governance, voting integrity, treasury controls, and deterministic execution/reporting workflows.",
      "difficulty": "intermediate",
      "duration": "5 weeks",
      "totalXP": 1900,
      "tags": [
        "dao",
        "governance",
        "proposals",
        "voting",
        "treasury",
        "automation"
      ],
      "imageUrl": "/images/courses/solana-dao.svg",
      "modules": [
        {
          "id": "mod-45-1",
          "title": "DAO Governance Mechanics",
          "description": "Implement governance mechanics with explicit proposal lifecycle rules, voting-power logic, and deterministic state transitions.",
          "lessons": [
            {
              "id": "lesson-45-1-1",
              "type": "content",
              "title": "DAO Governance Architecture",
              "content": "DAO governance architecture is a system of enforceable process rules. Proposal creation, voting, and execution must be deterministic, auditable, and resistant to manipulation.\n\nA robust governance model defines:\n1) proposal lifecycle states and transitions,\n2) voter eligibility and power calculation,\n3) quorum/approval thresholds by action class,\n4) execution preconditions and cancellation paths.\n\nGovernance failures usually come from ambiguity: unclear thresholds, inconsistent snapshot timing, or weak transition validation.\n\nState transitions should be explicit and testable. Invalid transitions (for example executed -> voting) should fail with deterministic errors.\n\nVoting-power logic must also be transparent. Whether delegation, time-weighting, or quadratic models are used, outcomes should be reproducible from public inputs.\n\nDAO tooling quality is measured by predictability under pressure. During contentious proposals, deterministic behavior and clear reason codes are what preserve legitimacy."
            },
            {
              "id": "lesson-45-1-2",
              "type": "challenge",
              "title": "Proposal Lifecycle Manager Challenge",
              "description": "Manage DAO proposal states and transitions.",
              "starterCode": "#[derive(Debug, Clone, PartialEq)]\npub enum ProposalState {\n    Draft,\n    Active,\n    Succeeded,\n    Defeated,\n    Executed,\n    Cancelled,\n}\n\n#[derive(Debug, Clone)]\npub struct Proposal {\n    pub id: u64,\n    pub title: String,\n    pub description: String,\n    pub state: ProposalState,\n    pub start_time: u64,\n    pub end_time: u64,\n    pub for_votes: u64,\n    pub against_votes: u64,\n    pub proposer: String,\n}\n\npub struct ProposalManager;\n\nimpl ProposalManager {\n    pub fn can_transition(proposal: &Proposal, new_state: ProposalState, current_time: u64) -> bool {\n        // TODO: Check if state transition is valid\n        // Draft -> Active, Active -> Succeeded/Defeated, Succeeded -> Executed\n        todo!(\"Implement can_transition\")\n    }\n\n    pub fn transition(proposal: &mut Proposal, new_state: ProposalState, current_time: u64) -> Result<(), String> {\n        // TODO: Transition proposal to new state if valid\n        todo!(\"Implement transition\")\n    }\n\n    pub fn is_voting_active(proposal: &Proposal, current_time: u64) -> bool {\n        // TODO: Check if proposal is in voting period\n        todo!(\"Implement is_voting_active\")\n    }\n\n    pub fn has_quorum(proposal: &Proposal, total_supply: u64, quorum_bps: u64) -> bool {\n        // TODO: Check if total votes meet quorum requirement\n        todo!(\"Implement has_quorum\")\n    }\n\n    pub fn has_succeeded(proposal: &Proposal, threshold_bps: u64) -> bool {\n        // TODO: Check if for_votes / total_votes >= threshold\n        todo!(\"Implement has_succeeded\")\n    }\n}",
              "solution": "impl ProposalManager {\n    pub fn can_transition(proposal: &Proposal, new_state: ProposalState, current_time: u64) -> bool {\n        match (&proposal.state, &new_state) {\n            (ProposalState::Draft, ProposalState::Active) => true,\n            (ProposalState::Active, ProposalState::Succeeded) => {\n                current_time > proposal.end_time && proposal.for_votes > proposal.against_votes\n            }\n            (ProposalState::Active, ProposalState::Defeated) => {\n                current_time > proposal.end_time && proposal.for_votes <= proposal.against_votes\n            }\n            (ProposalState::Succeeded, ProposalState::Executed) => true,\n            (ProposalState::Draft, ProposalState::Cancelled) => true,\n            _ => false,\n        }\n    }\n\n    pub fn transition(proposal: &mut Proposal, new_state: ProposalState, current_time: u64) -> Result<(), String> {\n        if Self::can_transition(proposal, new_state.clone(), current_time) {\n            proposal.state = new_state;\n            Ok(())\n        } else {\n            Err(\"Invalid state transition\".to_string())\n        }\n    }\n\n    pub fn is_voting_active(proposal: &Proposal, current_time: u64) -> bool {\n        proposal.state == ProposalState::Active &&\n        current_time >= proposal.start_time &&\n        current_time <= proposal.end_time\n    }\n\n    pub fn has_quorum(proposal: &Proposal, total_supply: u64, quorum_bps: u64) -> bool {\n        let total_votes = proposal.for_votes + proposal.against_votes;\n        (total_votes as u128 * 10000) >= (total_supply as u128 * quorum_bps as u128)\n    }\n\n    pub fn has_succeeded(proposal: &Proposal, threshold_bps: u64) -> bool {\n        let total_votes = proposal.for_votes + proposal.against_votes;\n        if total_votes == 0 {\n            return false;\n        }\n        (proposal.for_votes as u128 * 10000) >= (total_votes as u128 * threshold_bps as u128)\n    }\n}",
              "hints": [
                "Match on (current, new) state pairs for valid transitions",
                "Voting active only during time window in Active state",
                "Quorum and threshold use basis point calculations"
              ],
              "testCases": [
                {
                  "input": {
                    "state": "Draft",
                    "new": "Active",
                    "time": 100
                  },
                  "expected": {
                    "can": true
                  }
                },
                {
                  "input": {
                    "state": "Active",
                    "for": 70,
                    "against": 30,
                    "end": 100,
                    "time": 150
                  },
                  "expected": {
                    "can_succeed": true
                  }
                },
                {
                  "input": {
                    "votes": 1000,
                    "supply": 10000,
                    "quorum": 500
                  },
                  "expected": {
                    "has_quorum": true
                  }
                },
                {
                  "input": {
                    "for": 700,
                    "against": 300,
                    "threshold": 5000
                  },
                  "expected": {
                    "succeeded": true
                  }
                }
              ]
            },
            {
              "id": "lesson-45-1-3",
              "type": "challenge",
              "title": "Voting Power Calculator Challenge",
              "description": "Calculate voting power with delegation and quadratic options.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct Voter {\n    pub address: String,\n    pub token_balance: u64,\n    pub delegated_to: Option<String>,\n}\n\npub struct VotingPowerConfig {\n    pub use_quadratic: bool,\n    pub max_voting_cap: Option<u64>,\n}\n\npub struct VotingPowerCalculator;\n\nimpl VotingPowerCalculator {\n    pub fn calculate_voting_power(voter: &Voter, config: &VotingPowerConfig) -> u64 {\n        // TODO: Calculate voting power for a voter\n        // If quadratic: sqrt(balance), else: balance\n        // Apply cap if configured\n        todo!(\"Implement calculate_voting_power\")\n    }\n\n    pub fn calculate_quadratic_voting_power(balance: u64) -> u64 {\n        // TODO: Calculate quadratic voting power (square root)\n        todo!(\"Implement calculate_quadratic_voting_power\")\n    }\n\n    pub fn get_effective_voters(voters: &[Voter]) -> Vec<&Voter> {\n        // TODO: Return voters who haven't delegated (have voting power)\n        todo!(\"Implement get_effective_voters\")\n    }\n\n    pub fn calculate_total_voting_power(voters: &[Voter], config: &VotingPowerConfig) -> u64 {\n        // TODO: Sum voting power of all effective voters\n        todo!(\"Implement calculate_total_voting_power\")\n    }\n}",
              "solution": "impl VotingPowerCalculator {\n    pub fn calculate_voting_power(voter: &Voter, config: &VotingPowerConfig) -> u64 {\n        if voter.delegated_to.is_some() {\n            return 0;\n        }\n\n        let power = if config.use_quadratic {\n            Self::calculate_quadratic_voting_power(voter.token_balance)\n        } else {\n            voter.token_balance\n        };\n\n        match config.max_voting_cap {\n            Some(cap) => power.min(cap),\n            None => power,\n        }\n    }\n\n    pub fn calculate_quadratic_voting_power(balance: u64) -> u64 {\n        (balance as f64).sqrt() as u64\n    }\n\n    pub fn get_effective_voters(voters: &[Voter]) -> Vec<&Voter> {\n        voters.iter().filter(|v| v.delegated_to.is_none()).collect()\n    }\n\n    pub fn calculate_total_voting_power(voters: &[Voter], config: &VotingPowerConfig) -> u64 {\n        Self::get_effective_voters(voters)\n            .iter()\n            .map(|v| Self::calculate_voting_power(v, config))\n            .sum()\n    }\n}",
              "hints": [
                "Delegated voters have 0 voting power",
                "Quadratic voting uses square root of balance",
                "Apply cap after calculating base power"
              ],
              "testCases": [
                {
                  "input": {
                    "balance": 10000,
                    "quadratic": false
                  },
                  "expected": {
                    "power": 10000
                  }
                },
                {
                  "input": {
                    "balance": 10000,
                    "quadratic": true
                  },
                  "expected": {
                    "power": 100
                  }
                },
                {
                  "input": {
                    "balance": 10000,
                    "cap": 5000
                  },
                  "expected": {
                    "power": 5000
                  }
                },
                {
                  "input": {
                    "delegated": "alice"
                  },
                  "expected": {
                    "power": 0
                  }
                }
              ]
            },
            {
              "id": "lesson-45-1-4",
              "type": "challenge",
              "title": "Delegation Manager Challenge",
              "description": "Manage vote delegation between DAO members.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct Delegation {\n    pub from: String,\n    pub to: String,\n    pub amount: u64,\n}\n\npub struct DelegationManager {\n    pub delegations: Vec<Delegation>,\n}\n\npub struct DelegationImpl;\n\nimpl DelegationImpl {\n    pub fn new() -> DelegationManager {\n        DelegationManager { delegations: vec![] }\n    }\n\n    pub fn delegate(manager: &mut DelegationManager, from: String, to: String, amount: u64) -> Result<(), String> {\n        // TODO: Create new delegation\n        todo!(\"Implement delegate\")\n    }\n\n    pub fn undelegate(manager: &mut DelegationManager, from: &str) -> Result<u64, String> {\n        // TODO: Remove delegation and return amount\n        todo!(\"Implement undelegate\")\n    }\n\n    pub fn get_delegated_amount(manager: &DelegationManager, to: &str) -> u64 {\n        // TODO: Get total amount delegated to an address\n        todo!(\"Implement get_delegated_amount\")\n    }\n\n    pub fn get_delegation(manager: &DelegationManager, from: &str) -> Option<&Delegation> {\n        // TODO: Get delegation for a specific address\n        todo!(\"Implement get_delegation\")\n    }\n}",
              "solution": "impl DelegationImpl {\n    pub fn new() -> DelegationManager {\n        DelegationManager { delegations: vec![] }\n    }\n\n    pub fn delegate(manager: &mut DelegationManager, from: String, to: String, amount: u64) -> Result<(), String> {\n        // Remove existing delegation if any\n        manager.delegations.retain(|d| d.from != from);\n\n        manager.delegations.push(Delegation { from, to, amount });\n        Ok(())\n    }\n\n    pub fn undelegate(manager: &mut DelegationManager, from: &str) -> Result<u64, String> {\n        if let Some(pos) = manager.delegations.iter().position(|d| d.from == from) {\n            let amount = manager.delegations[pos].amount;\n            manager.delegations.remove(pos);\n            Ok(amount)\n        } else {\n            Err(\"No delegation found\".to_string())\n        }\n    }\n\n    pub fn get_delegated_amount(manager: &DelegationManager, to: &str) -> u64 {\n        manager.delegations.iter().filter(|d| d.to == to).map(|d| d.amount).sum()\n    }\n\n    pub fn get_delegation(manager: &DelegationManager, from: &str) -> Option<&Delegation> {\n        manager.delegations.iter().find(|d| d.from == from)\n    }\n}",
              "hints": [
                "Remove existing delegation before creating new one",
                "Use position() and remove() to undelegate",
                "Filter and sum to get delegated amount"
              ],
              "testCases": [
                {
                  "input": {
                    "delegate": {
                      "from": "alice",
                      "to": "bob",
                      "amount": 1000
                    }
                  },
                  "expected": {
                    "delegated_to_bob": 1000
                  }
                },
                {
                  "input": {
                    "delegate": {
                      "from": "carol",
                      "to": "bob",
                      "amount": 500
                    }
                  },
                  "expected": {
                    "delegated_to_bob": 1500
                  }
                },
                {
                  "input": {
                    "undelegate": "alice"
                  },
                  "expected": {
                    "amount": 1000,
                    "to_bob": 500
                  }
                },
                {
                  "input": {
                    "get": "alice"
                  },
                  "expected": {
                    "delegation": null
                  }
                }
              ]
            }
          ]
        },
        {
          "id": "mod-45-2",
          "title": "Treasury and Execution",
          "description": "Engineer treasury and execution tooling with policy gates, timelock safeguards, and auditable automation outcomes.",
          "lessons": [
            {
              "id": "lesson-45-2-1",
              "type": "content",
              "title": "DAO Treasury Management",
              "content": "DAO treasury management is where governance intent becomes real financial action. Treasury tooling must therefore combine flexibility with strict policy constraints.\n\nCore controls include:\n- spending limits and role-based authority,\n- timelock windows for sensitive actions,\n- multisig/escalation paths,\n- deterministic execution logs.\n\nAutomated execution should never hide policy checks. Every executed action should reference the proposal, required approvals, and control checks passed.\n\nFailure handling is equally important. If execution fails mid-flow, tooling should expose exact failure stage and safe retry/rollback guidance.\n\nTreasury systems should also produce reconciliation artifacts: proposed vs executed amounts, remaining budget, and exception records.\n\nOperationally mature DAOs treat treasury automation as regulated process infrastructure: explicit controls, reproducible evidence, and clear accountability boundaries."
            },
            {
              "id": "lesson-45-2-2",
              "type": "challenge",
              "title": "Treasury Spending Limit Challenge",
              "description": "Implement spending limits and budget tracking for DAO treasury.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct SpendingLimit {\n    pub category: String,\n    pub amount_per_period: u64,\n    pub period_duration: u64,\n    pub spent_in_period: u64,\n    pub period_start: u64,\n}\n\npub struct Treasury {\n    pub balance: u64,\n    pub spending_limits: Vec<SpendingLimit>,\n}\n\npub struct TreasuryManager;\n\nimpl TreasuryManager {\n    pub fn can_spend(treasury: &Treasury, category: &str, amount: u64, current_time: u64) -> bool {\n        // TODO: Check if spending is within limits\n        todo!(\"Implement can_spend\")\n    }\n\n    pub fn record_spending(treasury: &mut Treasury, category: &str, amount: u64, current_time: u64) -> Result<(), String> {\n        // TODO: Record spending and update limits\n        todo!(\"Implement record_spending\")\n    }\n\n    pub fn reset_period(limits: &mut [SpendingLimit], current_time: u64) {\n        // TODO: Reset spending for limits whose period has passed\n        todo!(\"Implement reset_period\")\n    }\n\n    pub fn get_remaining_budget(treasury: &Treasury, category: &str, current_time: u64) -> u64 {\n        // TODO: Get remaining budget for category\n        todo!(\"Implement get_remaining_budget\")\n    }\n}",
              "solution": "impl TreasuryManager {\n    pub fn can_spend(treasury: &Treasury, category: &str, amount: u64, current_time: u64) -> bool {\n        if amount > treasury.balance {\n            return false;\n        }\n\n        if let Some(limit) = treasury.spending_limits.iter().find(|l| l.category == category) {\n            let remaining = Self::get_remaining_budget(treasury, category, current_time);\n            amount <= remaining\n        } else {\n            true // No limit set\n        }\n    }\n\n    pub fn record_spending(treasury: &mut Treasury, category: &str, amount: u64, current_time: u64) -> Result<(), String> {\n        if !Self::can_spend(treasury, category, amount, current_time) {\n            return Err(\"Spending exceeds limit\".to_string());\n        }\n\n        if let Some(limit) = treasury.spending_limits.iter_mut().find(|l| l.category == category) {\n            // Reset period if needed\n            if current_time >= limit.period_start + limit.period_duration {\n                limit.period_start = current_time;\n                limit.spent_in_period = 0;\n            }\n            limit.spent_in_period += amount;\n        }\n\n        treasury.balance -= amount;\n        Ok(())\n    }\n\n    pub fn reset_period(limits: &mut [SpendingLimit], current_time: u64) {\n        for limit in limits.iter_mut() {\n            if current_time >= limit.period_start + limit.period_duration {\n                limit.period_start = current_time;\n                limit.spent_in_period = 0;\n            }\n        }\n    }\n\n    pub fn get_remaining_budget(treasury: &Treasury, category: &str, current_time: u64) -> u64 {\n        if let Some(limit) = treasury.spending_limits.iter().find(|l| l.category == category) {\n            let mut spent = limit.spent_in_period;\n            if current_time >= limit.period_start + limit.period_duration {\n                spent = 0;\n            }\n            limit.amount_per_period.saturating_sub(spent)\n        } else {\n            u64::MAX\n        }\n    }\n}",
              "hints": [
                "Check balance and category limits before allowing spend",
                "Reset period if duration has passed",
                "Use saturating_sub to avoid underflow"
              ],
              "testCases": [
                {
                  "input": {
                    "balance": 10000,
                    "category": "ops",
                    "limit": 1000,
                    "spend": 500
                  },
                  "expected": {
                    "can": true
                  }
                },
                {
                  "input": {
                    "record": 500,
                    "limit": 1000
                  },
                  "expected": {
                    "remaining": 500
                  }
                },
                {
                  "input": {
                    "spend": 600,
                    "remaining": 500
                  },
                  "expected": {
                    "can": false
                  }
                },
                {
                  "input": {
                    "reset": true,
                    "time": 86400,
                    "duration": 86400
                  },
                  "expected": {
                    "reset": true
                  }
                }
              ]
            },
            {
              "id": "lesson-45-2-3",
              "type": "challenge",
              "title": "Timelock Executor Challenge",
              "description": "Implement timelock for delayed proposal execution.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct TimelockedOperation {\n    pub operation_id: u64,\n    pub target: String,\n    pub data: Vec<u8>,\n    pub eta: u64,  // Earliest execution time\n    pub executed: bool,\n}\n\npub struct Timelock {\n    pub min_delay: u64,\n    pub max_delay: u64,\n    pub operations: Vec<TimelockedOperation>,\n}\n\npub struct TimelockExecutor;\n\nimpl TimelockExecutor {\n    pub fn schedule(timelock: &mut Timelock, target: String, data: Vec<u8>, eta: u64) -> u64 {\n        // TODO: Schedule operation for future execution\n        todo!(\"Implement schedule\")\n    }\n\n    pub fn can_execute(timelock: &Timelock, operation_id: u64, current_time: u64) -> bool {\n        // TODO: Check if operation can be executed (ETA reached, not executed)\n        todo!(\"Implement can_execute\")\n    }\n\n    pub fn execute(timelock: &mut Timelock, operation_id: u64, current_time: u64) -> Result<(), String> {\n        // TODO: Execute timelocked operation\n        todo!(\"Implement execute\")\n    }\n\n    pub fn cancel(timelock: &mut Timelock, operation_id: u64) -> Result<(), String> {\n        // TODO: Cancel scheduled operation\n        todo!(\"Implement cancel\")\n    }\n}",
              "solution": "impl TimelockExecutor {\n    pub fn schedule(timelock: &mut Timelock, target: String, data: Vec<u8>, eta: u64) -> u64 {\n        let operation_id = timelock.operations.len() as u64;\n        timelock.operations.push(TimelockedOperation {\n            operation_id,\n            target,\n            data,\n            eta,\n            executed: false,\n        });\n        operation_id\n    }\n\n    pub fn can_execute(timelock: &Timelock, operation_id: u64, current_time: u64) -> bool {\n        if let Some(op) = timelock.operations.get(operation_id as usize) {\n            !op.executed && current_time >= op.eta\n        } else {\n            false\n        }\n    }\n\n    pub fn execute(timelock: &mut Timelock, operation_id: u64, current_time: u64) -> Result<(), String> {\n        if !Self::can_execute(timelock, operation_id, current_time) {\n            return Err(\"Cannot execute operation\".to_string());\n        }\n\n        if let Some(op) = timelock.operations.get_mut(operation_id as usize) {\n            op.executed = true;\n            Ok(())\n        } else {\n            Err(\"Operation not found\".to_string())\n        }\n    }\n\n    pub fn cancel(timelock: &mut Timelock, operation_id: u64) -> Result<(), String> {\n        if operation_id >= timelock.operations.len() as u64 {\n            return Err(\"Operation not found\".to_string());\n        }\n\n        let op = &timelock.operations[operation_id as usize];\n        if op.executed {\n            return Err(\"Already executed\".to_string());\n        }\n\n        timelock.operations.remove(operation_id as usize);\n        Ok(())\n    }\n}",
              "hints": [
                "Push operation and return index as ID",
                "Can execute only if ETA reached and not executed",
                "Remove operation from list to cancel"
              ],
              "testCases": [
                {
                  "input": {
                    "schedule": {
                      "eta": 1000
                    }
                  },
                  "expected": {
                    "id": 0
                  }
                },
                {
                  "input": {
                    "can_execute": {
                      "id": 0,
                      "time": 500
                    }
                  },
                  "expected": {
                    "can": false
                  }
                },
                {
                  "input": {
                    "can_execute": {
                      "id": 0,
                      "time": 1000
                    }
                  },
                  "expected": {
                    "can": true
                  }
                },
                {
                  "input": {
                    "execute": {
                      "id": 0,
                      "time": 1000
                    }
                  },
                  "expected": {
                    "executed": true
                  }
                }
              ]
            },
            {
              "id": "lesson-45-2-4",
              "type": "challenge",
              "title": "Automated Action Trigger Challenge",
              "description": "Implement automated triggers for DAO actions based on conditions.",
              "starterCode": "#[derive(Debug, Clone)]\npub enum Condition {\n    PriceAbove { token: String, price: u64 },\n    TimeReached { timestamp: u64 },\n    BalanceBelow { threshold: u64 },\n}\n\n#[derive(Debug, Clone)]\npub struct AutomatedAction {\n    pub action_id: u64,\n    pub condition: Condition,\n    pub action: String,\n    pub triggered: bool,\n}\n\npub struct AutomationEngine {\n    pub actions: Vec<AutomatedAction>,\n}\n\npub struct AutomationImpl;\n\nimpl AutomationImpl {\n    pub fn new() -> AutomationEngine {\n        AutomationEngine { actions: vec![] }\n    }\n\n    pub fn register_action(engine: &mut AutomationEngine, condition: Condition, action: String) -> u64 {\n        // TODO: Register new automated action\n        todo!(\"Implement register_action\")\n    }\n\n    pub fn check_condition(condition: &Condition, current_price: u64, current_time: u64, current_balance: u64) -> bool {\n        // TODO: Evaluate if condition is met\n        todo!(\"Implement check_condition\")\n    }\n\n    pub fn evaluate_triggers(engine: &mut AutomationEngine, current_price: u64, current_time: u64, current_balance: u64) -> Vec<u64> {\n        // TODO: Check all actions and return IDs of triggered actions\n        todo!(\"Implement evaluate_triggers\")\n    }\n\n    pub fn mark_triggered(engine: &mut AutomationEngine, action_id: u64) {\n        // TODO: Mark action as triggered\n        todo!(\"Implement mark_triggered\")\n    }\n}",
              "solution": "impl AutomationImpl {\n    pub fn new() -> AutomationEngine {\n        AutomationEngine { actions: vec![] }\n    }\n\n    pub fn register_action(engine: &mut AutomationEngine, condition: Condition, action: String) -> u64 {\n        let action_id = engine.actions.len() as u64;\n        engine.actions.push(AutomatedAction {\n            action_id,\n            condition,\n            action,\n            triggered: false,\n        });\n        action_id\n    }\n\n    pub fn check_condition(condition: &Condition, current_price: u64, current_time: u64, current_balance: u64) -> bool {\n        match condition {\n            Condition::PriceAbove { price, .. } => current_price >= *price,\n            Condition::TimeReached { timestamp } => current_time >= *timestamp,\n            Condition::BalanceBelow { threshold } => current_balance < *threshold,\n        }\n    }\n\n    pub fn evaluate_triggers(engine: &mut AutomationEngine, current_price: u64, current_time: u64, current_balance: u64) -> Vec<u64> {\n        let mut triggered = vec![];\n\n        for action in engine.actions.iter_mut() {\n            if !action.triggered && Self::check_condition(&action.condition, current_price, current_time, current_balance) {\n                triggered.push(action.action_id);\n            }\n        }\n\n        triggered\n    }\n\n    pub fn mark_triggered(engine: &mut AutomationEngine, action_id: u64) {\n        if let Some(action) = engine.actions.iter_mut().find(|a| a.action_id == action_id) {\n            action.triggered = true;\n        }\n    }\n}",
              "hints": [
                "Push action and return index as ID",
                "Match on condition type to evaluate",
                "Only return non-triggered actions that meet conditions"
              ],
              "testCases": [
                {
                  "input": {
                    "register": {
                      "condition": "TimeReached(1000)"
                    }
                  },
                  "expected": {
                    "id": 0
                  }
                },
                {
                  "input": {
                    "condition": "PriceAbove(5000)",
                    "price": 6000
                  },
                  "expected": {
                    "met": true
                  }
                },
                {
                  "input": {
                    "condition": "TimeReached(1000)",
                    "time": 1500
                  },
                  "expected": {
                    "met": true
                  }
                },
                {
                  "input": {
                    "evaluate": {
                      "time": 1500
                    }
                  },
                  "expected": {
                    "triggered": [
                      0
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "course-046",
      "slug": "solana-gaming",
      "title": "Gaming and Game State Management",
      "description": "Build production-ready on-chain game systems on Solana: efficient state models, turn integrity, fairness controls, and scalable player progression economics.",
      "difficulty": "intermediate",
      "duration": "5 weeks",
      "totalXP": 1850,
      "tags": [
        "gaming",
        "game-state",
        "randomness",
        "turn-based",
        "progression"
      ],
      "imageUrl": "/images/courses/solana-gaming.svg",
      "modules": [
        {
          "id": "mod-46-1",
          "title": "Game State Architecture",
          "description": "Design game state and turn logic with deterministic transitions, storage efficiency, and anti-cheat validation boundaries.",
          "lessons": [
            {
              "id": "lesson-46-1-1",
              "type": "content",
              "title": "On-Chain Game Design",
              "content": "On-chain game design on Solana is a systems-engineering tradeoff between fairness, responsiveness, and cost. The best designs keep critical rules verifiable while minimizing expensive state writes.\n\nCore architecture decisions:\n1) what state must be on-chain for trust,\n2) what can remain off-chain for speed,\n3) how turn validity is enforced deterministically.\n\nTurn-based mechanics should use explicit state transitions and guard checks (current actor, phase, cooldown, resource limits). If transitions are ambiguous, replay and dispute resolution become difficult.\n\nState compression and compact encoding matter because game loops can generate many updates. Efficient schemas reduce rent and compute pressure while preserving auditability.\n\nA production game model should also define anti-cheat boundaries. Even with deterministic logic, you need clear validation for illegal actions, stale turns, and duplicate submissions.\n\nReliable game infrastructure is measured by predictable outcomes under stress: same input actions, same resulting state, clear reject reasons for invalid actions."
            },
            {
              "id": "lesson-46-1-2",
              "type": "challenge",
              "title": "Turn Manager Challenge",
              "description": "Implement turn-based game mechanics with action validation.",
              "starterCode": "#[derive(Debug, Clone, PartialEq)]\npub enum TurnState {\n    WaitingForPlayer,\n    ActionSubmitted,\n    Resolved,\n}\n\n#[derive(Debug, Clone)]\npub struct GameTurn {\n    pub turn_number: u32,\n    pub current_player: String,\n    pub state: TurnState,\n    pub actions: Vec<PlayerAction>,\n    pub deadline: u64,\n}\n\n#[derive(Debug, Clone)]\npub struct PlayerAction {\n    pub player: String,\n    pub action_type: String,\n    pub data: Vec<u8>,\n}\n\npub struct TurnManager;\n\nimpl TurnManager {\n    pub fn can_submit_action(turn: &GameTurn, player: &str, current_time: u64) -> bool {\n        // TODO: Check if player can submit action (their turn, before deadline)\n        todo!(\"Implement can_submit_action\")\n    }\n\n    pub fn submit_action(turn: &mut GameTurn, player: String, action_type: String, data: Vec<u8>) -> Result<(), String> {\n        // TODO: Submit player action\n        todo!(\"Implement submit_action\")\n    }\n\n    pub fn is_turn_complete(turn: &GameTurn, player_count: usize) -> bool {\n        // TODO: Check if all players have submitted actions\n        todo!(\"Implement is_turn_complete\")\n    }\n\n    pub fn next_turn(current: &GameTurn, next_player: String, deadline: u64) -> GameTurn {\n        // TODO: Create next turn with incremented number\n        todo!(\"Implement next_turn\")\n    }\n\n    pub fn has_expired(turn: &GameTurn, current_time: u64) -> bool {\n        // TODO: Check if turn deadline has passed\n        todo!(\"Implement has_expired\")\n    }\n}",
              "solution": "impl TurnManager {\n    pub fn can_submit_action(turn: &GameTurn, player: &str, current_time: u64) -> bool {\n        turn.current_player == player && \n        turn.state == TurnState::WaitingForPlayer &&\n        current_time < turn.deadline\n    }\n\n    pub fn submit_action(turn: &mut GameTurn, player: String, action_type: String, data: Vec<u8>) -> Result<(), String> {\n        if turn.state != TurnState::WaitingForPlayer {\n            return Err(\"Turn not waiting for actions\".to_string());\n        }\n\n        turn.actions.push(PlayerAction { player, action_type, data });\n        turn.state = TurnState::ActionSubmitted;\n        Ok(())\n    }\n\n    pub fn is_turn_complete(turn: &GameTurn, player_count: usize) -> bool {\n        turn.actions.len() >= player_count\n    }\n\n    pub fn next_turn(current: &GameTurn, next_player: String, deadline: u64) -> GameTurn {\n        GameTurn {\n            turn_number: current.turn_number + 1,\n            current_player: next_player,\n            state: TurnState::WaitingForPlayer,\n            actions: vec![],\n            deadline,\n        }\n    }\n\n    pub fn has_expired(turn: &GameTurn, current_time: u64) -> bool {\n        current_time >= turn.deadline\n    }\n}",
              "hints": [
                "Check player matches, state is waiting, and before deadline",
                "Turn complete when all players submitted",
                "Increment turn number for next turn"
              ],
              "testCases": [
                {
                  "input": {
                    "player": "alice",
                    "current": "alice",
                    "deadline": 100,
                    "time": 50
                  },
                  "expected": {
                    "can": true
                  }
                },
                {
                  "input": {
                    "submit": {
                      "player": "alice",
                      "action": "move"
                    }
                  },
                  "expected": {
                    "actions": 1
                  }
                },
                {
                  "input": {
                    "actions": 3,
                    "players": 3
                  },
                  "expected": {
                    "complete": true
                  }
                },
                {
                  "input": {
                    "deadline": 100,
                    "time": 150
                  },
                  "expected": {
                    "expired": true
                  }
                }
              ]
            },
            {
              "id": "lesson-46-1-3",
              "type": "challenge",
              "title": "Game State Compressor Challenge",
              "description": "Compress game state for efficient on-chain storage.",
              "starterCode": "pub struct GameState {\n    pub player_positions: Vec<(String, u8, u8)>,  // (player, x, y)\n    pub player_health: Vec<(String, u8)>,\n    pub game_status: u8,  // 0=waiting, 1=active, 2=ended\n    pub round: u8,\n}\n\npub struct StateCompressor;\n\nimpl StateCompressor {\n    pub fn pack_position(x: u8, y: u8) -> u8 {\n        // TODO: Pack x,y coordinates into single byte (4 bits each)\n        todo!(\"Implement pack_position\")\n    }\n\n    pub fn unpack_position(packed: u8) -> (u8, u8) {\n        // TODO: Unpack x,y from single byte\n        todo!(\"Implement unpack_position\")\n    }\n\n    pub fn pack_health(health: u8, max_health: u8) -> u8 {\n        // TODO: Pack health as percentage (0-100) in 7 bits\n        todo!(\"Implement pack_health\")\n    }\n\n    pub fn calculate_state_size(state: &GameState) -> usize {\n        // TODO: Calculate serialized size of game state\n        todo!(\"Implement calculate_state_size\")\n    }\n}",
              "solution": "impl StateCompressor {\n    pub fn pack_position(x: u8, y: u8) -> u8 {\n        // Pack into 4 bits each (0-15 range)\n        ((x & 0x0F) << 4) | (y & 0x0F)\n    }\n\n    pub fn unpack_position(packed: u8) -> (u8, u8) {\n        let x = (packed >> 4) & 0x0F;\n        let y = packed & 0x0F;\n        (x, y)\n    }\n\n    pub fn pack_health(health: u8, max_health: u8) -> u8 {\n        if max_health == 0 {\n            return 0;\n        }\n        let percentage = (health as u16 * 100 / max_health as u16) as u8;\n        percentage.min(100)\n    }\n\n    pub fn calculate_state_size(state: &GameState) -> usize {\n        // Player ID strings + positions (1 byte each) + health (1 byte each) + status + round\n        let player_data: usize = state.player_positions.iter()\n            .map(|(id, _, _)| id.len() + 2)  // ID + packed position\n            .sum();\n        let health_data = state.player_health.len();\n        player_data + health_data + 2\n    }\n}",
              "hints": [
                "Use bit shifting to pack x in high 4 bits, y in low 4 bits",
                "Unpack by shifting and masking",
                "Health stored as percentage (0-100) fits in 7 bits"
              ],
              "testCases": [
                {
                  "input": {
                    "pack": {
                      "x": 5,
                      "y": 10
                    }
                  },
                  "expected": {
                    "packed": 90
                  }
                },
                {
                  "input": {
                    "unpack": 90
                  },
                  "expected": {
                    "x": 5,
                    "y": 10
                  }
                },
                {
                  "input": {
                    "health": 50,
                    "max": 100
                  },
                  "expected": {
                    "packed": 50
                  }
                },
                {
                  "input": {
                    "health": 25,
                    "max": 100
                  },
                  "expected": {
                    "packed": 25
                  }
                }
              ]
            },
            {
              "id": "lesson-46-1-4",
              "type": "challenge",
              "title": "Player Progression Tracker Challenge",
              "description": "Track player experience, levels, and achievements.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct PlayerProgress {\n    pub player: String,\n    pub level: u32,\n    pub experience: u64,\n    pub achievements: Vec<String>,\n}\n\npub struct ProgressionConfig {\n    pub base_xp: u64,\n    pub xp_multiplier: f64,\n}\n\npub struct ProgressionTracker;\n\nimpl ProgressionTracker {\n    pub fn xp_for_level(config: &ProgressionConfig, level: u32) -> u64 {\n        // TODO: Calculate XP required for level\n        // base * multiplier^(level-1)\n        todo!(\"Implement xp_for_level\")\n    }\n\n    pub fn add_experience(progress: &mut PlayerProgress, config: &ProgressionConfig, xp: u64) -> Vec<u32> {\n        // TODO: Add XP and return list of level-ups\n        todo!(\"Implement add_experience\")\n    }\n\n    pub fn unlock_achievement(progress: &mut PlayerProgress, achievement: String) -> bool {\n        // TODO: Add achievement if not already unlocked\n        todo!(\"Implement unlock_achievement\")\n    }\n\n    pub fn get_progress_to_next(progress: &PlayerProgress, config: &ProgressionConfig) -> (u64, u64) {\n        // TODO: Return (current_xp, xp_needed) for next level\n        todo!(\"Implement get_progress_to_next\")\n    }\n}",
              "solution": "impl ProgressionTracker {\n    pub fn xp_for_level(config: &ProgressionConfig, level: u32) -> u64 {\n        if level <= 1 {\n            return 0;\n        }\n        (config.base_xp as f64 * config.xp_multiplier.powi(level as i32 - 1)) as u64\n    }\n\n    pub fn add_experience(progress: &mut PlayerProgress, config: &ProgressionConfig, xp: u64) -> Vec<u32> {\n        progress.experience += xp;\n        let mut level_ups = vec![];\n\n        loop {\n            let needed = Self::xp_for_level(config, progress.level + 1);\n            if progress.experience >= needed && needed > 0 {\n                progress.level += 1;\n                level_ups.push(progress.level);\n            } else {\n                break;\n            }\n        }\n\n        level_ups\n    }\n\n    pub fn unlock_achievement(progress: &mut PlayerProgress, achievement: String) -> bool {\n        if progress.achievements.contains(&achievement) {\n            return false;\n        }\n        progress.achievements.push(achievement);\n        true\n    }\n\n    pub fn get_progress_to_next(progress: &PlayerProgress, config: &ProgressionConfig) -> (u64, u64) {\n        let next_level = progress.level + 1;\n        let needed = Self::xp_for_level(config, next_level);\n        (progress.experience, needed)\n    }\n}",
              "hints": [
                "XP formula: base * multiplier^(level-1)",
                "Keep leveling up while XP exceeds requirement",
                "Check contains() before adding achievement"
              ],
              "testCases": [
                {
                  "input": {
                    "base": 100,
                    "multiplier": 2,
                    "level": 2
                  },
                  "expected": {
                    "xp": 200
                  }
                },
                {
                  "input": {
                    "base": 100,
                    "multiplier": 2,
                    "level": 5
                  },
                  "expected": {
                    "xp": 1600
                  }
                },
                {
                  "input": {
                    "level": 1,
                    "xp": 250,
                    "add": 100
                  },
                  "expected": {
                    "level_ups": [
                      2
                    ]
                  }
                },
                {
                  "input": {
                    "achievement": "first_win"
                  },
                  "expected": {
                    "unlocked": true
                  }
                }
              ]
            }
          ]
        },
        {
          "id": "mod-46-2",
          "title": "Randomness and Fairness",
          "description": "Implement fairness-oriented randomness and integrity controls that keep gameplay auditable and dispute-resistant.",
          "lessons": [
            {
              "id": "lesson-46-2-1",
              "type": "content",
              "title": "On-Chain Randomness",
              "content": "Randomness is one of the hardest fairness problems in blockchain games because execution is deterministic. Robust designs avoid naive pseudo-randomness tied directly to manipulable context.\n\nPractical fairness patterns include commit-reveal, VRF-backed randomness, and delayed-seed schemes. Each has latency/trust tradeoffs:\n- commit-reveal: simple and transparent, but requires multi-step interaction,\n- VRF: stronger unpredictability, but introduces oracle/dependency considerations,\n- delayed-seed methods: lower overhead but weaker guarantees under adversarial pressure.\n\nFairness engineering should specify:\n1) who can influence randomness inputs,\n2) when values become immutable,\n3) how unresolved rounds are handled on timeout.\n\nProduction systems should emit deterministic round evidence (commit hash, reveal value, validation result) so disputes can be resolved quickly.\n\nGame fairness is credible when randomness mechanisms are explicit, verifiable, and resilient to timing manipulation."
            },
            {
              "id": "lesson-46-2-2",
              "type": "challenge",
              "title": "Commit-Reveal Challenge",
              "description": "Implement commit-reveal scheme for fair randomness.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct Commitment {\n    pub player: String,\n    pub hash: [u8; 32],\n    pub timestamp: u64,\n}\n\n#[derive(Debug, Clone)]\npub struct Reveal {\n    pub player: String,\n    pub value: u64,\n    pub nonce: u64,\n}\n\npub struct CommitReveal;\n\nimpl CommitReveal {\n    pub fn commit(commitments: &mut Vec<Commitment>, player: String, hash: [u8; 32], timestamp: u64) {\n        // TODO: Add player commitment\n        todo!(\"Implement commit\")\n    }\n\n    pub fn verify_reveal(commitment: &Commitment, reveal: &Reveal) -> bool {\n        // TODO: Verify that reveal matches commitment hash\n        // hash(value + nonce) should equal commitment hash\n        todo!(\"Implement verify_reveal\")\n    }\n\n    pub fn has_committed(commitments: &[Commitment], player: &str) -> bool {\n        // TODO: Check if player has made a commitment\n        todo!(\"Implement has_committed\")\n    }\n\n    pub fn generate_random(reveals: &[Reveal]) -> u64 {\n        // TODO: Generate random number by XORing all revealed values\n        todo!(\"Implement generate_random\")\n    }\n}",
              "solution": "impl CommitReveal {\n    pub fn commit(commitments: &mut Vec<Commitment>, player: String, hash: [u8; 32], timestamp: u64) {\n        commitments.push(Commitment { player, hash, timestamp });\n    }\n\n    pub fn verify_reveal(commitment: &Commitment, reveal: &Reveal) -> bool {\n        // Simple hash simulation: XOR of value bytes + nonce\n        let mut computed_hash = [0u8; 32];\n        let value_bytes = reveal.value.to_le_bytes();\n        let nonce_bytes = reveal.nonce.to_le_bytes();\n\n        for i in 0..8 {\n            computed_hash[i] = value_bytes[i] ^ nonce_bytes[i];\n        }\n\n        computed_hash == commitment.hash\n    }\n\n    pub fn has_committed(commitments: &[Commitment], player: &str) -> bool {\n        commitments.iter().any(|c| c.player == player)\n    }\n\n    pub fn generate_random(reveals: &[Reveal]) -> u64 {\n        reveals.iter().fold(0u64, |acc, r| acc ^ r.value)\n    }\n}",
              "hints": [
                "Push commitment to vector",
                "Verify by recomputing hash from reveal",
                "XOR all revealed values for combined randomness"
              ],
              "testCases": [
                {
                  "input": {
                    "commit": {
                      "player": "alice"
                    }
                  },
                  "expected": {
                    "count": 1
                  }
                },
                {
                  "input": {
                    "check": "alice"
                  },
                  "expected": {
                    "committed": true
                  }
                },
                {
                  "input": {
                    "reveals": [
                      {
                        "value": 5
                      },
                      {
                        "value": 3
                      }
                    ]
                  },
                  "expected": {
                    "random": 6
                  }
                },
                {
                  "input": {
                    "reveals": [
                      {
                        "value": 255
                      },
                      {
                        "value": 255
                      }
                    ]
                  },
                  "expected": {
                    "random": 0
                  }
                }
              ]
            },
            {
              "id": "lesson-46-2-3",
              "type": "challenge",
              "title": "Dice Roller Challenge",
              "description": "Implement verifiable dice rolling with randomness.",
              "starterCode": "pub struct DiceRoller;\n\nimpl DiceRoller {\n    pub fn roll_d6(seed: u64) -> u8 {\n        // TODO: Roll a 6-sided die using seed\n        // Result: 1-6\n        todo!(\"Implement roll_d6\")\n    }\n\n    pub fn roll_d20(seed: u64) -> u8 {\n        // TODO: Roll a 20-sided die using seed\n        // Result: 1-20\n        todo!(\"Implement roll_d20\")\n    }\n\n    pub fn roll_multiple(seed: u64, sides: u8, count: u8) -> Vec<u8> {\n        // TODO: Roll multiple dice, using seed + index for each\n        todo!(\"Implement roll_multiple\")\n    }\n\n    pub fn roll_with_modifier(seed: u64, sides: u8, modifier: i8) -> i16 {\n        // TODO: Roll die and add modifier\n        todo!(\"Implement roll_with_modifier\")\n    }\n\n    pub fn roll_stat_array(seed: u64) -> [u8; 6] {\n        // TODO: Roll 6 stats using 4d6 drop lowest\n        todo!(\"Implement roll_stat_array\")\n    }\n}",
              "solution": "impl DiceRoller {\n    fn hash_seed(seed: u64) -> u64 {\n        // Simple hash function\n        let mut x = seed;\n        x = (x ^ (x >> 30)).wrapping_mul(0xbf58476d1ce4e5b9);\n        x = (x ^ (x >> 27)).wrapping_mul(0x94d049bb133111eb);\n        x ^ (x >> 31)\n    }\n\n    pub fn roll_d6(seed: u64) -> u8 {\n        let hash = Self::hash_seed(seed);\n        ((hash % 6) + 1) as u8\n    }\n\n    pub fn roll_d20(seed: u64) -> u8 {\n        let hash = Self::hash_seed(seed);\n        ((hash % 20) + 1) as u8\n    }\n\n    pub fn roll_multiple(seed: u64, sides: u8, count: u8) -> Vec<u8> {\n        (0..count)\n            .map(|i| {\n                let hash = Self::hash_seed(seed.wrapping_add(i as u64));\n                ((hash % sides as u64) + 1) as u8\n            })\n            .collect()\n    }\n\n    pub fn roll_with_modifier(seed: u64, sides: u8, modifier: i8) -> i16 {\n        let hash = Self::hash_seed(seed);\n        let roll = ((hash % sides as u64) + 1) as i16;\n        roll + modifier as i16\n    }\n\n    pub fn roll_stat_array(seed: u64) -> [u8; 6] {\n        let mut stats = [0u8; 6];\n        for i in 0..6 {\n            let rolls = Self::roll_multiple(seed.wrapping_add(i as u64 * 100), 6, 4);\n            let sum: u8 = rolls.iter().sum();\n            let min = rolls.iter().min().unwrap_or(&0);\n            stats[i] = sum - min;\n        }\n        stats\n    }\n}",
              "hints": [
                "Use hash of seed for deterministic randomness",
                "Modulo operation gives range, add 1 for 1-based",
                "4d6 drop lowest: roll 4, sum all, subtract minimum"
              ],
              "testCases": [
                {
                  "input": {
                    "roll": "d6",
                    "seed": 12345
                  },
                  "expected": {
                    "range": "1-6"
                  }
                },
                {
                  "input": {
                    "roll": "d20",
                    "seed": 12345
                  },
                  "expected": {
                    "range": "1-20"
                  }
                },
                {
                  "input": {
                    "multiple": {
                      "sides": 6,
                      "count": 3
                    }
                  },
                  "expected": {
                    "count": 3
                  }
                },
                {
                  "input": {
                    "stat_array": true
                  },
                  "expected": {
                    "stats": 6
                  }
                }
              ]
            },
            {
              "id": "lesson-46-2-4",
              "type": "challenge",
              "title": "Loot Table Challenge",
              "description": "Implement weighted loot tables for game rewards.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct LootItem {\n    pub name: String,\n    pub weight: u32,\n    pub min_quantity: u32,\n    pub max_quantity: u32,\n}\n\npub struct LootTable {\n    pub items: Vec<LootItem>,\n}\n\npub struct LootGenerator;\n\nimpl LootGenerator {\n    pub fn total_weight(table: &LootTable) -> u32 {\n        // TODO: Calculate total weight of all items\n        todo!(\"Implement total_weight\")\n    }\n\n    pub fn roll_loot(table: &LootTable, seed: u64) -> Option<(String, u32)> {\n        // TODO: Roll for loot using weighted probabilities\n        todo!(\"Implement roll_loot\")\n    }\n\n    pub fn roll_multiple_loot(table: &LootTable, seed: u64, rolls: u8) -> Vec<(String, u32)> {\n        // TODO: Roll multiple times for loot\n        todo!(\"Implement roll_multiple_loot\")\n    }\n\n    pub fn get_rarity_probability(table: &LootTable, item_name: &str) -> Option<f64> {\n        // TODO: Get probability of specific item dropping\n        todo!(\"Implement get_rarity_probability\")\n    }\n}",
              "solution": "impl LootGenerator {\n    pub fn total_weight(table: &LootTable) -> u32 {\n        table.items.iter().map(|i| i.weight).sum()\n    }\n\n    pub fn roll_loot(table: &LootTable, seed: u64) -> Option<(String, u32)> {\n        let total = Self::total_weight(table);\n        if total == 0 {\n            return None;\n        }\n\n        // Simple hash for randomness\n        let mut x = seed;\n        x = (x ^ (x >> 30)).wrapping_mul(0xbf58476d1ce4e5b9);\n        let roll = (x % total as u64) as u32;\n\n        let mut cumulative = 0;\n        for item in &table.items {\n            cumulative += item.weight;\n            if roll < cumulative {\n                // Determine quantity\n                let qty_seed = seed.wrapping_mul(item.weight as u64);\n                let qty_range = item.max_quantity - item.min_quantity + 1;\n                let qty = item.min_quantity + (qty_seed % qty_range as u64) as u32;\n                return Some((item.name.clone(), qty));\n            }\n        }\n\n        None\n    }\n\n    pub fn roll_multiple_loot(table: &LootTable, seed: u64, rolls: u8) -> Vec<(String, u32)> {\n        (0..rolls)\n            .filter_map(|i| Self::roll_loot(table, seed.wrapping_add(i as u64 * 1000)))\n            .collect()\n    }\n\n    pub fn get_rarity_probability(table: &LootTable, item_name: &str) -> Option<f64> {\n        let total = Self::total_weight(table);\n        table.items.iter().find(|i| i.name == item_name)\n            .map(|item| item.weight as f64 / total as f64)\n    }\n}",
              "hints": [
                "Sum all weights for total",
                "Generate random number in range [0, total)",
                "Find item where cumulative weight exceeds roll"
              ],
              "testCases": [
                {
                  "input": {
                    "items": [
                      {
                        "weight": 10
                      },
                      {
                        "weight": 20
                      }
                    ]
                  },
                  "expected": {
                    "total": 30
                  }
                },
                {
                  "input": {
                    "items": [
                      {
                        "name": "common",
                        "weight": 70
                      },
                      {
                        "name": "rare",
                        "weight": 30
                      }
                    ]
                  },
                  "expected": {
                    "rare_prob": 0.3
                  }
                },
                {
                  "input": {
                    "rolls": 5
                  },
                  "expected": {
                    "count": 5
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "course-047",
      "slug": "solana-permanent-storage",
      "title": "Permanent Storage and Arweave",
      "description": "Integrate permanent decentralized storage with Solana using Arweave-style workflows: content addressing, manifest integrity, and verifiable long-term data access.",
      "difficulty": "intermediate",
      "duration": "4 weeks",
      "totalXP": 1700,
      "tags": [
        "storage",
        "arweave",
        "permanent",
        "bundling",
        "manifest"
      ],
      "imageUrl": "/images/courses/solana-storage.svg",
      "modules": [
        {
          "id": "mod-47-1",
          "title": "Arweave Fundamentals",
          "description": "Understand permanent-storage architecture and build deterministic linking between Solana state and external immutable content.",
          "lessons": [
            {
              "id": "lesson-47-1-1",
              "type": "content",
              "title": "Permanent Storage Architecture",
              "content": "Permanent storage integration is a data durability contract. On Solana, storing full content on-chain is often impractical, so systems rely on immutable external storage references anchored by on-chain metadata.\n\nA robust architecture defines:\n1) canonical content identifiers,\n2) integrity verification method,\n3) fallback retrieval behavior,\n4) lifecycle policy for metadata updates.\n\nContent-addressed design is critical. If identifiers are not tied to content hash semantics, integrity guarantees weaken and replayed/wrong assets can be served.\n\nStorage integration should also separate control-plane and data-plane concerns: on-chain records govern ownership/version pointers, while external storage handles large payload persistence.\n\nProduction reliability requires deterministic verification reports (ID format validity, expected hash match, availability checks). This makes failures diagnosable and prevents silent corruption.\n\nPermanent storage systems succeed when users can independently verify that referenced content matches what governance or protocol state claims."
            },
            {
              "id": "lesson-47-1-2",
              "type": "challenge",
              "title": "Transaction ID Validator Challenge",
              "description": "Validate Arweave transaction IDs and URLs.",
              "starterCode": "pub struct ArweaveValidator;\n\nimpl ArweaveValidator {\n    pub const TX_ID_LENGTH: usize = 43;\n\n    pub fn is_valid_tx_id(tx_id: &str) -> bool {\n        todo!(\"Implement is_valid_tx_id\")\n    }\n\n    pub fn is_base64url_char(c: char) -> bool {\n        todo!(\"Implement is_base64url_char\")\n    }\n\n    pub fn to_view_url(tx_id: &str) -> Option<String> {\n        todo!(\"Implement to_view_url\")\n    }\n}",
              "solution": "impl ArweaveValidator {\n    pub const TX_ID_LENGTH: usize = 43;\n\n    pub fn is_valid_tx_id(tx_id: &str) -> bool {\n        if tx_id.len() != Self::TX_ID_LENGTH {\n            return false;\n        }\n        tx_id.chars().all(Self::is_base64url_char)\n    }\n\n    pub fn is_base64url_char(c: char) -> bool {\n        c.is_ascii_alphanumeric() || c == '-' || c == '_'\n    }\n\n    pub fn to_view_url(tx_id: &str) -> Option<String> {\n        if Self::is_valid_tx_id(tx_id) {\n            Some(format!(\"https://arweave.net/{}\", tx_id))\n        } else {\n            None\n        }\n    }\n}",
              "hints": [
                "Check exact length and all characters valid",
                "base64url uses alphanumeric plus - and _"
              ],
              "testCases": [
                {
                  "input": {
                    "tx_id": "valid_tx_id_43_chars_long_aaaaaaaaaaaaaaaa"
                  },
                  "expected": {
                    "valid": true
                  }
                },
                {
                  "input": {
                    "tx_id": "short"
                  },
                  "expected": {
                    "valid": false
                  }
                },
                {
                  "input": {
                    "to_url": "valid_tx_id_43_chars_long_aaaaaaaaaaaaaaaa"
                  },
                  "expected": {
                    "url": "https://arweave.net/valid_tx_id_43_chars_long_aaaaaaaaaaaaaaaa"
                  }
                }
              ]
            },
            {
              "id": "lesson-47-1-3",
              "type": "challenge",
              "title": "Storage Cost Estimator Challenge",
              "description": "Estimate Arweave storage costs based on data size.",
              "starterCode": "pub struct ArweavePricing {\n    pub usd_per_ar: f64,\n    pub winston_per_ar: u64,\n    pub base_fee_winston: u64,\n}\n\npub struct CostEstimator;\n\nimpl CostEstimator {\n    pub const BYTES_PER_WINSTON: u64 = 1024 * 1024;\n\n    pub fn estimate_cost(pricing: &ArweavePricing, data_size_bytes: u64) -> f64 {\n        todo!(\"Implement estimate_cost\")\n    }\n\n    pub fn estimate_cost_in_ar(pricing: &ArweavePricing, data_size_bytes: u64) -> f64 {\n        todo!(\"Implement estimate_cost_in_ar\")\n    }\n}",
              "solution": "impl CostEstimator {\n    pub const BYTES_PER_WINSTON: u64 = 1024 * 1024;\n\n    pub fn estimate_cost(pricing: &ArweavePricing, data_size_bytes: u64) -> f64 {\n        let storage_cost = data_size_bytes / Self::BYTES_PER_WINSTON;\n        let total_winston = storage_cost + pricing.base_fee_winston;\n        let ar_cost = total_winston as f64 / pricing.winston_per_ar as f64;\n        ar_cost * pricing.usd_per_ar\n    }\n\n    pub fn estimate_cost_in_ar(pricing: &ArweavePricing, data_size_bytes: u64) -> f64 {\n        let storage_cost = data_size_bytes / Self::BYTES_PER_WINSTON;\n        let total_winston = storage_cost + pricing.base_fee_winston;\n        total_winston as f64 / pricing.winston_per_ar as f64\n    }\n}",
              "hints": [
                "Calculate winston cost then convert to USD"
              ],
              "testCases": [
                {
                  "input": {
                    "size": 10485760,
                    "usd_per_ar": 10
                  },
                  "expected": {
                    "cost": 0.1
                  }
                },
                {
                  "input": {
                    "size": 10485760
                  },
                  "expected": {
                    "ar": 0.01
                  }
                }
              ]
            },
            {
              "id": "lesson-47-1-4",
              "type": "challenge",
              "title": "Bundle Optimizer Challenge",
              "description": "Optimize data bundling for efficient Arweave uploads.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct DataItem {\n    pub id: String,\n    pub size: u64,\n    pub priority: u8,\n}\n\npub struct BundleConfig {\n    pub max_bundle_size: u64,\n    pub max_items_per_bundle: usize,\n}\n\npub struct BundleOptimizer;\n\nimpl BundleOptimizer {\n    pub fn can_bundle(items: &[DataItem], config: &BundleConfig) -> bool {\n        todo!(\"Implement can_bundle\")\n    }\n\n    pub fn create_bundle(items: &mut Vec<DataItem>, config: &BundleConfig) -> Vec<DataItem> {\n        todo!(\"Implement create_bundle\")\n    }\n}",
              "solution": "impl BundleOptimizer {\n    pub fn can_bundle(items: &[DataItem], config: &BundleConfig) -> bool {\n        let total_size: u64 = items.iter().map(|i| i.size).sum();\n        let item_count = items.len();\n        total_size <= config.max_bundle_size && item_count <= config.max_items_per_bundle\n    }\n\n    pub fn create_bundle(items: &mut Vec<DataItem>, config: &BundleConfig) -> Vec<DataItem> {\n        items.sort_by(|a, b| b.priority.cmp(&a.priority));\n        let mut bundle = vec![];\n        let mut current_size = 0u64;\n        let mut i = 0;\n        while i < items.len() {\n            let item = &items[i];\n            if bundle.len() >= config.max_items_per_bundle {\n                break;\n            }\n            if current_size + item.size > config.max_bundle_size {\n                i += 1;\n                continue;\n            }\n            current_size += item.size;\n            bundle.push(items.remove(i));\n        }\n        bundle\n    }\n}",
              "hints": [
                "Sort items by priority before bundling"
              ],
              "testCases": [
                {
                  "input": {
                    "items": [
                      {
                        "size": 100
                      },
                      {
                        "size": 200
                      }
                    ],
                    "max": 500
                  },
                  "expected": {
                    "can": true
                  }
                },
                {
                  "input": {
                    "items": [
                      {
                        "priority": 10
                      },
                      {
                        "priority": 5
                      }
                    ],
                    "bundle": true
                  },
                  "expected": {
                    "first": 10
                  }
                }
              ]
            }
          ]
        },
        {
          "id": "mod-47-2",
          "title": "Manifests and Verification",
          "description": "Work with manifests, verification pipelines, and cost/performance controls for reliable long-lived data serving.",
          "lessons": [
            {
              "id": "lesson-47-2-1",
              "type": "content",
              "title": "Arweave Manifests",
              "content": "Manifests turn many stored assets into one navigable root, but they introduce their own integrity responsibilities. A manifest is only trustworthy if path mapping and referenced content IDs are validated consistently.\n\nKey safeguards:\n- deterministic path normalization,\n- duplicate/ambiguous key rejection,\n- strict transaction-ID validation,\n- recursive integrity checks for referenced content.\n\nManifest tooling should produce auditable outputs: resolved entries count, missing references, and hash verification status by path.\n\nFrom an operational standpoint, cost optimization should not compromise integrity. Bundling strategies, compression, and metadata minimization are useful only if verification remains straightforward and deterministic.\n\nWell-run permanent-storage pipelines treat manifests as governed artifacts with versioned schema expectations and repeatable validation in CI."
            },
            {
              "id": "lesson-47-2-2",
              "type": "challenge",
              "title": "Manifest Builder Challenge",
              "description": "Build and parse Arweave manifests.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct ManifestEntry {\n    pub path: String,\n    pub tx_id: String,\n}\n\n#[derive(Debug, Clone)]\npub struct Manifest {\n    pub index: Option<String>,\n    pub fallback: Option<String>,\n    pub entries: Vec<ManifestEntry>,\n}\n\npub struct ManifestBuilder;\n\nimpl ManifestBuilder {\n    pub fn add_entry(manifest: &mut Manifest, path: String, tx_id: String) -> Result<(), String> {\n        todo!(\"Implement add_entry\")\n    }\n\n    pub fn resolve_path(manifest: &Manifest, path: &str) -> Option<String> {\n        todo!(\"Implement resolve_path\")\n    }\n}",
              "solution": "impl ManifestBuilder {\n    pub fn add_entry(manifest: &mut Manifest, path: String, tx_id: String) -> Result<(), String> {\n        if tx_id.len() != 43 {\n            return Err(\"Invalid transaction ID\".to_string());\n        }\n        if manifest.entries.iter().any(|e| e.path == path) {\n            return Err(\"Path already exists\".to_string());\n        }\n        manifest.entries.push(ManifestEntry { path, tx_id });\n        Ok(())\n    }\n\n    pub fn resolve_path(manifest: &Manifest, path: &str) -> Option<String> {\n        if let Some(entry) = manifest.entries.iter().find(|e| e.path == path) {\n            return Some(entry.tx_id.clone());\n        }\n        if path.is_empty() || path == \"/\" {\n            if let Some(index) = &manifest.index {\n                if let Some(entry) = manifest.entries.iter().find(|e| e.path == *index) {\n                    return Some(entry.tx_id.clone());\n                }\n            }\n        }\n        manifest.fallback.clone()\n    }\n}",
              "hints": [
                "Validate tx_id length before adding",
                "Resolve in order: exact, index, fallback"
              ],
              "testCases": [
                {
                  "input": {
                    "add": {
                      "path": "/index.html",
                      "tx_id": "tx_id_43_chars_long_aaaaaaaaaaaaaaaaaaaaa"
                    }
                  },
                  "expected": {
                    "count": 1
                  }
                },
                {
                  "input": {
                    "resolve": "/index.html"
                  },
                  "expected": {
                    "found": true
                  }
                }
              ]
            },
            {
              "id": "lesson-47-2-3",
              "type": "challenge",
              "title": "Data Verifier Challenge",
              "description": "Verify data integrity and availability on Arweave.",
              "starterCode": "pub struct DataVerifier;\n\nimpl DataVerifier {\n    pub const MIN_CONFIRMATIONS: u64 = 10;\n\n    pub fn is_sufficiently_confirmed(confirmations: u64) -> bool {\n        todo!(\"Implement is_sufficiently_confirmed\")\n    }\n}",
              "solution": "impl DataVerifier {\n    pub const MIN_CONFIRMATIONS: u64 = 10;\n\n    pub fn is_sufficiently_confirmed(confirmations: u64) -> bool {\n        confirmations >= Self::MIN_CONFIRMATIONS\n    }\n}",
              "hints": [
                "MIN_CONFIRMATIONS defines 'sufficient' threshold"
              ],
              "testCases": [
                {
                  "input": {
                    "conf": 15
                  },
                  "expected": {
                    "sufficient": true
                  }
                },
                {
                  "input": {
                    "conf": 5
                  },
                  "expected": {
                    "sufficient": false
                  }
                }
              ]
            },
            {
              "id": "lesson-47-2-4",
              "type": "challenge",
              "title": "Storage Indexer Challenge",
              "description": "Index and query stored data by tags.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct StoredItem {\n    pub tx_id: String,\n    pub tags: Vec<(String, String)>,\n    pub size: u64,\n}\n\npub struct StorageIndex {\n    pub items: Vec<StoredItem>,\n}\n\npub struct StorageIndexer;\n\nimpl StorageIndexer {\n    pub fn new() -> StorageIndex {\n        StorageIndex { items: vec![] }\n    }\n\n    pub fn add_item(index: &mut StorageIndex, item: StoredItem) {\n        todo!(\"Implement add_item\")\n    }\n\n    pub fn find_by_tag(index: &StorageIndex, tag_name: &str, tag_value: &str) -> Vec<&StoredItem> {\n        todo!(\"Implement find_by_tag\")\n    }\n}",
              "solution": "impl StorageIndexer {\n    pub fn new() -> StorageIndex {\n        StorageIndex { items: vec![] }\n    }\n\n    pub fn add_item(index: &mut StorageIndex, item: StoredItem) {\n        index.items.push(item);\n    }\n\n    pub fn find_by_tag(index: &StorageIndex, tag_name: &str, tag_value: &str) -> Vec<&StoredItem> {\n        index.items.iter()\n            .filter(|item| item.tags.iter().any(|(k, v)| k == tag_name && v == tag_value))\n            .collect()\n    }\n}",
              "hints": [
                "Push item to vector to add",
                "Filter items where any tag matches"
              ],
              "testCases": [
                {
                  "input": {
                    "add": {
                      "tx_id": "abc",
                      "size": 1000
                    }
                  },
                  "expected": {
                    "count": 1
                  }
                },
                {
                  "input": {
                    "tag": [
                      "app",
                      "game"
                    ],
                    "find": [
                      "app",
                      "game"
                    ]
                  },
                  "expected": {
                    "found": 1
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "course-048",
      "slug": "solana-staking-economics",
      "title": "Staking and Validator Economics",
      "description": "Understand Solana staking and validator economics for real-world decision-making: delegation strategy, reward dynamics, commission effects, and operational sustainability.",
      "difficulty": "intermediate",
      "duration": "5 weeks",
      "totalXP": 1800,
      "tags": [
        "staking",
        "validator",
        "delegation",
        "rewards",
        "economics"
      ],
      "imageUrl": "/images/courses/solana-staking.svg",
      "modules": [
        {
          "id": "mod-48-1",
          "title": "Staking Fundamentals",
          "description": "Learn native staking mechanics with deterministic reward modeling, validator selection criteria, and delegation risk framing.",
          "lessons": [
            {
              "id": "lesson-48-1-1",
              "type": "content",
              "title": "Solana Staking Architecture",
              "content": "Solana staking economics is an incentives system connecting delegators, validators, and network security. Good delegation decisions require more than chasing headline APY.\n\nDelegators should evaluate:\n1) validator performance consistency,\n2) commission policy and changes over time,\n3) uptime and vote behavior,\n4) concentration risk across the validator set.\n\nReward modeling should be deterministic and transparent. Calculations must show gross rewards, commission effects, and net delegator outcome under explicit assumptions.\n\nDiversification matters. Concentrating stake purely on top performers can increase ecosystem centralization risk even if short-term yield appears higher.\n\nProduction staking tooling should expose scenario analysis (commission changes, performance drops, epoch variance) so delegators can make resilient choices rather than reactive moves.\n\nStaking quality is measured by sustainable net returns plus contribution to healthy validator distribution."
            },
            {
              "id": "lesson-48-1-2",
              "type": "challenge",
              "title": "Staking Rewards Calculator Challenge",
              "description": "Calculate staking rewards with commission and inflation.",
              "starterCode": "pub struct StakingConfig {\n    pub inflation_rate: f64,        // Annual inflation as decimal\n    pub validator_commission: f64,  // Commission as decimal (0-1)\n    pub epoch_duration_days: f64,\n}\n\npub struct StakeAccount {\n    pub amount: u64,\n    pub activated_stake: u64,\n    pub warmup_epochs: u8,\n}\n\npub struct RewardsCalculator;\n\nimpl RewardsCalculator {\n    pub fn calculate_annual_reward(stake: u64, config: &StakingConfig) -> u64 {\n        // TODO: Calculate annual reward after commission\n        // reward = stake * inflation * (1 - commission)\n        todo!(\"Implement calculate_annual_reward\")\n    }\n\n    pub fn calculate_epoch_reward(stake: u64, config: &StakingConfig) -> u64 {\n        // TODO: Calculate reward per epoch\n        todo!(\"Implement calculate_epoch_reward\")\n    }\n\n    pub fn calculate_apy(stake: u64, annual_reward: u64) -> f64 {\n        // TODO: Calculate APY from stake and annual reward\n        todo!(\"Implement calculate_apy\")\n    }\n\n    pub fn effective_stake(account: &StakeAccount) -> u64 {\n        // TODO: Calculate effective stake considering warmup\n        // During warmup, only portion is active\n        todo!(\"Implement effective_stake\")\n    }\n}",
              "solution": "impl RewardsCalculator {\n    pub fn calculate_annual_reward(stake: u64, config: &StakingConfig) -> u64 {\n        let gross_reward = stake as f64 * config.inflation_rate;\n        let net_reward = gross_reward * (1.0 - config.validator_commission);\n        net_reward as u64\n    }\n\n    pub fn calculate_epoch_reward(stake: u64, config: &StakingConfig) -> u64 {\n        let annual = Self::calculate_annual_reward(stake, config);\n        let epochs_per_year = 365.0 / config.epoch_duration_days;\n        (annual as f64 / epochs_per_year) as u64\n    }\n\n    pub fn calculate_apy(stake: u64, annual_reward: u64) -> f64 {\n        if stake == 0 {\n            return 0.0;\n        }\n        (annual_reward as f64 / stake as f64) * 100.0\n    }\n\n    pub fn effective_stake(account: &StakeAccount) -> u64 {\n        if account.warmup_epochs == 0 {\n            return account.activated_stake;\n        }\n        // Linear warmup: full stake / warmup_epochs\n        account.activated_stake / account.warmup_epochs as u64\n    }\n}",
              "hints": [
                "Apply commission as (1 - commission) multiplier",
                "Divide annual by epochs per year for epoch reward",
                "APY is (reward / stake) * 100"
              ],
              "testCases": [
                {
                  "input": {
                    "stake": 1000,
                    "inflation": 0.08,
                    "commission": 0.1
                  },
                  "expected": {
                    "reward": 72
                  }
                },
                {
                  "input": {
                    "stake": 1000,
                    "reward": 80
                  },
                  "expected": {
                    "apy": 8
                  }
                },
                {
                  "input": {
                    "activated": 1000,
                    "warmup": 4
                  },
                  "expected": {
                    "effective": 250
                  }
                }
              ]
            },
            {
              "id": "lesson-48-1-3",
              "type": "challenge",
              "title": "Validator Selector Challenge",
              "description": "Select validators based on performance and commission.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct Validator {\n    pub identity: String,\n    pub commission: f64,\n    pub uptime_percent: f64,\n    pub total_stake: u64,\n    pub skip_rate: f64,\n}\n\npub struct ValidatorSelector;\n\nimpl ValidatorSelector {\n    pub fn score_validator(validator: &Validator) -> f64 {\n        // TODO: Calculate validator score (higher is better)\n        // Consider: low commission, high uptime, reasonable stake\n        todo!(\"Implement score_validator\")\n    }\n\n    pub fn is_qualified(validator: &Validator, min_uptime: f64, max_commission: f64) -> bool {\n        // TODO: Check if validator meets minimum qualifications\n        todo!(\"Implement is_qualified\")\n    }\n\n    pub fn select_top_validators(validators: &[Validator], count: usize) -> Vec<&Validator> {\n        // TODO: Select top N validators by score\n        todo!(\"Implement select_top_validators\")\n    }\n\n    pub fn diversify_selection(selected: &[&Validator], max_per_validator: f64) -> bool {\n        // TODO: Check if selection is diversified (no validator exceeds max %)\n        todo!(\"Implement diversify_selection\")\n    }\n}",
              "solution": "impl ValidatorSelector {\n    pub fn score_validator(validator: &Validator) -> f64 {\n        // Score components (0-100 each)\n        let commission_score = (1.0 - validator.commission) * 100.0;\n        let uptime_score = validator.uptime_percent;\n        let skip_score = (1.0 - validator.skip_rate) * 100.0;\n\n        // Weighted average\n        (commission_score * 0.4 + uptime_score * 0.4 + skip_score * 0.2)\n    }\n\n    pub fn is_qualified(validator: &Validator, min_uptime: f64, max_commission: f64) -> bool {\n        validator.uptime_percent >= min_uptime && validator.commission <= max_commission\n    }\n\n    pub fn select_top_validators(validators: &[Validator], count: usize) -> Vec<&Validator> {\n        let mut scored: Vec<_> = validators.iter()\n            .map(|v| (v, Self::score_validator(v)))\n            .collect();\n        scored.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());\n        scored.into_iter().take(count).map(|(v, _)| v).collect()\n    }\n\n    pub fn diversify_selection(selected: &[&Validator], max_per_validator: f64) -> bool {\n        let total_stake: u64 = selected.iter().map(|v| v.total_stake).sum();\n        if total_stake == 0 {\n            return true;\n        }\n        selected.iter().all(|v| {\n            let percent = v.total_stake as f64 / total_stake as f64 * 100.0;\n            percent <= max_per_validator\n        })\n    }\n}",
              "hints": [
                "Weight factors: commission 40%, uptime 40%, skip rate 20%",
                "Sort by score descending and take top N",
                "Check each validator's percentage of total stake"
              ],
              "testCases": [
                {
                  "input": {
                    "commission": 0.1,
                    "uptime": 99,
                    "skip": 0.05
                  },
                  "expected": {
                    "score": 87
                  }
                },
                {
                  "input": {
                    "uptime": 95,
                    "min": 98
                  },
                  "expected": {
                    "qualified": false
                  }
                },
                {
                  "input": {
                    "validators": 10,
                    "select": 5
                  },
                  "expected": {
                    "selected": 5
                  }
                },
                {
                  "input": {
                    "stakes": [
                      100,
                      100,
                      100
                    ],
                    "max": 50
                  },
                  "expected": {
                    "diversified": false
                  }
                }
              ]
            },
            {
              "id": "lesson-48-1-4",
              "type": "challenge",
              "title": "Stake Rebalancing Challenge",
              "description": "Optimize stake distribution across validators.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct StakeAllocation {\n    pub validator: String,\n    pub amount: u64,\n}\n\npub struct RebalanceConfig {\n    pub target_count: usize,\n    pub min_per_validator: u64,\n    pub max_per_validator: u64,\n}\n\npub struct StakeRebalancer;\n\nimpl StakeRebalancer {\n    pub fn calculate_target_allocation(total_stake: u64, config: &RebalanceConfig) -> u64 {\n        // TODO: Calculate target stake per validator\n        todo!(\"Implement calculate_target_allocation\")\n    }\n\n    pub fn rebalance(allocations: &mut Vec<StakeAllocation>, config: &RebalanceConfig, total_stake: u64) {\n        // TODO: Rebalance stakes toward target allocation\n        todo!(\"Implement rebalance\")\n    }\n\n    pub fn calculate_rebalance_cost(allocations: &[StakeAllocation], new_allocations: &[StakeAllocation]) -> u64 {\n        // TODO: Calculate cost of rebalancing (withdrawal/deposit fees)\n        // Simplified: count of changes * base fee\n        todo!(\"Implement calculate_rebalance_cost\")\n    }\n\n    pub fn is_balanced(allocations: &[StakeAllocation], target: u64, tolerance: f64) -> bool {\n        // TODO: Check if allocations are within tolerance of target\n        todo!(\"Implement is_balanced\")\n    }\n}",
              "solution": "impl StakeRebalancer {\n    pub fn calculate_target_allocation(total_stake: u64, config: &RebalanceConfig) -> u64 {\n        let base = total_stake / config.target_count as u64;\n        base.clamp(config.min_per_validator, config.max_per_validator)\n    }\n\n    pub fn rebalance(allocations: &mut Vec<StakeAllocation>, config: &RebalanceConfig, total_stake: u64) {\n        let target = Self::calculate_target_allocation(total_stake, config);\n\n        // Simple rebalancing: move excess to deficit\n        for allocation in allocations.iter_mut() {\n            if allocation.amount > config.max_per_validator {\n                allocation.amount = config.max_per_validator;\n            }\n        }\n\n        // Ensure minimum\n        for allocation in allocations.iter_mut() {\n            if allocation.amount < config.min_per_validator && total_stake >= config.min_per_validator {\n                allocation.amount = config.min_per_validator;\n            }\n        }\n    }\n\n    pub fn calculate_rebalance_cost(allocations: &[StakeAllocation], new_allocations: &[StakeAllocation]) -> u64 {\n        let changes = allocations.iter().zip(new_allocations.iter())\n            .filter(|(a, b)| a.amount != b.amount)\n            .count();\n        changes as u64 * 5000  // 5000 lamports per change\n    }\n\n    pub fn is_balanced(allocations: &[StakeAllocation], target: u64, tolerance: f64) -> bool {\n        allocations.iter().all(|a| {\n            let diff = (a.amount as f64 - target as f64).abs();\n            diff / target as f64 <= tolerance\n        })\n    }\n}",
              "hints": [
                "Target is total divided by count, clamped to min/max",
                "Count allocations that differ between old and new",
                "Check all allocations within tolerance percentage"
              ],
              "testCases": [
                {
                  "input": {
                    "total": 10000,
                    "count": 5,
                    "min": 1000,
                    "max": 5000
                  },
                  "expected": {
                    "target": 2000
                  }
                },
                {
                  "input": {
                    "changes": 3
                  },
                  "expected": {
                    "cost": 15000
                  }
                },
                {
                  "input": {
                    "allocations": [
                      950,
                      1050
                    ],
                    "target": 1000,
                    "tolerance": 0.1
                  },
                  "expected": {
                    "balanced": true
                  }
                }
              ]
            }
          ]
        },
        {
          "id": "mod-48-2",
          "title": "Validator Operations",
          "description": "Analyze validator-side economics, operational cost pressure, and incentive alignment for long-term network health.",
          "lessons": [
            {
              "id": "lesson-48-2-1",
              "type": "content",
              "title": "Validator Economics",
              "content": "Validator economics balances revenue opportunities against operational costs and reliability obligations. Sustainable validators optimize for long-term trust, not short-term extraction.\n\nRevenue sources include inflation rewards and fee-related earnings; cost structure includes hardware, networking, maintenance, and operational staffing.\n\nKey operational metrics for validator viability:\n- effective uptime and vote success,\n- commission competitiveness,\n- stake retention trend,\n- incident frequency and recovery quality.\n\nCommission strategy should be explicit and predictable. Sudden commission spikes can damage delegator trust and long-term stake stability.\n\nEconomic analysis should include downside modeling: reduced stake, higher incident costs, or prolonged performance degradation.\n\nHealthy validator economics supports network resilience. Tooling should help operators and delegators reason about sustainability, not just peak-period earnings."
            },
            {
              "id": "lesson-48-2-2",
              "type": "challenge",
              "title": "Validator Profit Calculator Challenge",
              "description": "Calculate validator profitability.",
              "starterCode": "pub struct ValidatorCosts {\n    pub infrastructure_usd: f64,    // Monthly\n    pub bandwidth_usd: f64,\n    pub staff_usd: f64,\n}\n\npub struct ValidatorRevenue {\n    pub commission_rate: f64,\n    pub total_delegated: u64,\n    pub self_stake: u64,\n    pub inflation_rate: f64,\n}\n\npub struct ProfitCalculator;\n\nimpl ProfitCalculator {\n    pub fn monthly_cost(costs: &ValidatorCosts) -> f64 {\n        // TODO: Calculate total monthly cost\n        todo!(\"Implement monthly_cost\")\n    }\n\n    pub fn monthly_revenue_usd(revenue: &ValidatorRevenue, sol_price: f64) -> f64 {\n        // TODO: Calculate monthly revenue in USD\n        // Revenue from commission on delegated + full rewards on self-stake\n        todo!(\"Implement monthly_revenue_usd\")\n    }\n\n    pub fn is_profitable(costs: &ValidatorCosts, revenue: &ValidatorRevenue, sol_price: f64) -> bool {\n        // TODO: Check if validator operation is profitable\n        todo!(\"Implement is_profitable\")\n    }\n\n    pub fn break_even_commission(costs: &ValidatorCosts, delegated: u64, inflation: f64, sol_price: f64) -> f64 {\n        // TODO: Calculate minimum commission for break-even\n        todo!(\"Implement break_even_commission\")\n    }\n}",
              "solution": "impl ProfitCalculator {\n    pub fn monthly_cost(costs: &ValidatorCosts) -> f64 {\n        costs.infrastructure_usd + costs.bandwidth_usd + costs.staff_usd\n    }\n\n    pub fn monthly_revenue_usd(revenue: &ValidatorRevenue, sol_price: f64) -> f64 {\n        // Annual rewards\n        let delegated_annual = revenue.total_delegated as f64 * revenue.inflation_rate;\n        let self_annual = revenue.self_stake as f64 * revenue.inflation_rate;\n\n        // Commission on delegated + full self rewards\n        let annual_revenue = delegated_annual * revenue.commission_rate + self_annual;\n\n        // Monthly in USD\n        (annual_revenue / 12.0) * sol_price\n    }\n\n    pub fn is_profitable(costs: &ValidatorCosts, revenue: &ValidatorRevenue, sol_price: f64) -> bool {\n        let cost = Self::monthly_cost(costs);\n        let rev = Self::monthly_revenue_usd(revenue, sol_price);\n        rev > cost\n    }\n\n    pub fn break_even_commission(costs: &ValidatorCosts, delegated: u64, inflation: f64, sol_price: f64) -> f64 {\n        if delegated == 0 {\n            return 0.0;\n        }\n        let monthly_cost = Self::monthly_cost(costs);\n        let annual_cost = monthly_cost * 12.0;\n        let annual_rewards_needed = annual_cost / sol_price;\n        let annual_delegated_rewards = delegated as f64 * inflation;\n\n        (annual_rewards_needed / annual_delegated_rewards).min(1.0)\n    }\n}",
              "hints": [
                "Sum all cost components",
                "Revenue = commission * delegated_rewards + self_rewards",
                "Break-even: commission = needed_rewards / delegated_rewards"
              ],
              "testCases": [
                {
                  "input": {
                    "infra": 500,
                    "bw": 100,
                    "staff": 0
                  },
                  "expected": {
                    "cost": 600
                  }
                },
                {
                  "input": {
                    "delegated": 100000,
                    "commission": 0.1,
                    "inflation": 0.08,
                    "price": 20
                  },
                  "expected": {
                    "revenue": 13333.33
                  }
                },
                {
                  "input": {
                    "cost": 600,
                    "revenue": 13333.33
                  },
                  "expected": {
                    "profitable": true
                  }
                }
              ]
            },
            {
              "id": "lesson-48-2-3",
              "type": "challenge",
              "title": "Epoch Schedule Calculator Challenge",
              "description": "Calculate epoch timing and reward distribution schedules.",
              "starterCode": "pub struct EpochSchedule {\n    pub slots_per_epoch: u64,\n    pub slot_time_ms: u64,\n    pub current_epoch: u64,\n    pub current_slot: u64,\n}\n\npub struct EpochCalculator;\n\nimpl EpochCalculator {\n    pub fn epoch_duration_hours(schedule: &EpochSchedule) -> f64 {\n        // TODO: Calculate epoch duration in hours\n        todo!(\"Implement epoch_duration_hours\")\n    }\n\n    pub fn slots_remaining_in_epoch(schedule: &EpochSchedule) -> u64 {\n        // TODO: Calculate slots until next epoch\n        todo!(\"Implement slots_remaining_in_epoch\")\n    }\n\n    pub fn time_until_next_epoch(schedule: &EpochSchedule) -> u64 {\n        // TODO: Calculate milliseconds until next epoch\n        todo!(\"Implement time_until_next_epoch\")\n    }\n\n    pub fn epoch_for_slot(schedule: &EpochSchedule, slot: u64) -> u64 {\n        // TODO: Calculate which epoch a slot belongs to\n        todo!(\"Implement epoch_for_slot\")\n    }\n}",
              "solution": "impl EpochCalculator {\n    pub fn epoch_duration_hours(schedule: &EpochSchedule) -> f64 {\n        let duration_ms = schedule.slots_per_epoch * schedule.slot_time_ms;\n        duration_ms as f64 / (1000.0 * 60.0 * 60.0)\n    }\n\n    pub fn slots_remaining_in_epoch(schedule: &EpochSchedule) -> u64 {\n        let epoch_start_slot = schedule.current_epoch * schedule.slots_per_epoch;\n        let next_epoch_start = epoch_start_slot + schedule.slots_per_epoch;\n        next_epoch_start.saturating_sub(schedule.current_slot)\n    }\n\n    pub fn time_until_next_epoch(schedule: &EpochSchedule) -> u64 {\n        Self::slots_remaining_in_epoch(schedule) * schedule.slot_time_ms\n    }\n\n    pub fn epoch_for_slot(schedule: &EpochSchedule, slot: u64) -> u64 {\n        slot / schedule.slots_per_epoch\n    }\n}",
              "hints": [
                "Convert ms to hours: / (1000 * 60 * 60)",
                "Next epoch starts at (current_epoch + 1) * slots_per_epoch",
                "Epoch for slot is integer division"
              ],
              "testCases": [
                {
                  "input": {
                    "slots": 432000,
                    "slot_time": 400
                  },
                  "expected": {
                    "hours": 48
                  }
                },
                {
                  "input": {
                    "current_epoch": 100,
                    "current_slot": 432050,
                    "slots_per_epoch": 432000
                  },
                  "expected": {
                    "remaining": 431950
                  }
                },
                {
                  "input": {
                    "slot": 864000,
                    "slots_per_epoch": 432000
                  },
                  "expected": {
                    "epoch": 2
                  }
                }
              ]
            },
            {
              "id": "lesson-48-2-4",
              "type": "challenge",
              "title": "Stake Account Manager Challenge",
              "description": "Manage stake account lifecycle including activation and deactivation.",
              "starterCode": "#[derive(Debug, Clone, PartialEq)]\npub enum StakeState {\n    Inactive,\n    Activating,\n    Active,\n    Deactivating,\n}\n\n#[derive(Debug, Clone)]\npub struct StakeAccount {\n    pub state: StakeState,\n    pub amount: u64,\n    pub delegated_to: Option<String>,\n    pub activation_epoch: Option<u64>,\n}\n\npub struct StakeManager;\n\nimpl StakeManager {\n    pub fn activate(stake: &mut StakeAccount, validator: String, current_epoch: u64) -> Result<(), String> {\n        // TODO: Activate stake for delegation\n        todo!(\"Implement activate\")\n    }\n\n    pub fn deactivate(stake: &mut StakeAccount, current_epoch: u64) -> Result<(), String> {\n        // TODO: Begin stake deactivation\n        todo!(\"Implement deactivate\")\n    }\n\n    pub fn withdraw(stake: &StakeAccount) -> Result<u64, String> {\n        // TODO: Withdraw stake if inactive\n        todo!(\"Implement withdraw\")\n    }\n\n    pub fn is_fully_active(stake: &StakeAccount, current_epoch: u64, warmup_epochs: u8) -> bool {\n        // TODO: Check if stake is fully activated\n        todo!(\"Implement is_fully_active\")\n    }\n}",
              "solution": "impl StakeManager {\n    pub fn activate(stake: &mut StakeAccount, validator: String, current_epoch: u64) -> Result<(), String> {\n        if stake.state != StakeState::Inactive {\n            return Err(\"Stake not inactive\".to_string());\n        }\n        stake.state = StakeState::Activating;\n        stake.delegated_to = Some(validator);\n        stake.activation_epoch = Some(current_epoch);\n        Ok(())\n    }\n\n    pub fn deactivate(stake: &mut StakeAccount, current_epoch: u64) -> Result<(), String> {\n        if stake.state != StakeState::Active {\n            return Err(\"Stake not active\".to_string());\n        }\n        stake.state = StakeState::Deactivating;\n        Ok(())\n    }\n\n    pub fn withdraw(stake: &StakeAccount) -> Result<u64, String> {\n        if stake.state != StakeState::Inactive {\n            return Err(\"Stake not withdrawable\".to_string());\n        }\n        Ok(stake.amount)\n    }\n\n    pub fn is_fully_active(stake: &StakeAccount, current_epoch: u64, warmup_epochs: u8) -> bool {\n        if let Some(activation_epoch) = stake.activation_epoch {\n            stake.state == StakeState::Active && \n            current_epoch >= activation_epoch + warmup_epochs as u64\n        } else {\n            false\n        }\n    }\n}",
              "hints": [
                "Only inactive stakes can be activated",
                "Only active stakes can be deactivated",
                "Fully active after warmup_epochs from activation"
              ],
              "testCases": [
                {
                  "input": {
                    "activate": "validator1",
                    "epoch": 100
                  },
                  "expected": {
                    "state": "Activating"
                  }
                },
                {
                  "input": {
                    "state": "Active",
                    "deactivate": 105
                  },
                  "expected": {
                    "state": "Deactivating"
                  }
                },
                {
                  "input": {
                    "state": "Inactive",
                    "withdraw": true
                  },
                  "expected": {
                    "amount": 1000
                  }
                },
                {
                  "input": {
                    "activation": 100,
                    "current": 105,
                    "warmup": 4
                  },
                  "expected": {
                    "fully_active": true
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "course-049",
      "slug": "solana-account-abstraction",
      "title": "Account Abstraction and Smart Wallets",
      "description": "Implement smart-wallet/account-abstraction patterns on Solana with programmable authorization, recovery controls, and policy-driven transaction validation.",
      "difficulty": "advanced",
      "duration": "6 weeks",
      "totalXP": 2100,
      "tags": [
        "account-abstraction",
        "smart-wallet",
        "multisig",
        "recovery",
        "session-keys"
      ],
      "imageUrl": "/images/courses/solana-account-abstraction.svg",
      "modules": [
        {
          "id": "mod-49-1",
          "title": "Smart Wallet Fundamentals",
          "description": "Build smart-wallet fundamentals including multisig and social-recovery designs with clear trust and failure boundaries.",
          "lessons": [
            {
              "id": "lesson-49-1-1",
              "type": "content",
              "title": "Account Abstraction on Solana",
              "content": "Account abstraction on Solana shifts control from a single key to programmable policy. Smart wallets can enforce richer authorization logic, but policy complexity must be managed carefully.\n\nA robust smart-wallet design defines:\n1) authority model (owners/guardians/delegates),\n2) policy scope (what can be approved automatically vs manually),\n3) recovery path (how access is restored safely).\n\nMultisig and social recovery are powerful, but both need deterministic state transitions and explicit quorum rules. Ambiguous transitions create lockout or unauthorized-access risk.\n\nSmart-wallet systems should emit structured authorization evidence for each action: which policy matched, which signers approved, and which constraints passed.\n\nProduction reliability depends on clear emergency controls: pause paths, guardian rotation, and recovery cooldowns.\n\nAccount abstraction is successful when flexibility increases safety and usability together, not when policy logic becomes opaque."
            },
            {
              "id": "lesson-49-1-2",
              "type": "challenge",
              "title": "Multi-Signature Wallet Challenge",
              "description": "Implement M-of-N multi-signature wallet.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct MultisigWallet {\n    pub owners: Vec<String>,\n    pub threshold: usize,\n    pub nonce: u64,\n}\n\n#[derive(Debug, Clone)]\npub struct Transaction {\n    pub id: u64,\n    pub proposer: String,\n    pub signatures: Vec<String>,\n    pub executed: bool,\n}\n\npub struct MultisigManager;\n\nimpl MultisigManager {\n    pub fn is_owner(wallet: &MultisigWallet, address: &str) -> bool {\n        // TODO: Check if address is an owner\n        todo!(\"Implement is_owner\")\n    }\n\n    pub fn can_sign(wallet: &MultisigWallet, tx: &Transaction, signer: &str) -> bool {\n        // TODO: Check if signer can sign (is owner, hasn't signed, not executed)\n        todo!(\"Implement can_sign\")\n    }\n\n    pub fn add_signature(wallet: &MultisigWallet, tx: &mut Transaction, signer: String) -> Result<(), String> {\n        // TODO: Add signature to transaction\n        todo!(\"Implement add_signature\")\n    }\n\n    pub fn can_execute(wallet: &MultisigWallet, tx: &Transaction) -> bool {\n        // TODO: Check if transaction has enough signatures\n        todo!(\"Implement can_execute\")\n    }\n\n    pub fn required_signatures(wallet: &MultisigWallet) -> usize {\n        // TODO: Return number of signatures required\n        todo!(\"Implement required_signatures\")\n    }\n}",
              "solution": "impl MultisigManager {\n    pub fn is_owner(wallet: &MultisigWallet, address: &str) -> bool {\n        wallet.owners.contains(&address.to_string())\n    }\n\n    pub fn can_sign(wallet: &MultisigWallet, tx: &Transaction, signer: &str) -> bool {\n        Self::is_owner(wallet, signer) && \n        !tx.signatures.contains(&signer.to_string()) &&\n        !tx.executed\n    }\n\n    pub fn add_signature(wallet: &MultisigWallet, tx: &mut Transaction, signer: String) -> Result<(), String> {\n        if !Self::can_sign(wallet, tx, &signer) {\n            return Err(\"Cannot sign\".to_string());\n        }\n        tx.signatures.push(signer);\n        Ok(())\n    }\n\n    pub fn can_execute(wallet: &MultisigWallet, tx: &Transaction) -> bool {\n        !tx.executed && tx.signatures.len() >= wallet.threshold\n    }\n\n    pub fn required_signatures(wallet: &MultisigWallet) -> usize {\n        wallet.threshold\n    }\n}",
              "hints": [
                "Use contains() to check ownership",
                "Can sign if owner AND not already signed AND not executed",
                "Can execute if threshold reached and not executed"
              ],
              "testCases": [
                {
                  "input": {
                    "owners": [
                      "alice",
                      "bob"
                    ],
                    "check": "alice"
                  },
                  "expected": {
                    "owner": true
                  }
                },
                {
                  "input": {
                    "threshold": 2,
                    "signatures": 1
                  },
                  "expected": {
                    "can_execute": false
                  }
                },
                {
                  "input": {
                    "threshold": 2,
                    "signatures": 2
                  },
                  "expected": {
                    "can_execute": true
                  }
                },
                {
                  "input": {
                    "required": true
                  },
                  "expected": {
                    "threshold": 2
                  }
                }
              ]
            },
            {
              "id": "lesson-49-1-3",
              "type": "challenge",
              "title": "Social Recovery Challenge",
              "description": "Implement social recovery with guardians.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct RecoveryConfig {\n    pub guardians: Vec<String>,\n    pub threshold: usize,\n    pub recovery_delay: u64,\n}\n\n#[derive(Debug, Clone)]\npub struct RecoveryRequest {\n    pub requester: String,\n    pub new_owner: String,\n    pub guardians_approved: Vec<String>,\n    pub request_time: u64,\n    pub executed: bool,\n}\n\npub struct RecoveryManager;\n\nimpl RecoveryManager {\n    pub fn request_recovery(config: &RecoveryConfig, requester: String, new_owner: String, current_time: u64) -> RecoveryRequest {\n        // TODO: Create new recovery request\n        todo!(\"Implement request_recovery\")\n    }\n\n    pub fn approve_recovery(config: &RecoveryConfig, request: &mut RecoveryRequest, guardian: String) -> Result<(), String> {\n        // TODO: Guardian approves recovery request\n        todo!(\"Implement approve_recovery\")\n    }\n\n    pub fn can_execute_recovery(config: &RecoveryConfig, request: &RecoveryRequest, current_time: u64) -> bool {\n        // TODO: Check if recovery can be executed (threshold met, delay passed)\n        todo!(\"Implement can_execute_recovery\")\n    }\n\n    pub fn is_guardian(config: &RecoveryConfig, address: &str) -> bool {\n        // TODO: Check if address is a guardian\n        todo!(\"Implement is_guardian\")\n    }\n}",
              "solution": "impl RecoveryManager {\n    pub fn request_recovery(config: &RecoveryConfig, requester: String, new_owner: String, current_time: u64) -> RecoveryRequest {\n        RecoveryRequest {\n            requester,\n            new_owner,\n            guardians_approved: vec![],\n            request_time: current_time,\n            executed: false,\n        }\n    }\n\n    pub fn approve_recovery(config: &RecoveryConfig, request: &mut RecoveryRequest, guardian: String) -> Result<(), String> {\n        if !config.guardians.contains(&guardian) {\n            return Err(\"Not a guardian\".to_string());\n        }\n        if request.guardians_approved.contains(&guardian) {\n            return Err(\"Already approved\".to_string());\n        }\n        request.guardians_approved.push(guardian);\n        Ok(())\n    }\n\n    pub fn can_execute_recovery(config: &RecoveryConfig, request: &RecoveryRequest, current_time: u64) -> bool {\n        !request.executed &&\n        request.guardians_approved.len() >= config.threshold &&\n        current_time >= request.request_time + config.recovery_delay\n    }\n\n    pub fn is_guardian(config: &RecoveryConfig, address: &str) -> bool {\n        config.guardians.contains(&address.to_string())\n    }\n}",
              "hints": [
                "Track approvals in guardians_approved vector",
                "Check guardian status before approving",
                "Require threshold AND delay for execution"
              ],
              "testCases": [
                {
                  "input": {
                    "guardians": [
                      "g1",
                      "g2",
                      "g3"
                    ],
                    "check": "g1"
                  },
                  "expected": {
                    "guardian": true
                  }
                },
                {
                  "input": {
                    "threshold": 2,
                    "approvals": 1
                  },
                  "expected": {
                    "can_execute": false
                  }
                },
                {
                  "input": {
                    "threshold": 2,
                    "approvals": 2,
                    "delay": 100,
                    "elapsed": 150
                  },
                  "expected": {
                    "can_execute": true
                  }
                }
              ]
            },
            {
              "id": "lesson-49-1-4",
              "type": "challenge",
              "title": "Session Key Manager Challenge",
              "description": "Manage temporary session keys with limited permissions.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct SessionKey {\n    pub key: String,\n    pub expires_at: u64,\n    pub max_amount: u64,\n    pub used_amount: u64,\n    pub allowed_operations: Vec<String>,\n}\n\npub struct SessionManager;\n\nimpl SessionManager {\n    pub fn is_valid(session: &SessionKey, current_time: u64) -> bool {\n        // TODO: Check if session key is still valid\n        todo!(\"Implement is_valid\")\n    }\n\n    pub fn can_execute(session: &SessionKey, operation: &str, amount: u64, current_time: u64) -> bool {\n        // TODO: Check if session can execute operation\n        todo!(\"Implement can_execute\")\n    }\n\n    pub fn record_usage(session: &mut SessionKey, amount: u64) -> Result<(), String> {\n        // TODO: Record usage against session limit\n        todo!(\"Implement record_usage\")\n    }\n\n    pub fn remaining_allowance(session: &SessionKey) -> u64 {\n        // TODO: Get remaining amount session can spend\n        todo!(\"Implement remaining_allowance\")\n    }\n}",
              "solution": "impl SessionManager {\n    pub fn is_valid(session: &SessionKey, current_time: u64) -> bool {\n        current_time < session.expires_at\n    }\n\n    pub fn can_execute(session: &SessionKey, operation: &str, amount: u64, current_time: u64) -> bool {\n        Self::is_valid(session, current_time) &&\n        session.allowed_operations.contains(&operation.to_string()) &&\n        session.used_amount + amount <= session.max_amount\n    }\n\n    pub fn record_usage(session: &mut SessionKey, amount: u64) -> Result<(), String> {\n        if session.used_amount + amount > session.max_amount {\n            return Err(\"Exceeds session limit\".to_string());\n        }\n        session.used_amount += amount;\n        Ok(())\n    }\n\n    pub fn remaining_allowance(session: &SessionKey) -> u64 {\n        session.max_amount - session.used_amount\n    }\n}",
              "hints": [
                "Valid if current time before expiration",
                "Can execute if valid, allowed operation, and within limit",
                "Remaining is max minus used"
              ],
              "testCases": [
                {
                  "input": {
                    "expires": 1000,
                    "current": 500
                  },
                  "expected": {
                    "valid": true
                  }
                },
                {
                  "input": {
                    "expires": 1000,
                    "current": 1500
                  },
                  "expected": {
                    "valid": false
                  }
                },
                {
                  "input": {
                    "used": 300,
                    "max": 1000,
                    "amount": 500
                  },
                  "expected": {
                    "can": true
                  }
                },
                {
                  "input": {
                    "used": 800,
                    "max": 1000
                  },
                  "expected": {
                    "remaining": 200
                  }
                }
              ]
            }
          ]
        },
        {
          "id": "mod-49-2",
          "title": "Programmable Validation",
          "description": "Implement programmable validation policies (limits, allowlists, time/risk rules) with deterministic enforcement and auditability.",
          "lessons": [
            {
              "id": "lesson-49-2-1",
              "type": "content",
              "title": "Custom Validation Rules",
              "content": "Programmable validation is where smart wallets deliver real value, but it is also where subtle policy bugs appear.\n\nTypical controls include spending limits, destination allowlists, time windows, and risk-score gates. These controls should be deterministic and composable, with explicit precedence rules.\n\nDesign principles:\n- fail closed on ambiguous policy matches,\n- keep policy evaluation order stable,\n- attach machine-readable reason codes to approve/reject outcomes.\n\nValidation systems should also support policy explainability. Users and auditors need to understand why a transaction was blocked or approved.\n\nFor production deployments, policy changes should be versioned and test-fixtured. A new rule must be validated against prior known-good scenarios to avoid accidental lockouts or bypasses.\n\nProgrammable wallets are strongest when validation logic is transparent, testable, and operationally reversible."
            },
            {
              "id": "lesson-49-2-2",
              "type": "challenge",
              "title": "Spending Limit Enforcer Challenge",
              "description": "Enforce daily and per-transaction spending limits.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct SpendingLimits {\n    pub per_transaction: u64,\n    pub per_day: u64,\n    pub per_week: u64,\n}\n\n#[derive(Debug, Clone)]\npub struct SpendingTracker {\n    pub limits: SpendingLimits,\n    pub spent_today: u64,\n    pub spent_this_week: u64,\n    pub last_reset_day: u64,\n    pub last_reset_week: u64,\n}\n\npub struct LimitEnforcer;\n\nimpl LimitEnforcer {\n    pub fn can_spend(tracker: &mut SpendingTracker, amount: u64, current_day: u64) -> bool {\n        // TODO: Check if spend is within limits, resetting if needed\n        todo!(\"Implement can_spend\")\n    }\n\n    pub fn record_spend(tracker: &mut SpendingTracker, amount: u64, current_day: u64) {\n        // TODO: Record spend and update tracking\n        todo!(\"Implement record_spend\")\n    }\n\n    pub fn reset_if_needed(tracker: &mut SpendingTracker, current_day: u64) {\n        // TODO: Reset daily/weekly counters if period passed\n        todo!(\"Implement reset_if_needed\")\n    }\n\n    pub fn get_daily_remaining(tracker: &SpendingTracker) -> u64 {\n        // TODO: Get remaining daily allowance\n        todo!(\"Implement get_daily_remaining\")\n    }\n}",
              "solution": "impl LimitEnforcer {\n    pub fn can_spend(tracker: &mut SpendingTracker, amount: u64, current_day: u64) -> bool {\n        Self::reset_if_needed(tracker, current_day);\n\n        amount <= tracker.limits.per_transaction &&\n        tracker.spent_today + amount <= tracker.limits.per_day &&\n        tracker.spent_this_week + amount <= tracker.limits.per_week\n    }\n\n    pub fn record_spend(tracker: &mut SpendingTracker, amount: u64, current_day: u64) {\n        Self::reset_if_needed(tracker, current_day);\n        tracker.spent_today += amount;\n        tracker.spent_this_week += amount;\n    }\n\n    pub fn reset_if_needed(tracker: &mut SpendingTracker, current_day: u64) {\n        // Reset daily\n        if current_day > tracker.last_reset_day {\n            tracker.spent_today = 0;\n            tracker.last_reset_day = current_day;\n        }\n        // Reset weekly (every 7 days)\n        if current_day >= tracker.last_reset_week + 7 {\n            tracker.spent_this_week = 0;\n            tracker.last_reset_week = current_day;\n        }\n    }\n\n    pub fn get_daily_remaining(tracker: &SpendingTracker) -> u64 {\n        tracker.limits.per_day - tracker.spent_today\n    }\n}",
              "hints": [
                "Reset counters before checking",
                "Check all three limits: per-tx, daily, weekly",
                "Reset daily if new day, weekly if 7+ days passed"
              ],
              "testCases": [
                {
                  "input": {
                    "per_tx": 100,
                    "daily": 500,
                    "spend": 50
                  },
                  "expected": {
                    "can": true
                  }
                },
                {
                  "input": {
                    "spent": 450,
                    "daily": 500,
                    "spend": 100
                  },
                  "expected": {
                    "can": false
                  }
                },
                {
                  "input": {
                    "spent": 300,
                    "daily": 500
                  },
                  "expected": {
                    "remaining": 200
                  }
                },
                {
                  "input": {
                    "last": 5,
                    "current": 6
                  },
                  "expected": {
                    "reset": true
                  }
                }
              ]
            },
            {
              "id": "lesson-49-2-3",
              "type": "challenge",
              "title": "Whitelist Enforcer Challenge",
              "description": "Enforce destination whitelists for transactions.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct WhitelistConfig {\n    pub allowed_destinations: Vec<String>,\n    pub allow_all: bool,\n}\n\npub struct WhitelistEnforcer;\n\nimpl WhitelistEnforcer {\n    pub fn is_allowed(config: &WhitelistConfig, destination: &str) -> bool {\n        // TODO: Check if destination is whitelisted\n        todo!(\"Implement is_allowed\")\n    }\n\n    pub fn add_destination(config: &mut WhitelistConfig, destination: String) -> Result<(), String> {\n        // TODO: Add destination to whitelist\n        todo!(\"Implement add_destination\")\n    }\n\n    pub fn remove_destination(config: &mut WhitelistConfig, destination: &str) -> Result<(), String> {\n        // TODO: Remove destination from whitelist\n        todo!(\"Implement remove_destination\")\n    }\n\n    pub fn validate_transaction(config: &WhitelistConfig, destinations: &[String]) -> Result<(), String> {\n        // TODO: Validate all transaction destinations are whitelisted\n        todo!(\"Implement validate_transaction\")\n    }\n}",
              "solution": "impl WhitelistEnforcer {\n    pub fn is_allowed(config: &WhitelistConfig, destination: &str) -> bool {\n        config.allow_all || config.allowed_destinations.contains(&destination.to_string())\n    }\n\n    pub fn add_destination(config: &mut WhitelistConfig, destination: String) -> Result<(), String> {\n        if config.allowed_destinations.contains(&destination) {\n            return Err(\"Already whitelisted\".to_string());\n        }\n        config.allowed_destinations.push(destination);\n        Ok(())\n    }\n\n    pub fn remove_destination(config: &mut WhitelistConfig, destination: &str) -> Result<(), String> {\n        if let Some(pos) = config.allowed_destinations.iter().position(|d| d == destination) {\n            config.allowed_destinations.remove(pos);\n            Ok(())\n        } else {\n            Err(\"Destination not found\".to_string())\n        }\n    }\n\n    pub fn validate_transaction(config: &WhitelistConfig, destinations: &[String]) -> Result<(), String> {\n        for dest in destinations {\n            if !Self::is_allowed(config, dest) {\n                return Err(format!(\"Destination not allowed: {}\", dest));\n            }\n        }\n        Ok(())\n    }\n}",
              "hints": [
                "allow_all bypasses whitelist check",
                "Check contains() before adding",
                "Validate all destinations in transaction"
              ],
              "testCases": [
                {
                  "input": {
                    "allowed": [
                      "alice",
                      "bob"
                    ],
                    "check": "alice"
                  },
                  "expected": {
                    "allowed": true
                  }
                },
                {
                  "input": {
                    "allowed": [
                      "alice"
                    ],
                    "check": "charlie"
                  },
                  "expected": {
                    "allowed": false
                  }
                },
                {
                  "input": {
                    "allow_all": true,
                    "check": "anyone"
                  },
                  "expected": {
                    "allowed": true
                  }
                },
                {
                  "input": {
                    "destinations": [
                      "alice",
                      "bob"
                    ]
                  },
                  "expected": {
                    "valid": true
                  }
                }
              ]
            },
            {
              "id": "lesson-49-2-4",
              "type": "challenge",
              "title": "Time Lock Enforcer Challenge",
              "description": "Enforce time-based restrictions on transactions.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct TimeRestrictions {\n    pub allowed_hours_start: u8,  // 0-23\n    pub allowed_hours_end: u8,\n    pub min_delay: u64,           // Minimum delay from proposal to execution\n    pub max_delay: u64,           // Maximum time to execute after proposal\n}\n\npub struct TimeLockEnforcer;\n\nimpl TimeLockEnforcer {\n    pub fn is_within_allowed_hours(restrictions: &TimeRestrictions, current_hour: u8) -> bool {\n        // TODO: Check if current hour is within allowed window\n        todo!(\"Implement is_within_allowed_hours\")\n    }\n\n    pub fn can_execute(restrictions: &TimeRestrictions, proposed_at: u64, current_time: u64) -> bool {\n        // TODO: Check if enough time passed since proposal (min_delay)\n        // AND not too much time passed (max_delay)\n        todo!(\"Implement can_execute\")\n    }\n\n    pub fn time_remaining(restrictions: &TimeRestrictions, proposed_at: u64, current_time: u64) -> u64 {\n        // TODO: Calculate time remaining before max_delay expires\n        todo!(\"Implement time_remaining\")\n    }\n\n    pub fn validate_schedule(restrictions: &TimeRestrictions) -> Result<(), String> {\n        // TODO: Validate time restrictions are configured correctly\n        todo!(\"Implement validate_schedule\")\n    }\n}",
              "solution": "impl TimeLockEnforcer {\n    pub fn is_within_allowed_hours(restrictions: &TimeRestrictions, current_hour: u8) -> bool {\n        if restrictions.allowed_hours_start <= restrictions.allowed_hours_end {\n            current_hour >= restrictions.allowed_hours_start && current_hour <= restrictions.allowed_hours_end\n        } else {\n            // Wraps around midnight\n            current_hour >= restrictions.allowed_hours_start || current_hour <= restrictions.allowed_hours_end\n        }\n    }\n\n    pub fn can_execute(restrictions: &TimeRestrictions, proposed_at: u64, current_time: u64) -> bool {\n        let elapsed = current_time - proposed_at;\n        elapsed >= restrictions.min_delay && elapsed <= restrictions.max_delay\n    }\n\n    pub fn time_remaining(restrictions: &TimeRestrictions, proposed_at: u64, current_time: u64) -> u64 {\n        let deadline = proposed_at + restrictions.max_delay;\n        deadline.saturating_sub(current_time)\n    }\n\n    pub fn validate_schedule(restrictions: &TimeRestrictions) -> Result<(), String> {\n        if restrictions.allowed_hours_start > 23 || restrictions.allowed_hours_end > 23 {\n            return Err(\"Invalid hour range\".to_string());\n        }\n        if restrictions.min_delay > restrictions.max_delay {\n            return Err(\"min_delay cannot exceed max_delay\".to_string());\n        }\n        Ok(())\n    }\n}",
              "hints": [
                "Handle wrap-around for hours crossing midnight",
                "Check elapsed is between min and max delay",
                "Validate hours are 0-23 and min <= max"
              ],
              "testCases": [
                {
                  "input": {
                    "start": 9,
                    "end": 17,
                    "current": 12
                  },
                  "expected": {
                    "within": true
                  }
                },
                {
                  "input": {
                    "start": 9,
                    "end": 17,
                    "current": 20
                  },
                  "expected": {
                    "within": false
                  }
                },
                {
                  "input": {
                    "proposed": 0,
                    "min": 100,
                    "max": 1000,
                    "current": 500
                  },
                  "expected": {
                    "can": true
                  }
                },
                {
                  "input": {
                    "proposed": 0,
                    "max": 1000,
                    "current": 500
                  },
                  "expected": {
                    "remaining": 500
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "course-050",
      "slug": "solana-pda-mastery",
      "title": "Program Derived Address Mastery",
      "description": "Master advanced PDA engineering on Solana: seed schema design, bump handling discipline, and secure cross-program PDA usage at production scale.",
      "difficulty": "advanced",
      "duration": "6 weeks",
      "totalXP": 2100,
      "tags": [
        "pda",
        "program-derived-address",
        "seeds",
        "bump",
        "deterministic"
      ],
      "imageUrl": "/images/courses/solana-pda.svg",
      "modules": [
        {
          "id": "mod-50-1",
          "title": "PDA Fundamentals",
          "description": "Build strong PDA foundations with deterministic derivation, canonical seed composition, and collision-resistant namespace strategy.",
          "lessons": [
            {
              "id": "lesson-50-1-1",
              "type": "content",
              "title": "Program Derived Addresses",
              "content": "Program Derived Addresses (PDAs) are deterministic authority and state anchors on Solana. Their power comes from predictable derivation; their risk comes from inconsistent seed discipline.\n\nA strong PDA design standard defines:\n1) canonical seed order,\n2) explicit namespace/domain tags,\n3) bump handling rules,\n4) versioning strategy for future evolution.\n\nSeed ambiguity is a common source of bugs. If different handlers derive the same concept with different seed ordering, identity checks become inconsistent and security assumptions break.\n\nPDA validation should always re-derive expected addresses on the trusted side and compare exact keys before mutating state.\n\nProduction teams should document seed recipes as API contracts. Changing recipes without migration planning can orphan state and break clients.\n\nPDA mastery is mostly discipline: deterministic derivation everywhere, no implicit conventions, no trust in client-provided derivation claims."
            },
            {
              "id": "lesson-50-1-2",
              "type": "challenge",
              "title": "PDA Generator Challenge",
              "description": "Implement PDA generation with seed validation.",
              "starterCode": "pub struct PdaGenerator;\n\nimpl PdaGenerator {\n    pub fn find_pda(seeds: &[&[u8]], program_id: &str) -> (String, u8) {\n        // TODO: Find valid PDA by trying bumps 255 down to 0\n        // Return (address, bump) where address is off-curve\n        todo!(\"Implement find_pda\")\n    }\n\n    pub fn create_seed_bytes(seeds: &[&str]) -> Vec<Vec<u8>> {\n        // TODO: Convert string seeds to byte vectors\n        todo!(\"Implement create_seed_bytes\")\n    }\n\n    pub fn is_valid_pda(address: &str, seeds: &[&[u8]], program_id: &str, bump: u8) -> bool {\n        // TODO: Verify that address was derived from given seeds and bump\n        todo!(\"Implement is_valid_pda\")\n    }\n\n    pub fn hash_seeds(seeds: &[&[u8]], program_id: &str, bump: u8) -> [u8; 32] {\n        // TODO: Hash seeds with program_id and bump for address generation\n        todo!(\"Implement hash_seeds\")\n    }\n}",
              "solution": "impl PdaGenerator {\n    pub fn find_pda(seeds: &[&[u8]], program_id: &str) -> (String, u8) {\n        let mut bump = 255u8;\n\n        loop {\n            let address = Self::derive_address(seeds, program_id, bump);\n\n            // Check if off-curve (simplified: valid if doesn't start with specific prefix)\n            if Self::is_off_curve(&address) {\n                return (address, bump);\n            }\n\n            if bump == 0 {\n                break;\n            }\n            bump -= 1;\n        }\n\n        (\"invalid\".to_string(), 0)\n    }\n\n    pub fn create_seed_bytes(seeds: &[&str]) -> Vec<Vec<u8>> {\n        seeds.iter().map(|s| s.as_bytes().to_vec()).collect()\n    }\n\n    pub fn is_valid_pda(address: &str, seeds: &[&[u8]], program_id: &str, bump: u8) -> bool {\n        let derived = Self::derive_address(seeds, program_id, bump);\n        derived == address\n    }\n\n    fn derive_address(seeds: &[&[u8]], program_id: &str, bump: u8) -> String {\n        let hash = Self::hash_seeds(seeds, program_id, bump);\n        // Convert to base58-like string (simplified)\n        format!(\"pda_{:x}_{}\", hash[0], bump)\n    }\n\n    fn hash_seeds(seeds: &[&[u8]], program_id: &str, bump: u8) -> [u8; 32] {\n        let mut result = [0u8; 32];\n\n        // Simple hash combining all inputs\n        for (i, seed) in seeds.iter().enumerate() {\n            for (j, &byte) in seed.iter().enumerate() {\n                result[(i + j) % 32] ^= byte;\n            }\n        }\n\n        for (i, byte) in program_id.as_bytes().iter().enumerate() {\n            result[i % 32] ^= *byte;\n        }\n\n        result[0] ^= bump;\n        result\n    }\n\n    fn is_off_curve(address: &str) -> bool {\n        // Simplified: valid PDA if contains \"pda_\" prefix\n        address.starts_with(\"pda_\")\n    }\n}",
              "hints": [
                "Try bumps from 255 down to 0",
                "Combine seeds, program_id, and bump in hash",
                "Check if derived address matches expected"
              ],
              "testCases": [
                {
                  "input": {
                    "seeds": [
                      "user"
                    ],
                    "program": "prog1"
                  },
                  "expected": {
                    "has_bump": true
                  }
                },
                {
                  "input": {
                    "seeds": [
                      "user"
                    ],
                    "program": "prog1"
                  },
                  "expected": {
                    "address": "pda_"
                  }
                },
                {
                  "input": {
                    "validate": {
                      "seeds": [
                        "user"
                      ],
                      "bump": 255
                    }
                  },
                  "expected": {
                    "valid": true
                  }
                }
              ]
            },
            {
              "id": "lesson-50-1-3",
              "type": "challenge",
              "title": "Seed Composer Challenge",
              "description": "Compose complex seed patterns for different use cases.",
              "starterCode": "pub struct SeedComposer;\n\nimpl SeedComposer {\n    pub fn user_pda_seed(user_pubkey: &str, program_id: &str) -> Vec<Vec<u8>> {\n        // TODO: Create seed for user-specific PDA\n        // Format: [\"user\", user_pubkey, program_id]\n        todo!(\"Implement user_pda_seed\")\n    }\n\n    pub fn vault_pda_seed(vault_id: u64, token_mint: &str) -> Vec<Vec<u8>> {\n        // TODO: Create seed for vault PDA\n        // Format: [\"vault\", vault_id_bytes, token_mint]\n        todo!(\"Implement vault_pda_seed\")\n    }\n\n    pub fn authority_pda_seed(role: &str, nonce: u64) -> Vec<Vec<u8>> {\n        // TODO: Create seed for authority PDA\n        // Format: [\"authority\", role, nonce_bytes]\n        todo!(\"Implement authority_pda_seed\")\n    }\n\n    pub fn escrow_pda_seed(trade_id: &str, party_a: &str, party_b: &str) -> Vec<Vec<u8>> {\n        // TODO: Create seed for escrow PDA\n        // Format: [\"escrow\", trade_id, party_a, party_b]\n        todo!(\"Implement escrow_pda_seed\")\n    }\n}",
              "solution": "impl SeedComposer {\n    pub fn user_pda_seed(user_pubkey: &str, program_id: &str) -> Vec<Vec<u8>> {\n        vec![\n            b\"user\".to_vec(),\n            user_pubkey.as_bytes().to_vec(),\n            program_id.as_bytes().to_vec(),\n        ]\n    }\n\n    pub fn vault_pda_seed(vault_id: u64, token_mint: &str) -> Vec<Vec<u8>> {\n        vec![\n            b\"vault\".to_vec(),\n            vault_id.to_le_bytes().to_vec(),\n            token_mint.as_bytes().to_vec(),\n        ]\n    }\n\n    pub fn authority_pda_seed(role: &str, nonce: u64) -> Vec<Vec<u8>> {\n        vec![\n            b\"authority\".to_vec(),\n            role.as_bytes().to_vec(),\n            nonce.to_le_bytes().to_vec(),\n        ]\n    }\n\n    pub fn escrow_pda_seed(trade_id: &str, party_a: &str, party_b: &str) -> Vec<Vec<u8>> {\n        vec![\n            b\"escrow\".to_vec(),\n            trade_id.as_bytes().to_vec(),\n            party_a.as_bytes().to_vec(),\n            party_b.as_bytes().to_vec(),\n        ]\n    }\n}",
              "hints": [
                "Use byte string literals b\"...\" for static prefixes",
                "Convert integers with to_le_bytes()",
                "Collect into Vec<Vec<u8>>"
              ],
              "testCases": [
                {
                  "input": {
                    "user": "alice",
                    "program": "prog1"
                  },
                  "expected": {
                    "seeds": 3
                  }
                },
                {
                  "input": {
                    "vault_id": 123,
                    "mint": "USDC"
                  },
                  "expected": {
                    "seeds": 3
                  }
                },
                {
                  "input": {
                    "role": "admin",
                    "nonce": 456
                  },
                  "expected": {
                    "seeds": 3
                  }
                },
                {
                  "input": {
                    "trade": "trade1",
                    "a": "alice",
                    "b": "bob"
                  },
                  "expected": {
                    "seeds": 4
                  }
                }
              ]
            },
            {
              "id": "lesson-50-1-4",
              "type": "challenge",
              "title": "Bump Manager Challenge",
              "description": "Manage bump seeds for PDA verification and signing.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct PdaAccount {\n    pub address: String,\n    pub bump: u8,\n    pub seeds: Vec<Vec<u8>>,\n}\n\npub struct BumpManager;\n\nimpl BumpManager {\n    pub fn store_bump(account: &mut PdaAccount, bump: u8) {\n        // TODO: Store bump in account for later verification\n        todo!(\"Implement store_bump\")\n    }\n\n    pub fn verify_bump(account: &PdaAccount, expected_seeds: &[&[u8]], program_id: &str) -> bool {\n        // TODO: Verify stored bump matches expected derivation\n        todo!(\"Implement verify_bump\")\n    }\n\n    pub fn get_signer_seeds<'a>(account: &'a PdaAccount) -> Vec<&'a [u8]> {\n        // TODO: Get seeds for CPI signer invocation\n        todo!(\"Implement get_signer_seeds\")\n    }\n\n    pub fn is_canonical_bump(bump: u8, seeds: &[&[u8]], program_id: &str) -> bool {\n        // TODO: Check if bump is the canonical (highest valid) bump\n        todo!(\"Implement is_canonical_bump\")\n    }\n}",
              "solution": "impl BumpManager {\n    pub fn store_bump(account: &mut PdaAccount, bump: u8) {\n        account.bump = bump;\n    }\n\n    pub fn verify_bump(account: &PdaAccount, expected_seeds: &[&[u8]], program_id: &str) -> bool {\n        // Verify stored seeds match expected\n        if account.seeds.len() != expected_seeds.len() {\n            return false;\n        }\n        for (stored, expected) in account.seeds.iter().zip(expected_seeds.iter()) {\n            if stored != *expected {\n                return false;\n            }\n        }\n\n        // Verify address matches derivation\n        PdaGenerator::is_valid_pda(&account.address, expected_seeds, program_id, account.bump)\n    }\n\n    pub fn get_signer_seeds<'a>(account: &'a PdaAccount) -> Vec<&'a [u8]> {\n        account.seeds.iter()\n            .map(|s| s.as_slice())\n            .chain(std::iter::once(&[account.bump][..]))\n            .collect()\n    }\n\n    pub fn is_canonical_bump(bump: u8, seeds: &[&[u8]], program_id: &str) -> bool {\n        let (_, canonical_bump) = PdaGenerator::find_pda(seeds, program_id);\n        bump == canonical_bump\n    }\n}",
              "hints": [
                "Compare stored seeds with expected seeds",
                "Signer seeds include all seeds plus bump",
                "Canonical bump is from find_pda with highest valid bump"
              ],
              "testCases": [
                {
                  "input": {
                    "store": 255
                  },
                  "expected": {
                    "bump": 255
                  }
                },
                {
                  "input": {
                    "seeds": [
                      "user"
                    ],
                    "program": "prog1"
                  },
                  "expected": {
                    "verify": true
                  }
                },
                {
                  "input": {
                    "signer_seeds": true
                  },
                  "expected": {
                    "count": 2
                  }
                },
                {
                  "input": {
                    "bump": 255,
                    "seeds": [
                      "user"
                    ]
                  },
                  "expected": {
                    "canonical": true
                  }
                }
              ]
            }
          ]
        },
        {
          "id": "mod-50-2",
          "title": "Advanced PDA Patterns",
          "description": "Implement advanced PDA patterns (nested/counter/stateful) while preserving security invariants and migration safety.",
          "lessons": [
            {
              "id": "lesson-50-2-1",
              "type": "content",
              "title": "PDA Design Patterns",
              "content": "Advanced PDA patterns solve real scaling and composability needs but increase design complexity.\n\nNested PDAs, counter-based PDAs, and multi-tenant PDA namespaces each require explicit invariants around uniqueness, lifecycle, and authority boundaries.\n\nKey safeguards:\n- monotonic counters with replay protection,\n- collision checks in shared namespaces,\n- explicit ownership checks on all derived-state paths,\n- deterministic migration paths when schema/seed versions evolve.\n\nCross-program PDA interactions must minimize signer scope. invoke_signed should only grant exactly what downstream steps require.\n\nOperationally, advanced PDA systems need deterministic audit artifacts: derivation inputs, expected outputs, and validation results by instruction path.\n\nComplex PDA architecture is safe when derivation logic remains simple to reason about and impossible to interpret ambiguously."
            },
            {
              "id": "lesson-50-2-2",
              "type": "challenge",
              "title": "Nested PDA Generator Challenge",
              "description": "Generate PDAs derived from other PDA addresses.",
              "starterCode": "pub struct NestedPdaGenerator;\n\nimpl NestedPdaGenerator {\n    pub fn derive_child_pda(parent_pda: &str, child_id: &str, program_id: &str) -> (String, u8) {\n        // TODO: Derive child PDA from parent PDA address\n        todo!(\"Implement derive_child_pda\")\n    }\n\n    pub fn derive_sibling_pda(base_pda: &str, sibling_index: u32, program_id: &str) -> (String, u8) {\n        // TODO: Derive sibling PDA with same base but different index\n        todo!(\"Implement derive_sibling_pda\")\n    }\n\n    pub fn derive_hierarchical_pda(components: &[&str], program_id: &str) -> (String, u8) {\n        // TODO: Derive PDA from hierarchical path components\n        // e.g., [\"user\", \"alice\", \"vault\", \"1\"]\n        todo!(\"Implement derive_hierarchical_pda\")\n    }\n\n    pub fn verify_parent_child(parent: &str, child: &str, child_id: &str, program_id: &str) -> bool {\n        // TODO: Verify child was derived from parent\n        todo!(\"Implement verify_parent_child\")\n    }\n}",
              "solution": "impl NestedPdaGenerator {\n    pub fn derive_child_pda(parent_pda: &str, child_id: &str, program_id: &str) -> (String, u8) {\n        let seeds: Vec<&[u8]> = vec![\n            parent_pda.as_bytes(),\n            b\"child\",\n            child_id.as_bytes(),\n        ];\n        PdaGenerator::find_pda(&seeds, program_id)\n    }\n\n    pub fn derive_sibling_pda(base_pda: &str, sibling_index: u32, program_id: &str) -> (String, u8) {\n        let seeds: Vec<&[u8]> = vec![\n            base_pda.as_bytes(),\n            b\"sibling\",\n            &sibling_index.to_le_bytes(),\n        ];\n        PdaGenerator::find_pda(&seeds, program_id)\n    }\n\n    pub fn derive_hierarchical_pda(components: &[&str], program_id: &str) -> (String, u8) {\n        let seeds: Vec<&[u8]> = components.iter()\n            .map(|c| c.as_bytes())\n            .collect();\n        PdaGenerator::find_pda(&seeds, program_id)\n    }\n\n    pub fn verify_parent_child(parent: &str, child: &str, child_id: &str, program_id: &str) -> bool {\n        let (expected_child, _) = Self::derive_child_pda(parent, child_id, program_id);\n        expected_child == child\n    }\n}",
              "hints": [
                "Include parent address in child seeds",
                "Use index bytes for sibling derivation",
                "Verify by re-deriving and comparing"
              ],
              "testCases": [
                {
                  "input": {
                    "parent": "pda_abc",
                    "child_id": "vault1"
                  },
                  "expected": {
                    "child": "pda_"
                  }
                },
                {
                  "input": {
                    "base": "pda_abc",
                    "index": 5
                  },
                  "expected": {
                    "sibling": "pda_"
                  }
                },
                {
                  "input": {
                    "components": [
                      "user",
                      "alice",
                      "token"
                    ]
                  },
                  "expected": {
                    "pda": "pda_"
                  }
                },
                {
                  "input": {
                    "verify": {
                      "parent": "pda_abc",
                      "child_id": "vault1"
                    }
                  },
                  "expected": {
                    "valid": true
                  }
                }
              ]
            },
            {
              "id": "lesson-50-2-3",
              "type": "challenge",
              "title": "Counter PDA Generator Challenge",
              "description": "Generate unique PDAs using incrementing counters.",
              "starterCode": "pub struct CounterPdaGenerator {\n    pub counter: u64,\n}\n\nimpl CounterPdaGenerator {\n    pub fn new() -> Self {\n        Self { counter: 0 }\n    }\n\n    pub fn generate_next(&mut self, prefix: &str, program_id: &str) -> (String, u8) {\n        // TODO: Generate unique PDA using counter\n        todo!(\"Implement generate_next\")\n    }\n\n    pub fn generate_batch(&mut self, prefix: &str, program_id: &str, count: usize) -> Vec<(String, u8)> {\n        // TODO: Generate multiple unique PDAs\n        todo!(\"Implement generate_batch\")\n    }\n\n    pub fn get_counter(&self) -> u64 {\n        self.counter\n    }\n\n    pub fn reset_counter(&mut self) {\n        // TODO: Reset counter to 0\n        todo!(\"Implement reset_counter\")\n    }\n}",
              "solution": "impl CounterPdaGenerator {\n    pub fn new() -> Self {\n        Self { counter: 0 }\n    }\n\n    pub fn generate_next(&mut self, prefix: &str, program_id: &str) -> (String, u8) {\n        let seeds: Vec<&[u8]> = vec![\n            prefix.as_bytes(),\n            &self.counter.to_le_bytes(),\n        ];\n        let result = PdaGenerator::find_pda(&seeds, program_id);\n        self.counter += 1;\n        result\n    }\n\n    pub fn generate_batch(&mut self, prefix: &str, program_id: &str, count: usize) -> Vec<(String, u8)> {\n        (0..count)\n            .map(|_| self.generate_next(prefix, program_id))\n            .collect()\n    }\n\n    pub fn get_counter(&self) -> u64 {\n        self.counter\n    }\n\n    pub fn reset_counter(&mut self) {\n        self.counter = 0;\n    }\n}",
              "hints": [
                "Increment counter after each generation",
                "Use counter in seeds for uniqueness",
                "Batch generation calls generate_next multiple times"
              ],
              "testCases": [
                {
                  "input": {
                    "generate": "user"
                  },
                  "expected": {
                    "counter": 1
                  }
                },
                {
                  "input": {
                    "generate": "user"
                  },
                  "expected": {
                    "counter": 2
                  }
                },
                {
                  "input": {
                    "batch": 5
                  },
                  "expected": {
                    "count": 5,
                    "counter": 7
                  }
                },
                {
                  "input": {
                    "reset": true
                  },
                  "expected": {
                    "counter": 0
                  }
                }
              ]
            },
            {
              "id": "lesson-50-2-4",
              "type": "challenge",
              "title": "PDA Collision Detector Challenge",
              "description": "Detect and prevent PDA seed collisions.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct PdaRegistry {\n    pub entries: Vec<(Vec<Vec<u8>>, String)>,  // (seeds, address)\n}\n\npub struct CollisionDetector;\n\nimpl CollisionDetector {\n    pub fn new_registry() -> PdaRegistry {\n        PdaRegistry { entries: vec![] }\n    }\n\n    pub fn check_collision(registry: &PdaRegistry, seeds: &[Vec<u8>]) -> Option<String> {\n        // TODO: Check if seeds would collide with existing PDA\n        todo!(\"Implement check_collision\")\n    }\n\n    pub fn register_pda(registry: &mut PdaRegistry, seeds: Vec<Vec<u8>>, address: String) -> Result<(), String> {\n        // TODO: Register new PDA, fail if collision\n        todo!(\"Implement register_pda\")\n    }\n\n    pub fn find_by_address(registry: &PdaRegistry, address: &str) -> Option<&Vec<Vec<u8>>> {\n        // TODO: Find seeds for given address\n        todo!(\"Implement find_by_address\")\n    }\n\n    pub fn has_collision_risk(seeds_a: &[Vec<u8>], seeds_b: &[Vec<u8>]) -> bool {\n        // TODO: Check if two seed patterns could collide\n        todo!(\"Implement has_collision_risk\")\n    }\n}",
              "solution": "impl CollisionDetector {\n    pub fn new_registry() -> PdaRegistry {\n        PdaRegistry { entries: vec![] }\n    }\n\n    pub fn check_collision(registry: &PdaRegistry, seeds: &[Vec<u8>]) -> Option<String> {\n        for (existing_seeds, address) in &registry.entries {\n            if existing_seeds == seeds {\n                return Some(address.clone());\n            }\n        }\n        None\n    }\n\n    pub fn register_pda(registry: &mut PdaRegistry, seeds: Vec<Vec<u8>>, address: String) -> Result<(), String> {\n        if let Some(existing) = Self::check_collision(registry, &seeds) {\n            return Err(format!(\"Collision with existing PDA: {}\", existing));\n        }\n        registry.entries.push((seeds, address));\n        Ok(())\n    }\n\n    pub fn find_by_address(registry: &PdaRegistry, address: &str) -> Option<&Vec<Vec<u8>>> {\n        registry.entries.iter()\n            .find(|(_, addr)| addr == address)\n            .map(|(seeds, _)| seeds)\n    }\n\n    pub fn has_collision_risk(seeds_a: &[Vec<u8>], seeds_b: &[Vec<u8>]) -> bool {\n        // Check if seeds have same length and similar structure\n        if seeds_a.len() != seeds_b.len() {\n            return false;\n        }\n\n        // Check if all components are the same type/length\n        seeds_a.iter().zip(seeds_b.iter())\n            .all(|(a, b)| a.len() == b.len())\n    }\n}",
              "hints": [
                "Check if seeds match any existing entry",
                "Return error if collision detected",
                "Collision risk if same structure and component sizes"
              ],
              "testCases": [
                {
                  "input": {
                    "register": {
                      "seeds": [
                        "user"
                      ],
                      "address": "pda_1"
                    }
                  },
                  "expected": {
                    "ok": true
                  }
                },
                {
                  "input": {
                    "check": {
                      "seeds": [
                        "user"
                      ]
                    }
                  },
                  "expected": {
                    "collision": "pda_1"
                  }
                },
                {
                  "input": {
                    "find": "pda_1"
                  },
                  "expected": {
                    "found": true
                  }
                },
                {
                  "input": {
                    "risk": {
                      "a": [
                        "x",
                        "y"
                      ],
                      "b": [
                        "a",
                        "b"
                      ]
                    }
                  },
                  "expected": {
                    "risk": true
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "course-051",
      "slug": "solana-economics",
      "title": "Solana Economics and Token Flows",
      "description": "Analyze Solana economic dynamics in production context: inflation/fee-burn interplay, staking flows, supply movement, and protocol sustainability tradeoffs.",
      "difficulty": "intermediate",
      "duration": "5 weeks",
      "totalXP": 1800,
      "tags": [
        "economics",
        "inflation",
        "fees",
        "rent",
        "token-flows",
        "sustainability"
      ],
      "imageUrl": "/images/courses/solana-economics.svg",
      "modules": [
        {
          "id": "mod-51-1",
          "title": "Solana Economic Model",
          "description": "Understand Solana macro token economics (inflation, burn, rewards, fees) with deterministic scenario modeling.",
          "lessons": [
            {
              "id": "lesson-51-1-1",
              "type": "content",
              "title": "Solana Token Economics",
              "content": "Solana economics is the interaction of issuance, burn, staking rewards, and usage demand. Sustainable protocol decisions require understanding these flows as a system, not isolated metrics.\n\nCore mechanisms include:\n1) inflation schedule and long-term emission behavior,\n2) fee burn and validator reward pathways,\n3) staking participation effects on circulating supply.\n\nEconomic analysis should be scenario-driven. Single-point estimates hide risk. Teams should model calm/high-usage/low-usage regimes and compare supply-pressure outcomes.\n\nDeterministic calculators are useful for governance and product planning because they make assumptions explicit: epoch cadence, fee volume, staking ratio, and unlock schedules.\n\nHealthy economic reasoning links network-level flows to protocol-level choices (treasury policy, incentive emissions, fee strategy).\n\nEconomic quality improves when teams publish assumption-driven reports instead of headline narratives."
            },
            {
              "id": "lesson-51-1-2",
              "type": "challenge",
              "title": "Inflation Calculator Challenge",
              "description": "Calculate inflation rate and staking rewards over time.",
              "starterCode": "pub struct InflationConfig {\n    pub initial_rate: f64,      // 0.08 for 8%\n    pub disinflation_rate: f64, // 0.15 for 15% reduction per year\n    pub long_term_rate: f64,    // 0.015 for 1.5%\n}\n\npub struct InflationCalculator;\n\nimpl InflationCalculator {\n    pub fn inflation_rate(config: &InflationConfig, year: u32) -> f64 {\n        // TODO: Calculate inflation rate for given year\n        // rate = initial * (1 - disinflation)^year, capped at long_term_rate\n        todo!(\"Implement inflation_rate\")\n    }\n\n    pub fn total_supply_after_years(initial_supply: u64, config: &InflationConfig, years: u32) -> u64 {\n        // TODO: Calculate total supply after N years of inflation\n        todo!(\"Implement total_supply_after_years\")\n    }\n\n    pub fn staking_apy(config: &InflationConfig, year: u32, percent_staked: f64) -> f64 {\n        // TODO: Calculate staking APY given inflation and staked percentage\n        // APY = inflation_rate / percent_staked\n        todo!(\"Implement staking_apy\")\n    }\n\n    pub fn years_to_long_term(config: &InflationConfig) -> u32 {\n        // TODO: Calculate years until inflation reaches long-term rate\n        todo!(\"Implement years_to_long_term\")\n    }\n}",
              "solution": "impl InflationCalculator {\n    pub fn inflation_rate(config: &InflationConfig, year: u32) -> f64 {\n        let rate = config.initial_rate * (1.0 - config.disinflation_rate).powi(year as i32);\n        rate.max(config.long_term_rate)\n    }\n\n    pub fn total_supply_after_years(initial_supply: u64, config: &InflationConfig, years: u32) -> u64 {\n        let mut supply = initial_supply as f64;\n        for year in 0..years {\n            let rate = Self::inflation_rate(config, year);\n            supply *= 1.0 + rate;\n        }\n        supply as u64\n    }\n\n    pub fn staking_apy(config: &InflationConfig, year: u32, percent_staked: f64) -> f64 {\n        if percent_staked == 0.0 {\n            return 0.0;\n        }\n        let inflation = Self::inflation_rate(config, year);\n        (inflation / percent_staked) * 100.0\n    }\n\n    pub fn years_to_long_term(config: &InflationConfig) -> u32 {\n        let mut years = 0u32;\n        loop {\n            let rate = Self::inflation_rate(config, years);\n            if rate <= config.long_term_rate {\n                return years;\n            }\n            years += 1;\n            if years > 100 {\n                return 100; // Safety limit\n            }\n        }\n    }\n}",
              "hints": [
                "Use powi for disinflation calculation",
                "Compound inflation year over year",
                "APY is inflation divided by staked percentage"
              ],
              "testCases": [
                {
                  "input": {
                    "initial": 0.08,
                    "disinflation": 0.15,
                    "year": 0
                  },
                  "expected": {
                    "rate": 0.08
                  }
                },
                {
                  "input": {
                    "initial": 0.08,
                    "disinflation": 0.15,
                    "year": 1
                  },
                  "expected": {
                    "rate": 0.068
                  }
                },
                {
                  "input": {
                    "supply": 1000000,
                    "years": 1,
                    "rate": 0.08
                  },
                  "expected": {
                    "supply": 1080000
                  }
                },
                {
                  "input": {
                    "inflation": 0.08,
                    "staked": 0.7
                  },
                  "expected": {
                    "apy": 11.43
                  }
                }
              ]
            },
            {
              "id": "lesson-51-1-3",
              "type": "challenge",
              "title": "Fee Burn Calculator Challenge",
              "description": "Calculate fee burns and their deflationary impact.",
              "starterCode": "pub struct FeeConfig {\n    pub base_fee: u64,\n    pub priority_fee_multiplier: f64,\n    pub burn_percent: u8,  // 50 for 50%\n}\n\npub struct BurnCalculator;\n\nimpl BurnCalculator {\n    pub fn calculate_fee(config: &FeeConfig, compute_units: u64, priority: u8) -> u64 {\n        // TODO: Calculate total transaction fee\n        // fee = base + (compute_units * priority_multiplier)\n        todo!(\"Implement calculate_fee\")\n    }\n\n    pub fn calculate_burn(config: &FeeConfig, total_fee: u64) -> u64 {\n        // TODO: Calculate amount to burn\n        todo!(\"Implement calculate_burn\")\n    }\n\n    pub fn calculate_validator_reward(config: &FeeConfig, total_fee: u64) -> u64 {\n        // TODO: Calculate validator reward (fee - burn)\n        todo!(\"Implement calculate_validator_reward\")\n    }\n\n    pub fn annual_burn_estimate(config: &FeeConfig, txs_per_day: u64, avg_fee: u64) -> u64 {\n        // TODO: Estimate annual SOL burn\n        todo!(\"Implement annual_burn_estimate\")\n    }\n}",
              "solution": "impl BurnCalculator {\n    pub fn calculate_fee(config: &FeeConfig, compute_units: u64, priority: u8) -> u64 {\n        let base = config.base_fee;\n        let priority_multiplier = 1.0 + (priority as f64 * config.priority_fee_multiplier);\n        let cu_fee = (compute_units as f64 * priority_multiplier) as u64;\n        base + cu_fee\n    }\n\n    pub fn calculate_burn(config: &FeeConfig, total_fee: u64) -> u64 {\n        (total_fee as u128 * config.burn_percent as u128 / 100) as u64\n    }\n\n    pub fn calculate_validator_reward(config: &FeeConfig, total_fee: u64) -> u64 {\n        total_fee - Self::calculate_burn(config, total_fee)\n    }\n\n    pub fn annual_burn_estimate(config: &FeeConfig, txs_per_day: u64, avg_fee: u64) -> u64 {\n        let daily_burn = txs_per_day * Self::calculate_burn(config, avg_fee);\n        daily_burn * 365\n    }\n}",
              "hints": [
                "Priority multiplier increases with priority level",
                "Burn is percentage of total fee",
                "Annual estimate is daily * 365"
              ],
              "testCases": [
                {
                  "input": {
                    "base": 5000,
                    "cu": 200000,
                    "priority": 0
                  },
                  "expected": {
                    "fee": 5000
                  }
                },
                {
                  "input": {
                    "fee": 10000,
                    "burn_pct": 50
                  },
                  "expected": {
                    "burn": 5000
                  }
                },
                {
                  "input": {
                    "fee": 10000,
                    "burn_pct": 50
                  },
                  "expected": {
                    "reward": 5000
                  }
                },
                {
                  "input": {
                    "txs_per_day": 1000000,
                    "avg_fee": 5000
                  },
                  "expected": {
                    "annual_burn": 912500000000
                  }
                }
              ]
            },
            {
              "id": "lesson-51-1-4",
              "type": "challenge",
              "title": "Rent Economics Calculator Challenge",
              "description": "Calculate rent costs and exemption thresholds.",
              "starterCode": "pub struct RentConfig {\n    pub lamports_per_byte_year: u64,\n    pub exemption_threshold_years: f64,\n}\n\npub struct RentCalculator;\n\nimpl RentCalculator {\n    pub fn annual_rent(config: &RentConfig, data_size: u64) -> u64 {\n        // TODO: Calculate annual rent for account\n        todo!(\"Implement annual_rent\")\n    }\n\n    pub fn exemption_threshold(config: &RentConfig, data_size: u64) -> u64 {\n        // TODO: Calculate minimum balance for rent exemption\n        todo!(\"Implement exemption_threshold\")\n    }\n\n    pub fn is_exempt(balance: u64, config: &RentConfig, data_size: u64) -> bool {\n        // TODO: Check if balance is rent exempt\n        todo!(\"Implement is_exempt\")\n    }\n\n    pub fn calculate_rent_due(config: &RentConfig, data_size: u64, years: f64) -> u64 {\n        // TODO: Calculate rent due for period\n        todo!(\"Implement calculate_rent_due\")\n    }\n}",
              "solution": "impl RentCalculator {\n    pub fn annual_rent(config: &RentConfig, data_size: u64) -> u64 {\n        data_size * config.lamports_per_byte_year\n    }\n\n    pub fn exemption_threshold(config: &RentConfig, data_size: u64) -> u64 {\n        let annual = Self::annual_rent(config, data_size);\n        (annual as f64 * config.exemption_threshold_years) as u64\n    }\n\n    pub fn is_exempt(balance: u64, config: &RentConfig, data_size: u64) -> bool {\n        balance >= Self::exemption_threshold(config, data_size)\n    }\n\n    pub fn calculate_rent_due(config: &RentConfig, data_size: u64, years: f64) -> u64 {\n        let annual = Self::annual_rent(config, data_size);\n        (annual as f64 * years) as u64\n    }\n}",
              "hints": [
                "Annual rent is bytes times rate",
                "Exemption is annual times threshold years",
                "Rent due is annual times period"
              ],
              "testCases": [
                {
                  "input": {
                    "size": 128,
                    "rate": 3480
                  },
                  "expected": {
                    "annual": 445440
                  }
                },
                {
                  "input": {
                    "size": 128,
                    "rate": 3480,
                    "threshold": 2
                  },
                  "expected": {
                    "exemption": 890880
                  }
                },
                {
                  "input": {
                    "balance": 1000000,
                    "size": 128
                  },
                  "expected": {
                    "exempt": true
                  }
                },
                {
                  "input": {
                    "size": 128,
                    "years": 2
                  },
                  "expected": {
                    "due": 890880
                  }
                }
              ]
            }
          ]
        },
        {
          "id": "mod-51-2",
          "title": "Token Flow Analysis",
          "description": "Model token flow dynamics and sustainability signals using supply categories, unlock events, and behavior-driven liquidity effects.",
          "lessons": [
            {
              "id": "lesson-51-2-1",
              "type": "content",
              "title": "Token Flow Dynamics",
              "content": "Token flow analysis turns abstract economics into operational insight. The key is to track where tokens are (staked, circulating, locked, treasury, pending unlock) and how they move over time.\n\nUseful flow metrics include:\n- net circulating change,\n- staking inflow/outflow trend,\n- unlock cliff concentration,\n- treasury spend velocity.\n\nUnlock events should be modeled for market-impact risk. Large clustered unlocks can create short-term supply shock even when long-term tokenomics is sound.\n\nFlow tooling should support deterministic category accounting and conservation checks (total categorized supply consistency).\n\nFor governance, flow analysis is most valuable when tied to policy actions: adjust emissions, change vesting cadence, alter incentive programs.\n\nSustainable token systems are not static designs; they are continuously monitored flow systems with explicit policy feedback loops."
            },
            {
              "id": "lesson-51-2-2",
              "type": "challenge",
              "title": "Supply Flow Tracker Challenge",
              "description": "Track token supply categories and flows.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct SupplyBreakdown {\n    pub circulating: u64,\n    pub staked: u64,\n    pub locked: u64,\n    pub burned: u64,\n}\n\n#[derive(Debug, Clone)]\npub struct TokenFlow {\n    pub from: String,\n    pub to: String,\n    pub amount: u64,\n    pub timestamp: u64,\n}\n\npub struct SupplyTracker;\n\nimpl SupplyTracker {\n    pub fn total_supply(breakdown: &SupplyBreakdown) -> u64 {\n        // TODO: Calculate total supply (excluding burned)\n        todo!(\"Implement total_supply\")\n    }\n\n    pub fn staked_ratio(breakdown: &SupplyBreakdown) -> f64 {\n        // TODO: Calculate percentage of supply that is staked\n        todo!(\"Implement staked_ratio\")\n    }\n\n    pub fn apply_flow(breakdown: &mut SupplyBreakdown, flow: &TokenFlow) -> Result<(), String> {\n        // TODO: Apply token flow to supply breakdown\n        todo!(\"Implement apply_flow\")\n    }\n\n    pub fn net_flow(flows: &[TokenFlow], category: &str) -> i64 {\n        // TODO: Calculate net flow for a category (in - out)\n        todo!(\"Implement net_flow\")\n    }\n}",
              "solution": "impl SupplyTracker {\n    pub fn total_supply(breakdown: &SupplyBreakdown) -> u64 {\n        breakdown.circulating + breakdown.staked + breakdown.locked\n    }\n\n    pub fn staked_ratio(breakdown: &SupplyBreakdown) -> f64 {\n        let total = Self::total_supply(breakdown);\n        if total == 0 {\n            return 0.0;\n        }\n        (breakdown.staked as f64 / total as f64) * 100.0\n    }\n\n    pub fn apply_flow(breakdown: &mut SupplyBreakdown, flow: &TokenFlow) -> Result<(), String> {\n        match flow.from.as_str() {\n            \"circulating\" => breakdown.circulating = breakdown.circulating.checked_sub(flow.amount).ok_or(\"Underflow\")?,\n            \"staked\" => breakdown.staked = breakdown.staked.checked_sub(flow.amount).ok_or(\"Underflow\")?,\n            \"locked\" => breakdown.locked = breakdown.locked.checked_sub(flow.amount).ok_or(\"Underflow\")?,\n            _ => {}\n        }\n\n        match flow.to.as_str() {\n            \"circulating\" => breakdown.circulating += flow.amount,\n            \"staked\" => breakdown.staked += flow.amount,\n            \"locked\" => breakdown.locked += flow.amount,\n            \"burned\" => breakdown.burned += flow.amount,\n            _ => {}\n        }\n\n        Ok(())\n    }\n\n    pub fn net_flow(flows: &[TokenFlow], category: &str) -> i64 {\n        let inflow: u64 = flows.iter()\n            .filter(|f| f.to == category)\n            .map(|f| f.amount)\n            .sum();\n        let outflow: u64 = flows.iter()\n            .filter(|f| f.from == category)\n            .map(|f| f.amount)\n            .sum();\n        inflow as i64 - outflow as i64\n    }\n}",
              "hints": [
                "Total excludes burned tokens",
                "Apply flow by subtracting from source, adding to destination",
                "Net flow is inflow minus outflow"
              ],
              "testCases": [
                {
                  "input": {
                    "circulating": 500,
                    "staked": 300,
                    "locked": 200
                  },
                  "expected": {
                    "total": 1000
                  }
                },
                {
                  "input": {
                    "staked": 300,
                    "total": 1000
                  },
                  "expected": {
                    "ratio": 30
                  }
                },
                {
                  "input": {
                    "flow": {
                      "from": "circulating",
                      "to": "staked",
                      "amount": 100
                    }
                  },
                  "expected": {
                    "circulating": 400,
                    "staked": 400
                  }
                },
                {
                  "input": {
                    "flows": [
                      {
                        "to": "staked",
                        "amount": 100
                      },
                      {
                        "from": "staked",
                        "amount": 50
                      }
                    ]
                  },
                  "expected": {
                    "net": 50
                  }
                }
              ]
            },
            {
              "id": "lesson-51-2-3",
              "type": "challenge",
              "title": "Vesting Schedule Impact Challenge",
              "description": "Calculate token unlock impact on supply.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct VestingSchedule {\n    pub total_amount: u64,\n    pub cliff_months: u32,\n    pub vesting_months: u32,\n    pub start_month: u32,\n}\n\npub struct VestingImpact;\n\nimpl VestingImpact {\n    pub fn vested_amount(schedule: &VestingSchedule, current_month: u32) -> u64 {\n        // TODO: Calculate amount vested by given month\n        todo!(\"Implement vested_amount\")\n    }\n\n    pub fn monthly_unlock(schedule: &VestingSchedule, month: u32) -> u64 {\n        // TODO: Calculate amount unlocking in specific month\n        todo!(\"Implement monthly_unlock\")\n    }\n\n    pub fn total_unlocks_by_month(schedules: &[VestingSchedule], month: u32) -> u64 {\n        // TODO: Sum all unlocks across schedules for a month\n        todo!(\"Implement total_unlocks_by_month\")\n    }\n\n    pub fn peak_monthly_unlock(schedules: &[VestingSchedule]) -> (u32, u64) {\n        // TODO: Find month with highest total unlock\n        todo!(\"Implement peak_monthly_unlock\")\n    }\n}",
              "solution": "impl VestingImpact {\n    pub fn vested_amount(schedule: &VestingSchedule, current_month: u32) -> u64 {\n        let elapsed = current_month.saturating_sub(schedule.start_month);\n\n        if elapsed < schedule.cliff_months {\n            return 0;\n        }\n\n        if elapsed >= schedule.cliff_months + schedule.vesting_months {\n            return schedule.total_amount;\n        }\n\n        let vesting_elapsed = elapsed - schedule.cliff_months;\n        (schedule.total_amount as u128 * vesting_elapsed as u128 / schedule.vesting_months as u128) as u64\n    }\n\n    pub fn monthly_unlock(schedule: &VestingSchedule, month: u32) -> u64 {\n        let prev = Self::vested_amount(schedule, month.saturating_sub(1));\n        let curr = Self::vested_amount(schedule, month);\n        curr - prev\n    }\n\n    pub fn total_unlocks_by_month(schedules: &[VestingSchedule], month: u32) -> u64 {\n        schedules.iter()\n            .map(|s| Self::monthly_unlock(s, month))\n            .sum()\n    }\n\n    pub fn peak_monthly_unlock(schedules: &[VestingSchedule]) -> (u32, u64) {\n        let mut max_month = 0u32;\n        let mut max_unlock = 0u64;\n\n        // Check first 60 months\n        for month in 0..60 {\n            let unlock = Self::total_unlocks_by_month(schedules, month);\n            if unlock > max_unlock {\n                max_unlock = unlock;\n                max_month = month;\n            }\n        }\n\n        (max_month, max_unlock)\n    }\n}",
              "hints": [
                "0 before cliff, linear after, full at end",
                "Monthly unlock is difference between consecutive months",
                "Check multiple months to find peak"
              ],
              "testCases": [
                {
                  "input": {
                    "total": 12000,
                    "cliff": 6,
                    "vesting": 12,
                    "start": 0,
                    "month": 0
                  },
                  "expected": {
                    "vested": 0
                  }
                },
                {
                  "input": {
                    "total": 12000,
                    "cliff": 6,
                    "vesting": 12,
                    "start": 0,
                    "month": 6
                  },
                  "expected": {
                    "vested": 0
                  }
                },
                {
                  "input": {
                    "total": 12000,
                    "cliff": 6,
                    "vesting": 12,
                    "start": 0,
                    "month": 12
                  },
                  "expected": {
                    "vested": 6000
                  }
                },
                {
                  "input": {
                    "total": 12000,
                    "cliff": 6,
                    "vesting": 12,
                    "start": 0,
                    "month": 18
                  },
                  "expected": {
                    "vested": 12000
                  }
                }
              ]
            },
            {
              "id": "lesson-51-2-4",
              "type": "challenge",
              "title": "Protocol Sustainability Score Challenge",
              "description": "Calculate sustainability metrics for tokenomics.",
              "starterCode": "#[derive(Debug, Clone)]\npub struct ProtocolMetrics {\n    pub monthly_inflation: u64,\n    pub monthly_burn: u64,\n    pub monthly_revenue: u64,\n    pub treasury_balance: u64,\n    pub staked_supply: u64,\n    pub total_supply: u64,\n}\n\npub struct SustainabilityScorer;\n\nimpl SustainabilityScorer {\n    pub fn net_issuance(metrics: &ProtocolMetrics) -> i64 {\n        // TODO: Calculate net issuance (inflation - burn)\n        todo!(\"Implement net_issuance\")\n    }\n\n    pub fn burn_ratio(metrics: &ProtocolMetrics) -> f64 {\n        // TODO: Calculate burn as percentage of inflation\n        todo!(\"Implement burn_ratio\")\n    }\n\n    pub fn treasury_runway(metrics: &ProtocolMetrics, monthly_expenses: u64) -> f64 {\n        // TODO: Calculate months of runway\n        todo!(\"Implement treasury_runway\")\n    }\n\n    pub fn sustainability_score(metrics: &ProtocolMetrics) -> u8 {\n        // TODO: Calculate overall sustainability score (0-100)\n        // Higher is better\n        todo!(\"Implement sustainability_score\")\n    }\n}",
              "solution": "impl SustainabilityScorer {\n    pub fn net_issuance(metrics: &ProtocolMetrics) -> i64 {\n        metrics.monthly_inflation as i64 - metrics.monthly_burn as i64\n    }\n\n    pub fn burn_ratio(metrics: &ProtocolMetrics) -> f64 {\n        if metrics.monthly_inflation == 0 {\n            return 0.0;\n        }\n        (metrics.monthly_burn as f64 / metrics.monthly_inflation as f64) * 100.0\n    }\n\n    pub fn treasury_runway(metrics: &ProtocolMetrics, monthly_expenses: u64) -> f64 {\n        if monthly_expenses == 0 {\n            return f64::INFINITY;\n        }\n        metrics.treasury_balance as f64 / monthly_expenses as f64\n    }\n\n    pub fn sustainability_score(metrics: &ProtocolMetrics) -> u8 {\n        let mut score = 50u8; // Base score\n\n        // Burn ratio bonus (up to 25 points)\n        let burn_ratio = Self::burn_ratio(metrics);\n        if burn_ratio >= 50.0 {\n            score += 25;\n        } else {\n            score += (burn_ratio / 2.0) as u8;\n        }\n\n        // Staking ratio bonus (up to 25 points)\n        let stake_ratio = if metrics.total_supply > 0 {\n            (metrics.staked_supply as f64 / metrics.total_supply as f64) * 100.0\n        } else {\n            0.0\n        };\n        score += (stake_ratio / 4.0).min(25.0) as u8;\n\n        score.min(100)\n    }\n}",
              "hints": [
                "Net issuance is inflation minus burn",
                "Burn ratio is burn divided by inflation",
                "Score combines burn ratio and staking ratio"
              ],
              "testCases": [
                {
                  "input": {
                    "inflation": 1000,
                    "burn": 500
                  },
                  "expected": {
                    "net": 500
                  }
                },
                {
                  "input": {
                    "inflation": 1000,
                    "burn": 500
                  },
                  "expected": {
                    "ratio": 50
                  }
                },
                {
                  "input": {
                    "treasury": 100000,
                    "expenses": 10000
                  },
                  "expected": {
                    "runway": 10
                  }
                },
                {
                  "input": {
                    "burn_ratio": 50,
                    "staked": 70,
                    "total": 100
                  },
                  "expected": {
                    "score": 75
                  }
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}
