{
  "generatedAt": "2026-02-19T21:35:15.367Z",
  "locales": [
    {
      "locale": "es",
      "exactEnglishMatches": [
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].options[0]",
          "text": "To calculate NFT metadata size"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "It is the user who paid the creation fee forever"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "What does `executable: true` indicate?"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].options[1]",
          "text": "Token balances are program-specific state managed by the token program"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "This is your active signer public key."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[1]",
          "text": "Convert SOL to lamports using 1_000_000_000 multiplier."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[0]",
          "text": "A client-only simulation mode"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[1]",
          "text": "Calling one on-chain program from another on-chain program"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].prompt",
          "text": "Why are PDAs useful?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].options[0]",
          "text": "They let programs derive deterministic addresses without private keys"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].options[1]",
          "text": "The runtime on behalf of the program when invoke_signed seeds match"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].prompt",
          "text": "What happens if you change a seed?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[0]",
          "text": "The PDA stays the same but bump changes"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[2]",
          "text": "You derive a different PDA address"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].explanation",
          "text": "Seed bytes are part of the hash input, so any change yields a different derived address."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "A compressed NFT ledger entry"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[2].prompt",
          "text": "What authority controls minting?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[0]",
          "text": "Parse flags in pairs: --key value."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[2]",
          "text": "Construct JSON object in fixed key order before JSON.stringify."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does Anchor generate automatically from your program definitions?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Automatic PDA funding from devnet faucets"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A JSON interface used by clients/tests/tooling to call your program correctly"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "A private key format used only by on-chain programs"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is a seeds constraint verifying?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "That a token mint has 9 decimals"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].prompt",
          "text": "Why is a PDA considered off-curve?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].options[0]",
          "text": "It is derived to avoid having a corresponding private key"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].explanation",
          "text": "Off-curve means no user-held private key exists; programs authorize via seed proofs."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].prompt",
          "text": "What breaks if you change one PDA seed value?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[1]",
          "text": "Only the bump changes while address stays fixed"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[2]",
          "text": "Nothing changes unless RPC endpoint changes"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].explanation",
          "text": "PDA derivation is seed-sensitive. Any seed change creates a different address namespace."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].title",
          "text": "Initialize Counter PDA (deterministic)"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[0]",
          "text": "Use a deterministic hash-like reducer over programId + authorityPubkey + static seed."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[0]",
          "text": "Represent state as a pure JS structure so increment can be deterministic in tests."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[1]",
          "text": "Return a new state object from applyIncrement; avoid mutating the input object in-place."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the main role of optional integration tests?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Validate network execution paths after deterministic logic is proven"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Replace all unit tests"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Avoid asserting exact outputs"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Integration tests add runtime confidence but should not replace deterministic core checks."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do simulation failures happen even before final send succeeds?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because fee payer is irrelevant"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[0]",
          "text": "Compose the checkpoint from deterministic helper functions to keep output stable."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Where do SPL token balances actually live?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why keep raw amounts as integer strings in model code?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because decimals are always 9"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "Show pending overlays first, mutate durable balances only after stronger confirmation"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[2]",
          "text": "Disable activity feed until finalized"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "Optimistic overlays are useful, but confirmed state must remain authoritative."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].options[2]",
          "text": "Because commitment levels require it by protocol"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Phase-specific metrics enable actionable incident diagnosis."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is ordering by (ts, id) preferred over timestamp-only replay?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Stable ordering prevents environment-dependent state divergence."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should happen when the same event id arrives twice?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Idempotency guarantees deterministic behavior under retries."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[0]",
          "text": "Sort by (ts, id) before applying events."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[1]",
          "text": "Deduplicate by event id before snapshot interval checks."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[2]",
          "text": "Build checksum from stable snapshot metadata, not random values."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[0]",
          "text": "Use fixed-scale integers (micro USD) instead of floating point."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[1]",
          "text": "Apply filter -> search -> sort in a deterministic order."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "To reduce CSS size only"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because rate limits require it"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the main risk of generic one-size-fits-all error banners?"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Users cannot distinguish recovery actions across failure classes"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "They always break hydration"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Which metric should drive route selection at execution size?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Deterministic outAmount from full route simulation"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Displayed ticker price only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Lowest hop count only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Route quality is output-at-size, not headline spot labels."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does slippage tolerance directly determine?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "The minOut acceptance bound"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the deterministic minOut formula?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "minOut is a bounded percentage reduction from outAmount."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Why keep per-hop fee breakdowns?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Per-hop fee attribution makes route behavior auditable."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Minimize hop count always"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Choose first enumerated route"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "Why simulate virtual reserves per candidate route?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Virtual simulation avoids shared-state contamination."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].content",
          "text": "# Implement token/pool model + constant-product quote calc Implement deterministic CPMM quoting: - out = (reserveOut * inAfterFee) / (reserveIn + inAfterFee) - fee = floor(inAmount * feeBps / 10000) - impactBps from spot..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].hints[0]",
          "text": "Use inAfterFee = inAmount - floor(inAmount * feeBps / 10000)."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].hints[2]",
          "text": "Keep sorting deterministic to avoid route flicker."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[0]",
          "text": "Use virtual pool copies so fixture reserves are not mutated."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[2]",
          "text": "Return structured errors when pools or route links are invalid."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].prompt",
          "text": "What should happen when quote freshness expires?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].options[2]",
          "text": "Increase slippage automatically without notifying user"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Freshness boundaries should trigger deterministic recomputation."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which failures are not solved by blind retries?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].explanation",
          "text": "Planner errors require input/route changes, not repetition."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[0]",
          "text": "Keep output key order stable: swapPlan first, swapSummary second."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[1]",
          "text": "Path should be deterministic symbols along route hops."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[2]",
          "text": "Include fixtureHash + modelVersion under determinism metadata."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because owner checks improve rendering speed"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Because owner checks replace signer checks"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Only that an amount field exists"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the purpose of trace hashing in an audit workflow?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].options[1]",
          "text": "To replace structured test assertions"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Which sequence represents a valid evidence chain?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "Reproduce -> trace -> impact -> fix -> verify"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[1]",
          "text": "Fix -> reproduce -> trace -> release"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Accepting any PDA-like prefix"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Trusting client-provided bump values"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Deterministic re-derivation closes spoofable PDA substitution paths."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Because most exploitable bugs only appear under malformed or adversarial input"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Because traces are optional without them"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[0]",
          "text": "Compute drained lamports from recipient before/after."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[1]",
          "text": "Include deterministic field ordering in the JSON output."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[2]",
          "text": "The explanation should mention missing signer/owner validation."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].hints[2]",
          "text": "Keep output key order stable."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[1]",
          "text": "Use fixedBlockedExploit to set blocked status."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[2]",
          "text": "Return error code only when blocked is true."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].options[1]",
          "text": "They are interchangeable labels"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Good reports separate damage potential from exploit feasibility."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which recommendation is most actionable?"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[0]",
          "text": "Return stable, minimal checkpoint metadata."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[2]",
          "text": "Preserve scenarioIds order as provided."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why generate an offline deterministic launch pack before devnet/mainnet actions?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should supply checks use integer math instead of floating-point UI values?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "To avoid rounding drift in launch invariants"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Because decimals are always zero"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the primary role of freeze authority?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[0]",
          "text": "It can materially change effective fee behavior across transfer sizes"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "It is ignored once mint is initialized"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is a core risk of permanent delegate configuration?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].hints[2]",
          "text": "Keep output key order stable so checkpoint tests are reproducible."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].hints[1]",
          "text": "Append extension steps in deterministic order so plan labels are stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[0]",
          "text": "Transfer fee formula: fee = min(maxFee, floor(amount * feeBps / 10000))."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[2]",
          "text": "Fail when distributed amount exceeds initial supply."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is parameter closure required before execution?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Single-source configuration prevents mismatched launch behavior."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the purpose of hard stop launch criteria?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "To halt execution when invariants or authority assumptions fail"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Hard stop rules prevent progressing through unsafe operational states."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[0]",
          "text": "Keep checkpoint JSON key ordering fixed so output is stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[2]",
          "text": "Include determinism metadata (fixtures hash + encoding version) in the final object."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[0]",
          "text": "Add validation before returning the formatted string."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[1]",
          "text": "instructionCount should be treated as a number but returned as text."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].content",
          "text": "# Write a Counter Program Bankrun Test Implement a helper that returns the expected counter value after a sequence of increment operations. This mirrors a deterministic assertion you would use in a Bankrun test. Return t..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[0]",
          "text": "Use Array.reduce to sum increments."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[2]",
          "text": "Convert final number to string before returning."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the primary source of event data on Solana?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Explicit event topics like EVM"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is idempotency important in indexing?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "To prevent duplicate events during replays or forks"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "To improve RPC response times"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "As little-endian u64, then divided by 10^decimals"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[1].note",
          "text": "Inner CPI call at depth 2"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Success bubbles up from inner to outer"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[0]",
          "text": "Parse log entries to identify event types"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[1]",
          "text": "Extract fields using regex patterns"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It provides stable ordering during concurrent writes"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Cursor-based pagination handles concurrent writes without missing or duplicating entries."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What enables indexer recovery after crashes?"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Periodic checkpointing of last processed position"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Re-indexing from genesis on every start"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Caching all data in memory"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Checkpoints allow indexers to resume from the last known good position."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].hints[3]",
          "text": "Include metadata like timestamps"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the purpose of SPL Memo in payments?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What should never be included in a memo?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Memos are public on-chain; sensitive data should be hashed or kept off-chain."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[0]",
          "text": "Use base58 alphabet to validate the recipient address format."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[2]",
          "text": "Generate an idempotency key if not provided in the input."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].hints[2]",
          "text": "Key order matters: SOL transfer needs [from, to], SPL transfer needs [source, mint, dest, owner]."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Different key orders produce different signatures"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Canonicalization ensures consistent serialization so signatures match regardless of object construction order."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Initial state after intent creation"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Payment complete, generate receipt"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[0]",
          "text": "HMAC-SHA256: H(key, message) = SHA256((key XOR outer_pad) || SHA256((key XOR inner_pad) || message))"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[1]",
          "text": "Use constant-time comparison to prevent timing attacks on signature verification."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[2]",
          "text": "Verify the timestamp is recent (within 5 minutes) to prevent replay attacks."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a Merkle root commit to?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The tree depth only"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[0]",
          "text": "Start by validating the leaf index is within bounds."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[1]",
          "text": "At each level, find the sibling node (left or right of current)."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[3]",
          "text": "Traverse up to the root, collecting all updated node hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[4]",
          "text": "Use deterministic ordering: left hash comes before right hash."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].prompt",
          "text": "What determines concatenation order during verification?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[0]",
          "text": "The leaf index bits at each level"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[1]",
          "text": "The size of the sibling hashes"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[2]",
          "text": "The tree root hash"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].explanation",
          "text": "Each bit of the leaf index determines if the current hash goes left or right in the concatenation."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[1].explanation",
          "text": "log2(1024) = 10, so proofs contain 10 sibling hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[0]",
          "text": "To generate a proof, collect the sibling hash at each level from leaf to root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[1]",
          "text": "The sibling is at index+1 if current is left, index-1 if current is right."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[3]",
          "text": "Use the same ordering (left || right) when combining hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[4]",
          "text": "The proof is valid if the recomputed root matches the stored root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do old proofs fail after tree updates?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "The root changes when leaves are added/modified"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "The proof format changes"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "The leaf hashes are encrypted"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Adding leaves changes parent hashes up to the root, invalidating previous proofs."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "How can metadata attacks be prevented?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Hash verification against leaf commitments"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Using shorter metadata URIs"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Verifying metadata hashes ensures the off-chain data matches the on-chain commitment."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[0]",
          "text": "Validate the mint request has all required fields (leafIndex, nftId, owner)."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[2]",
          "text": "Insert the leaf by computing hashes up to the root, collecting sibling hashes as proof."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What determines voting power in most DAOs?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Token balance at snapshot block"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Voting power is typically proportional to token holdings at a specific snapshot time."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Anyone can trigger execution"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].content",
          "text": "# Challenge: Implement quorum/voting state machine Build a deterministic voting system: - Calculate vote weights from token balances - Check quorum requirements - Determine pass/fail based on thresholds - Handle abstenti..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[1]",
          "text": "Check if totalVoteWeight >= quorumThreshold to determine quorumMet."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[2]",
          "text": "Calculate support percentage as forWeight / (forWeight + againstWeight) when there are non-abstain votes."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does 2-of-3 multisig mean?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].options[0]",
          "text": "2 signatures required from 3 possible signers"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why track approvals on-chain?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[1]",
          "text": "Process actions in order - each action updates the signer's status."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[2]",
          "text": "Track the cumulative approved weight to compare against threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[3]",
          "text": "A proposal is 'approved' when approvedWeight >= threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[4]",
          "text": "A proposal is 'rejected' when no pending signers remain but threshold is not met."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "What is a replay attack in multisig systems?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Sending duplicate approval requests"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].hints[0]",
          "text": "First validate the proposal status is 'approved'."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The network automatically extends the limit"
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].hints[2]",
          "text": "Each byte of data adds 10 compute units."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Lower fees, higher throughput"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[0]",
          "text": "Sort fields by size (largest first) to minimize padding gaps."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[1]",
          "text": "Consider if u64 fields can be reduced to u32 based on maxValue."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[2]",
          "text": "Boolean flags can be packed into a single byte as bit flags."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[3]",
          "text": "Calculate bytes saved as originalSize - optimizedSize."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of setComputeUnitPrice?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Enable additional program features"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why request specific compute unit limits?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "Optimizing without profiling or evidence of need"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Premature optimization wastes effort on theoretical rather than measured bottlenecks."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[0]",
          "text": "Compute savings by subtracting 'after' from 'before' metrics."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[1]",
          "text": "Use approximate conversion: 1 SOL = $20, 1 SOL = 1,000,000,000 lamports."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why must native SOL be wrapped before swapping?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Native SOL cannot be transferred on Solana"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Solana automatically creates the ATA"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The tokens are sent to the system program"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is 50 basis points of slippage on a 1,000,000 output?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why should minOutAmount use BigInt instead of floating point?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Floating point introduces rounding errors in token amounts"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "BigInt is faster than floating point"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Single-hop direct route"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Total execution cost includes fees + impact"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[0]",
          "text": "Use BigInt arithmetic to avoid floating point errors when computing minOutAmount."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[1]",
          "text": "Slippage in basis points: minOut = outAmount - (outAmount * slippageBps / 10000)."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[3]",
          "text": "The priceImpactPct comes directly from the quote response."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].hints[0]",
          "text": "Define a TRANSITIONS map: each key is a state, each value maps event names to next states."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "They reduce the number of required signatures"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Retryable — get fresh blockhash"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[0]",
          "text": "Use BigInt to sum fee amounts across all route legs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[1]",
          "text": "Effective price = outAmount / inAmount, formatted to 9 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the main advantage of CLMMs over constant product AMMs?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Capital efficiency — LPs concentrate liquidity where trades happen"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "CLMMs allow LPs to allocate capital to specific price ranges, dramatically improving capital efficiency compared to spreading liquidity across all prices."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs use ticks to discretize the price space?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "To reduce the number of tokens in the pool"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs store sqrtPrice instead of price directly?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "It simplifies the AMM math — token amounts become linear in sqrtPrice"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "It uses less storage space on-chain"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Price within range, position is active"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "All SOL was sold as price rose through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Position reactivates when price returns to range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "All USDC was sold as price fell through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[0]",
          "text": "Price at a tick index = 1.0001^tickIndex. Use Math.pow(1.0001, tick)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[1]",
          "text": "Reverse conversion: tick = round(ln(price) / ln(1.0001))."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[2]",
          "text": "sqrtPriceX64 = BigInt(round(sqrt(price) * 2^64)) — Solana CLMM uses Q64.64 fixed-point."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[3]",
          "text": "Tick spacing alignment: floor(tick / spacing) * spacing."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[0]",
          "text": "Convert ticks to prices: lowerPrice = 1.0001^lowerTick, upperPrice = 1.0001^upperTick."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[2]",
          "text": "Fees only accrue when the position is in range. fee = floor(volumePerPeriod * feeRate)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[3]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[4]",
          "text": "Current status is based on the last price in the path relative to the range."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the main tradeoff of using a tight price range?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Lower fees but less impermanent loss"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "More tokens required to open the position"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When should an LP consider a full-range (all ticks) position?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "JavaScript Number cannot safely represent 128-bit integers"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "sqrtPriceX64 is a u128 value that can exceed JavaScript's Number.MAX_SAFE_INTEGER (2^53 - 1). BigInt provides arbitrary precision integer arithmetic."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "They are rejected by the program"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Floor division rounds toward negative infinity: floor(-100/64) = -2, so -100 aligns to -2 * 64 = -128. This is correct CLMM behavior."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[1]",
          "text": "Status is 'in-range' if lowerPrice <= currentPrice <= upperPrice."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[3]",
          "text": "IL formula: lpValue = sqrt(priceRatio) + sqrt(1/priceRatio); compare to holdValue = 2*sqrt(priceRatio)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[4]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimals."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a utilization ratio of 80% mean?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "80% of supplied assets are currently borrowed"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "80% of borrowers have been liquidated"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The pool has 80% of its maximum capacity"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Utilization = totalBorrowed / totalSupply. At 80%, four-fifths of all deposited assets are currently lent out to borrowers."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does the reserve factor affect supplier yield?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "It reduces supplier yield by skimming a percentage of borrow interest"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It increases supplier yield by adding protocol subsidies"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "It has no effect on supplier yield"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "The reserve factor takes a cut of borrow interest before distributing the rest to suppliers, reducing their effective APY."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What happens to borrow rates when utilization exceeds the kink?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "They increase steeply according to slope2"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "They remain constant at the kink rate"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "They decrease to attract more borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is the supply rate always lower than the borrow rate?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The protocol subsidizes borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Only 20% buffer remaining — consider adding collateral"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[0]",
          "text": "Utilization = totalBorrowed / totalSupply. Handle the zero-supply edge case."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[1]",
          "text": "Below kink: borrowRate = baseRate + (utilization/kink) * slope1."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[2]",
          "text": "Above kink: borrowRate = baseRate + slope1 + ((util - kink)/(1 - kink)) * slope2."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[3]",
          "text": "Supply rate = borrowRate * utilization * (1 - reserveFactor)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[1]",
          "text": "Effective threshold = weighted average of liquidationThreshold by collateral value."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[2]",
          "text": "Health factor = (collateralValue * effectiveThreshold) / borrowValue."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[3]",
          "text": "Max additional borrow = max(0, collateralValue * threshold - currentBorrow)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of the liquidation bonus?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It incentivizes liquidators to repay debt by offering collateral at a discount"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When does bad debt occur in a lending protocol?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "When collateral value is insufficient to cover outstanding debt after liquidation"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "When the reserve factor is set too high"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "When utilization drops below the kink"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "To be conservative — using (price - confidence) prevents over-valuing collateral during uncertainty"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Confidence intervals make prices more accurate"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should a protocol do when all oracle feeds are stale?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "Use the last known price regardless of age"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Estimate the price from on-chain DEX data"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[2]",
          "text": "Track the worst health factor across all scenarios."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[3]",
          "text": "Count how many scenarios result in isLiquidatable: true."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do perpetual futures protocols use a mark price instead of the last-traded price?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Mark price smooths out manipulation by incorporating oracle data, preventing artificial liquidations"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Mark price is cheaper to compute on-chain"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Last-traded price is not available on Solana"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Mark price incorporates the oracle price as a stability anchor. Using last-traded price alone would allow a single large trade to trigger cascading liquidations through price manipulation."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Weighted average: (8 * 20 + 2 * 30) / 10 = (160 + 60) / 10 = $22.00. The entry price shifts toward the new fill price proportional to the additional size."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "When the perpetual mark price is above the oracle (spot) price, who pays funding?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Longs pay shorts — the positive premium makes long positions expensive to hold"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Both sides pay the protocol a fee"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "A 10 SOL-PERP position at $25 entry faces a 0.01% funding rate. What is the per-period payment?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "text": "Funding payment = size * entryPrice * rate = 10 * 25 * 0.0001 = $0.025 per funding interval."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Position snapshot at current mark price"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Long PnL = size * (mark - entry)"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Positive rate: longs pay funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "True return includes funding drag"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[0]",
          "text": "Long PnL = size * (markPrice - entryPrice). Short PnL = size * (entryPrice - markPrice)."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[1]",
          "text": "Notional value = size * markPrice — represents the total position value."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[2]",
          "text": "ROE (return on equity) = unrealizedPnL / margin * 100."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[0]",
          "text": "Funding payment per period = size * entryPrice * fundingRate."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[1]",
          "text": "Longs pay when rate is positive (totalFunding -= payment). Shorts receive."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[2]",
          "text": "Average funding rate = sum(rates) / count."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[3]",
          "text": "Net margin impact = (totalFunding / margin) * 100, as a percentage."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is the maintenance margin rate set above zero?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "What causes a cascading liquidation spiral?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Forced position closes push the price further, triggering more liquidations in a feedback loop"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Too many traders opening positions at the same time"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Oracle prices updating too slowly"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "text": "When liquidation engines close positions by selling into the market, the selling pressure moves the price further against remaining positions, triggering their liquidations too — a self-reinforcing feedback loop."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should position size always be stored as a positive number?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Positive numbers use less storage space"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "A long position has a positive funding rate of 0.01%. What happens to the trader's balance?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The balance decreases — longs pay when the funding rate is positive"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The balance increases — longs receive positive funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Nothing — funding only affects shorts"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Positive funding rate means the perp is trading above spot. Longs pay shorts to discourage the long-heavy imbalance. The long trader's effective margin decreases by the funding payment amount."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[0]",
          "text": "Effective margin = initial margin + unrealized PnL + funding payments."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[1]",
          "text": "Margin ratio = effectiveMargin / notionalValue."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[3]",
          "text": "Generate alerts based on margin ratio vs maintenance margin rate thresholds."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[4]",
          "text": "Sort alerts by severity: CRITICAL > WARNING > INFO."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How is the priority fee calculated in lamports?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "The CU price is denominated in micro-lamports per CU. Dividing by 1,000,000 converts micro-lamports to lamports. The ceiling function ensures rounding up to the nearest lamport."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is setting the CU limit to exactly the simulated value risky?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The runtime does not accept exact values"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Simulation always underreports CU usage by 50%"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Low compute = minimal priority fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Higher compute increases priority cost proportionally"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "High CU + high priority = significant fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[1]",
          "text": "Cap compute unit limit at 1,400,000 (Solana max)."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[2]",
          "text": "Priority fee = ceil(computeUnitLimit * computeUnitPrice / 1_000_000) in lamports."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[3]",
          "text": "Total fee = base fee (5000 lamports) + priority fee."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].hints[3]",
          "text": "Recommend 'legacy' if fits without LUT, 'use-existing-lut' if LUT helps enough, 'create-new-lut' if still too large."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "When the blockhash has expired or pool state has changed"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Whenever any error occurs"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Only when the user manually clicks retry"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add random jitter to retry delays?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To make the delay shorter on average"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Jitter is required by the Solana protocol"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Without jitter, all clients using the same backoff formula would retry simultaneously, creating thundering herd problems on the RPC infrastructure."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Slippage exceeded -> actionable message"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Balance error -> show exact shortfall"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[1]",
          "text": "Fee estimates: low = 100 microlamports/CU, medium = 1000, high = 10000."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[2]",
          "text": "Retry policy: 3 retries, 500ms base delay, 2x backoff, always refresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[3]",
          "text": "Use the same CU calculation: ceil(totalCU * 1.1) capped at 1,400,000."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Foreground services maintaining a session channel"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Deep links passed between applications"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Shared local storage between apps"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "iOS suspends app execution on background transitions, preventing persistent channels"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "iOS uses a different blockchain protocol"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "iOS does not allow arbitrary background processes or persistent inter-app communication. When the user switches apps, the dApp's execution context is suspended."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Detect available connection methods (MWA, deep links, QR)"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "Capability detection ensures you only present connection methods that are actually available on the user's device."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Request sent via MWA session or deep link"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "User decision - timing is unpredictable"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[3]",
          "text": "Generate a requestId from type + payload prefix if not provided."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[0]",
          "text": "Process actions sequentially: each action modifies the session state."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[3]",
          "text": "Expire check clears session if current time >= expiresAt."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "As raw lamports or smallest unit values"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Raw simulation logs from the RPC response"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].title",
          "text": "Retry State Machine Flow"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "User action triggers request construction"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[0]",
          "text": "Count requests by status: 'signed' = success, 'rejected'/'timeout'/'error' = failure."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[2]",
          "text": "Session duration = sessionEnd - sessionStart in seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "solana:<recipient> (single colon, no slashes)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "solana://<recipient> (double slashes like HTTP)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "pay:<recipient> (custom pay scheme)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "When the amount exceeds 100 SOL"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How does the reference parameter enable payment tracking?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "It creates a webhook that notifies the merchant"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What amount value represents 2.5 USDC in a Solana Pay URL?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "amount=2.5 (human-readable decimal)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Native SOL transfer — no spl-token parameter"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[0]",
          "text": "Solana Pay URL format: solana:<recipient>?amount=<amount>&spl-token=<mint>&reference=<ref>&label=<label>&message=<msg>"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[1]",
          "text": "Validate recipient: must be 32-44 characters of valid base58."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[2]",
          "text": "Amount must be a positive finite number."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[0]",
          "text": "Track state transitions: pending -> found -> confirmed -> finalized."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[1]",
          "text": "The 'found' event sets the signature. 'confirmation' increments the counter."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[2]",
          "text": "Timeout check expires the reference if still pending after expiryTimeout seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[3]",
          "text": "Record each state change in the history array."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Confirmed is never sufficient — always use finalized"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What should happen when the payment request expires?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Silently restart the polling loop"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Redirect the customer to a different payment method"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Exponential backoff recovers from transient failures"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Never auto-complete mismatched payments"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Track processed references to prevent double fulfillment"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[0]",
          "text": "Generate receiptId from the last 8 chars of reference + timestamp."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[1]",
          "text": "Reconstruct the Solana Pay URL from payment data."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[2]",
          "text": "Currency is 'SPL' if splToken is present, otherwise 'SOL'."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What should happen when auto-connect fails silently on page load?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Show the connect button without an error message"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Display an error toast telling the user to reconnect"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Auto-connect is a background optimization. If it fails, the user never initiated the action, so showing an error would be confusing. Simply display the default connect button."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why should you show skeleton UI during the connecting phase?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It makes the page load faster"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How do you reliably detect which Solana cluster an RPC endpoint is connected to?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What must happen to cached data when the network changes?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Only token balances need to be refreshed"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Cached data can be retained since addresses are the same across clusters"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "User clicks Connect, show loading state"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[0]",
          "text": "Define a TRANSITIONS map: each state maps event types to next states."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[2]",
          "text": "Error state stores the error message. Disconnected clears all session data."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[2]",
          "text": "DISCONNECT invalidates all non-'global' entries."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[3]",
          "text": "Track invalidation counts per event in the event log."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must cache keys include the network cluster?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "The Solana RPC protocol requires cluster identification"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What does the stale-while-revalidate pattern do when a cache entry is past its TTL?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Blocks until fresh data is fetched from the RPC"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Primary endpoint responding normally"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Latency spike detected, slot behind tip"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Automatic failover to healthy secondary"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Primary recovered, restoring as default"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[1]",
          "text": "Average connect time = total durationMs from CONNECTED events / count."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[2]",
          "text": "Cache hit rate = hits / (hits + misses) * 100."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[3]",
          "text": "RPC health = healthy checks / total checks * 100."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "signMessage does not produce valid Ed25519 signatures"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does SIWS prevent replay attacks?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "By requiring a unique, server-generated nonce that is consumed after verification"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must nonces be generated server-side rather than client-side?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Client-generated nonces allow attackers to reuse previously valid nonce-signature pairs"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Client-side random number generators are too slow"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What format must the domain field use?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Plain domain name without protocol prefix (e.g., example.com)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[0]",
          "text": "Domain should not include protocol (https://). Strip or reject it."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[2]",
          "text": "Address must be 32-44 characters (Solana base58 public key)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[3]",
          "text": "If no statement is provided, default to 'Sign in to <domain>'."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[1]",
          "text": "issuedAt must be <= currentTime (not in the future)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[2]",
          "text": "expirationTime (if present) must be > currentTime."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The dApp should invalidate the server-side session (treat it as logout)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Atomic SET NX ensures only one request can consume the nonce"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Replay blocked: nonce was already consumed"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[0]",
          "text": "Track used nonces in a map. If a nonce was already used, it's a replay attempt."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[2]",
          "text": "Use an address set to count unique addresses."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does a wide p90 vs p50 spread usually indicate?"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A volatile fee regime where a guard premium may be needed"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "Floor protects small estimates."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Large payload triggers heap recommendation."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[0].content",
          "text": "Implement a deterministic compute budget planner. No RPC calls; operate only on provided input data."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[0]",
          "text": "Use percentile targeting from sorted synthetic fee samples."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[1]",
          "text": "Apply volatility guard if p90 vs p50 spread exceeds policy threshold."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[2].hints[0]",
          "text": "Map risk score bands to processed/confirmed/finalized UX levels."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].hints[1]",
          "text": "Avoid timestamps or random IDs in output."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[4].hints[1]",
          "text": "Checkpoint report should avoid nondeterministic fields."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do users still expect atomic behavior in multi-tx flows?"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because protocols always guarantee it"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].title",
          "text": "Flow Graph Risk Walkthrough"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "No compensation path after swap failure."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Still verify idempotency on each step."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[0].hints[1]",
          "text": "Emit explicit edges from dependency relationships."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[1].hints[1]",
          "text": "Flag non-idempotent steps because retries can break all-or-nothing guarantees."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].content",
          "text": "Encode deterministic failure handling metadata, including compensation state."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].hints[0]",
          "text": "Generate deterministic idempotency keys from stable inputs."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[3].hints[0]",
          "text": "No real Jito calls. Build deterministic data structures only."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].content",
          "text": "Generate a stable markdown flow safety report checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[0]",
          "text": "Render a stable markdown report as the final checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[1]",
          "text": "Keep the PASS/FAIL status deterministic from issue count."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Slippage is user tolerance; impact is market footprint"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They are identical metrics"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Slippage is a user-configured bound, while impact reflects route liquidity response to trade size."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[1].hints[0]",
          "text": "Clamp recommended BPS to policy bounds."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[2].hints[0]",
          "text": "Teach difference: impact is market footprint, slippage is user tolerance."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[3].hints[0]",
          "text": "Map risk grades to deterministic banner copy."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[4].hints[1]",
          "text": "Do not include timestamps or random IDs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "It reduces RPC cost directly"
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[0].hints[1]",
          "text": "Sort by key so output is deterministic across runs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[1].hints[0]",
          "text": "Apply only confirmed-depth events to state."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[0]",
          "text": "Integrity checks must fail on negative balances."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[1]",
          "text": "Finalized keys must always be a subset of applied keys."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].title",
          "text": "RPC failures in real life: timeouts, 429s, stale nodes"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is slot lag important in endpoint scoring?"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Fast responses can still be wrong if the node is stale"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Slot lag is equivalent to timeout"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Latency alone cannot guarantee freshness of chain state."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Fast but less reliable under pressure."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].title",
          "text": "Explorer: retry/backoff simulator"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].title",
          "text": "RPC Multi-Provider Client Project Journey"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[0].hints[0]",
          "text": "Build a deterministic retry schedule including the first attempt."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[1].hints[1]",
          "text": "Tie-break deterministically by endpoint ID."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[2].hints[1]",
          "text": "Use tighter TTL when node lag grows."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].title",
          "text": "Checkpoint: RPC health report export"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].hints[1]",
          "text": "Ensure field order is stable in JSON output."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Alignment inserts padding bytes"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "RPC forces 8-byte packets"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "u64 alignment usually forces padding after smaller fields."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "u32 length + UTF-8 bytes + u8 field"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[0].hints[1]",
          "text": "Struct total size should be aligned to max field alignment."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].title",
          "text": "Challenge: implement borshEncode/borshDecode helpers"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].hints[0]",
          "text": "Borsh strings are length-prefixed little-endian u32 + UTF-8 bytes."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].title",
          "text": "Challenge: zero-copy vs Borsh tradeoff model"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[0]",
          "text": "Model tradeoffs deterministically: read speed vs schema flexibility."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[1]",
          "text": "Recommendation should be pure function of inputs."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[3].hints[0]",
          "text": "Validate byte length before field parsing."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].title",
          "text": "Checkpoint: stable layout report"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should export stable JSON + markdown."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].title",
          "text": "Error taxonomy: recoverable vs fatal"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why are typed error codes preferred over free-form strings?"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable machine-readable semantics"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "They reduce compile time"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].title",
          "text": "Explorer: invariant decision tree"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].title",
          "text": "Invariant Guard Library Project Journey"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].title",
          "text": "Challenge: implement InvariantError + ensure helpers"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].hints[0]",
          "text": "Return typed error payloads, not raw strings."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[1].title",
          "text": "Challenge: implement deterministic EvidenceChain"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].title",
          "text": "Challenge: deterministic invariant case runner"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].hints[0]",
          "text": "Property-ish deterministic tests can still run as fixed case sets."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].title",
          "text": "Challenge: implement formatReport() stable markdown"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].content",
          "text": "Format a deterministic markdown evidence report."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].title",
          "text": "Checkpoint: invariant audit report"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].content",
          "text": "Export deterministic invariant audit checkpoint artifacts."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should capture deterministic summary fields only."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[1]",
          "text": "No wall-clock timestamps in exported artifact."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why use deterministic cost models before microbenchmarks?"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable regression signals in CI"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They replace all profiling"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Deterministic models make relative regressions easy to catch early."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].title",
          "text": "Data structures: Vec, HashMap, BTreeMap tradeoffs"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].title",
          "text": "Explorer: cost model sandbox"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].title",
          "text": "Compute Budget Profiler (Sim)"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].title",
          "text": "Challenge: implement CostModel::estimate()"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].content",
          "text": "Estimate deterministic operation costs from fixed weighting rules."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].title",
          "text": "Challenge: optimize function metrics"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[0]",
          "text": "Treat optimization as deterministic metric diffs, not runtime benchmarking."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[1]",
          "text": "Clamp reduced metrics at zero."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].title",
          "text": "Challenge: model serialization overhead"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[0]",
          "text": "Show why repeated encode/decode loops are expensive."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[1]",
          "text": "Keep the model deterministic by counting bytes instead of timing."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].content",
          "text": "Generate stable optimization suggestions from deterministic metrics."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[0]",
          "text": "Output suggestions as a stable, sorted list."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[1]",
          "text": "Use threshold-based recommendations to avoid noisy advice."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].title",
          "text": "Checkpoint: stable perf report"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].hints[1]",
          "text": "Use deterministic percentage rounding."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].title",
          "text": "Async fundamentals: futures, tasks, channels"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].title",
          "text": "Reorg-safe Async Pipeline Project Journey"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].title",
          "text": "Challenge: implement Pipeline::run()"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].hints[1]",
          "text": "No real timers; simulate progression by decrementing remaining ticks."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[1].title",
          "text": "Challenge: implement RetryPolicy schedule"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].title",
          "text": "Challenge: idempotency key dedupe"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].content",
          "text": "Deduplicate replay events by deterministic idempotency keys."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].hints[0]",
          "text": "Use idempotency keys to collapse duplicate replay events."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[3].content",
          "text": "Build deterministic snapshot state from simulated event streams."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].title",
          "text": "Checkpoint: pipeline run report"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint output should mirror deterministic pipeline run artifacts."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "It verifies expansion matches policy intent"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].title",
          "text": "Safety through codegen: constraint checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].title",
          "text": "Explorer: constraint builder to generated checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].content",
          "text": "Parse mini-DSL constraints into deterministic AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].hints[0]",
          "text": "Parse mini DSL lines into typed AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].content",
          "text": "Generate stable pseudo-code from parsed constraint AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[0]",
          "text": "Generate stable pseudo-code output from AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[1]",
          "text": "One deterministic line per constraint node."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].title",
          "text": "Challenge: deterministic golden-file checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].content",
          "text": "Compare generated check output against deterministic golden strings."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[0]",
          "text": "Golden tests compare generated output strings exactly."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[1]",
          "text": "Keep check output deterministic to make golden tests meaningful."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].content",
          "text": "Execute generated constraints on deterministic sample input."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].hints[1]",
          "text": "Return deterministic failure reasons."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].title",
          "text": "Checkpoint: generated safety report"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].content",
          "text": "Export deterministic markdown safety report from generated checks."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].hints[0]",
          "text": "Render a deterministic markdown report from generated check results."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].title",
          "text": "Upgrade authority lifecycle in Anchor programs"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Compare approved build hash to expected programdata hash policy input"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Rely on signer memory without written report"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is release communication part of upgrade safety?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Because Anchor automatically writes support tickets"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because all upgrades are backward compatible"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].title",
          "text": "Explorer: upgrade risk matrix"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].title",
          "text": "Challenge: implement migration step planner"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].hints[1]",
          "text": "requiresMigration should be true only when toVersion > fromVersion."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].title",
          "text": "Challenge: implement upgrade safety gate checks"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[1]",
          "text": "Return issueCount plus ordered issue code array."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[2]",
          "text": "Keep order stable to make report diffs deterministic."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What should happen first when rollback trigger thresholds are hit?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Continue migration batches to avoid confusion"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Delete all historical reports"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Trigger conditions should map to immediate deterministic response actions."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add deterministic fixtures after an incident?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "To prove policy changes prevent the same failure path"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To increase deploy complexity without benefit"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "To replace all code reviews"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].title",
          "text": "Challenge: build stable upgrade markdown summary"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].hints[2]",
          "text": "Return plain markdown string without trailing spaces."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].title",
          "text": "Checkpoint: upgrade readiness artifact"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[0]",
          "text": "ready is true only when issueCount equals 0."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[1]",
          "text": "Return stable keys in releaseTag, ready, migrationBatches order."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[2]",
          "text": "Checkpoint output should be machine-readable deterministic JSON."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[0]",
          "text": "Use match on the BackoffStrategy enum to handle each case"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[2]",
          "text": "should_retry simply checks if attempt is less than max_attempts"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].content",
          "text": "Implement a deadline management system to enforce time limits on operations."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].hints[0]",
          "text": "Store the absolute expiration timestamp in the Deadline struct"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].content",
          "text": "Implement a fallback mechanism that provides alternative execution paths when primary operations fail."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].hints[1]",
          "text": "Only call fallback if primary returns None"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].hints[1]",
          "text": "record_success should reset everything to Closed state"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[0]",
          "text": "Always refill before checking if consumption is possible"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[2]",
          "text": "Use min() to ensure tokens don't exceed capacity"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].content",
          "text": "Implement an error classification system to determine if errors are retryable."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[1]",
          "text": "should_retry can use matches! macro or match on classify result"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[2]",
          "text": "batch_classify can use iter().map().collect() pattern"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].title",
          "text": "Test Assertion Framework Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].hints[1]",
          "text": "Use format! to create descriptive error messages"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[2].hints[0]",
          "text": "Use vec![0; size] to create zero-filled data of specified size"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].title",
          "text": "Test Scenario Builder Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].hints[1]",
          "text": "Push strings into vectors (use to_string() to convert &str)"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].title",
          "text": "Fuzz Input Generator Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].hints[1]",
          "text": "Generate bytes by taking random % 256"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[2].content",
          "text": "Implement a property verifier that checks invariants hold across operations."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].title",
          "text": "Boundary Value Analyzer Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[1]",
          "text": "Typical value is the midpoint of the range"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[2]",
          "text": "Return all 7 boundary values as test cases"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].content",
          "text": "Implement a compute unit counter to estimate operation costs."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[0]",
          "text": "Loop cost is overhead plus iterations times per-iteration cost"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[2]",
          "text": "Apply safety margin by multiplying budget by the percentage"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].title",
          "text": "Data Structure Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[0]",
          "text": "Use copy_from_slice to write data efficiently"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[1]",
          "text": "Track the highest written position as 'used'"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[2]",
          "text": "Always check bounds before read/write operations"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].title",
          "text": "Batch Operation Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].content",
          "text": "Optimize batch operations to minimize compute units."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[0]",
          "text": "Use to_le_bytes() to convert integers to bytes"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[1]",
          "text": "Use from_le_bytes() to convert bytes back to integers"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[2]",
          "text": "Alignment formula: if remainder, add (alignment - remainder)"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[0]",
          "text": "Annual rent is data size times lamports per byte per year"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[1]",
          "text": "Exemption threshold is annual rent times threshold years"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[2]",
          "text": "Check if balance is greater than or equal to minimum"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].title",
          "text": "Zero-Copy Deserializer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[0]",
          "text": "Use copy_from_slice to read fixed-size data into stack arrays"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[2]",
          "text": "Always advance offset after reading"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].title",
          "text": "Vesting Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[0]",
          "text": "Use saturating_sub to avoid underflow when calculating elapsed time"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[2]",
          "text": "Releasable is simply vested minus already released"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].title",
          "text": "Token Allocation Distributor Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[0]",
          "text": "Use iter().map().sum() to calculate total percentage"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[2]",
          "text": "Use find() to locate allocation by recipient"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].title",
          "text": "Release Schedule Generator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].hints[0]",
          "text": "Divide duration by intervals to get interval duration"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[0]",
          "text": "Use compound interest formula: A = P(1 + r/n)^(nt)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[1]",
          "text": "Convert basis points to decimal by dividing by 10000"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[0]",
          "text": "If delegated_to is Some, voting power is 0 (they gave it away)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[1]",
          "text": "Use filter to find voters who delegated to a specific address"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[2]",
          "text": "Sum staked amounts to calculate delegated power"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].title",
          "text": "Proposal Threshold Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].hints[0]",
          "text": "Convert basis points to amount: (supply * bps) / 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[1].title",
          "text": "Constant Product AMM Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].title",
          "text": "Liquidity Provider Calculator Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].hints[2]",
          "text": "Rewards are proportional to LP token holdings"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].content",
          "text": "Implement a time-weighted average price oracle."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[0]",
          "text": "Use retain() to filter out old observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[1]",
          "text": "Calculate duration between consecutive observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[2]",
          "text": "TWAP is weighted sum divided by total duration"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[0]",
          "text": "Max borrow is collateral value times LTV ratio"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[1]",
          "text": "Position is liquidatable when borrowed exceeds threshold * value"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[2]",
          "text": "Health factor shows how close to liquidation (higher is safer)"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].title",
          "text": "Interest Rate Model Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].content",
          "text": "Implement a utilization-based interest rate model."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].hints[0]",
          "text": "Utilization is borrowed divided by supplied"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].content",
          "text": "Implement flash loan validation logic."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[0]",
          "text": "Fee is amount times fee_bps divided by 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[1]",
          "text": "Total repay is principal plus fee"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[1].title",
          "text": "NFT Metadata Parser Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[2].hints[2]",
          "text": "Only verify if collection is complete"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].title",
          "text": "Attribute Rarity Calculator Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].content",
          "text": "Calculate NFT attribute rarity scores."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[0]",
          "text": "Rarity percentage is (count / total) * 100"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[1]",
          "text": "Rarity score is inverse of rarity (1 / rarity)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[1].hints[2]",
          "text": "Use any() to check if address is in restrictions list"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].title",
          "text": "Dynamic NFT Updater Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].content",
          "text": "Implement dynamic NFT attributes that can evolve over time."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[1]",
          "text": "Update last_updated timestamp after successful update"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[2]",
          "text": "Time until update is max(0, next_update - current_time)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[3].hints[2]",
          "text": "Filter equipped items by matching type in items list"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[1].hints[2]",
          "text": "Privilege extension: if caller is signer, child can sign too"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[0]",
          "text": "Convert string seeds to bytes using as_bytes()"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[1]",
          "text": "Simulate PDA finding by trying different bump values"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[0]",
          "text": "Use HashMap insert to register handlers"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[1]",
          "text": "Route by looking up instruction_type in handlers map"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].title",
          "text": "Atomic Swap Orchestrator Challenge"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].content",
          "text": "Implement an atomic swap across multiple programs."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].hints[1]",
          "text": "Atomicity requires output_token of step N equals input_token of step N+1"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[2].content",
          "text": "Validate state consistency across multiple CPI calls."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[0]",
          "text": "Push permission into vector to register"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[2]",
          "text": "Use retain() to remove caller from allowed list"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].title",
          "text": "Arbitrage Opportunity Detector Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].content",
          "text": "Detect arbitrage opportunities across DEXes."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[1]",
          "text": "Profit percent is (sell - buy) / buy * 100"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[2]",
          "text": "Use max_by to find best opportunity"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].title",
          "text": "Liquidation Opportunity Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[0]",
          "text": "Position is liquidatable when borrowed > threshold * collateral_value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[2]",
          "text": "Liquidation profit is bonus percentage of collateral value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].title",
          "text": "Priority Fee Calculator Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[0]",
          "text": "Urgency factor scales the base fee"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[1]",
          "text": "Execution probability decreases as more fees are higher"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[0]",
          "text": "Tip is percentage of total profit"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[1]",
          "text": "Bundle is profitable if profit exceeds tip"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].title",
          "text": "Multi-Hop Arbitrage Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].content",
          "text": "Find multi-hop arbitrage paths across token pairs."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[1]",
          "text": "Two-hop arbitrage goes A -> B -> A through different pools"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[2]",
          "text": "Profit is final output minus initial input"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].title",
          "text": "MEV Simulation Engine Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].content",
          "text": "Simulate MEV extraction to estimate profitability."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].hints[2]",
          "text": "Expected value weights profit by success probability"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[0]",
          "text": "Push config into vector to add"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[1]",
          "text": "Use find() to locate config by environment name"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[0]",
          "text": "Compare binary length against MAX_PROGRAM_SIZE"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[2]",
          "text": "Compression ratio shows percentage size reduction"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].title",
          "text": "Upgrade Authority Manager Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[0]",
          "text": "Push metadata into vector to register"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[1]",
          "text": "can_upgrade checks if authority matches stored authority"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[0]",
          "text": "Track seen stages to enforce ordering constraints"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[2]",
          "text": "Can skip build/test if only documentation files changed"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].title",
          "text": "Version Compatibility Checker Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[1]",
          "text": "Compatibility requires same major, actual >= required"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[2]",
          "text": "Use min_by to find smallest compatible version"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].title",
          "text": "Cross-Chain Messaging Architecture"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].content",
          "text": "Implement VAA (Verified Action Approval) signature verification."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[0]",
          "text": "Check signatures length against MIN_SIGNERS first"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[2]",
          "text": "Quorum is 2/3 of total guardians rounded up"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[0]",
          "text": "Increment sequence before creating message"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[2]",
          "text": "Verify message sequence is within emitted range"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[0]",
          "text": "Use contains() to check if sequence was processed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[1]",
          "text": "Return error if trying to mark already-processed sequence"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[2]",
          "text": "Use retain() to filter out old sequences"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[1].hints[1]",
          "text": "Verify requester matches owner before unlocking"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].title",
          "text": "Wrapped Token Mint Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].hints[1]",
          "text": "Check bounds before minting/burning"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].title",
          "text": "Bridge Rate Limiter Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[0]",
          "text": "Reset window before checking if duration passed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[1]",
          "text": "Only consume if total won't exceed max"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[1].hints[1]",
          "text": "Confidence ratio: conf / |price| < threshold"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[0]",
          "text": "Multiplier formula: smoothing / (period + 1)"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[1]",
          "text": "First EMA equals first price"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[2]",
          "text": "Subsequent EMAs use weighted average formula"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].title",
          "text": "Median Price Calculator Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].content",
          "text": "Calculate median price from multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].hints[2]",
          "text": "Use retain() to filter out outliers"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].content",
          "text": "Implement consensus checking across multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[0]",
          "text": "Check minimum sources first"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[2]",
          "text": "Agreement percent is (agreeing / total) * 100"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].title",
          "text": "Fallback Oracle Manager Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[0]",
          "text": "Store sources in priority order"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[1]",
          "text": "current_source index tracks which is active"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[2]",
          "text": "Fallback if index > 0 (not primary)"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].title",
          "text": "Proposal Lifecycle Manager Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].hints[1]",
          "text": "Voting active only during time window in Active state"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[0]",
          "text": "Delegated voters have 0 voting power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[1]",
          "text": "Quadratic voting uses square root of balance"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[2]",
          "text": "Apply cap after calculating base power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].content",
          "text": "Manage vote delegation between DAO members."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].hints[0]",
          "text": "Remove existing delegation before creating new one"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].title",
          "text": "Treasury Spending Limit Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].hints[1]",
          "text": "Reset period if duration has passed"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[2].hints[2]",
          "text": "Remove operation from list to cancel"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].title",
          "text": "Automated Action Trigger Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[1]",
          "text": "Match on condition type to evaluate"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[2]",
          "text": "Only return non-triggered actions that meet conditions"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[1].hints[1]",
          "text": "Turn complete when all players submitted"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].title",
          "text": "Game State Compressor Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[0]",
          "text": "Use bit shifting to pack x in high 4 bits, y in low 4 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[2]",
          "text": "Health stored as percentage (0-100) fits in 7 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].title",
          "text": "Player Progression Tracker Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[0]",
          "text": "XP formula: base * multiplier^(level-1)"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[1]",
          "text": "Keep leveling up while XP exceeds requirement"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[2]",
          "text": "Check contains() before adding achievement"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[1].hints[1]",
          "text": "Verify by recomputing hash from reveal"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[2].hints[2]",
          "text": "4d6 drop lowest: roll 4, sum all, subtract minimum"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[1]",
          "text": "Generate random number in range [0, total)"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[2]",
          "text": "Find item where cumulative weight exceeds roll"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].title",
          "text": "Storage Cost Estimator Challenge"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].content",
          "text": "Estimate Arweave storage costs based on data size."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].hints[0]",
          "text": "Calculate winston cost then convert to USD"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[3].hints[0]",
          "text": "Sort items by priority before bundling"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[0]",
          "text": "Validate tx_id length before adding"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[1]",
          "text": "Resolve in order: exact, index, fallback"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[0]",
          "text": "Push item to vector to add"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[1]",
          "text": "Filter items where any tag matches"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].title",
          "text": "Staking Rewards Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].hints[0]",
          "text": "Apply commission as (1 - commission) multiplier"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[2].hints[0]",
          "text": "Weight factors: commission 40%, uptime 40%, skip rate 20%"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[0]",
          "text": "Target is total divided by count, clamped to min/max"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[2]",
          "text": "Check all allocations within tolerance percentage"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[1].hints[0]",
          "text": "Sum all cost components"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[2].title",
          "text": "Epoch Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[0]",
          "text": "Only inactive stakes can be activated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[1]",
          "text": "Only active stakes can be deactivated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[2]",
          "text": "Fully active after warmup_epochs from activation"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[1].hints[0]",
          "text": "Use contains() to check ownership"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[2].hints[1]",
          "text": "Check guardian status before approving"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].title",
          "text": "Session Key Manager Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[0]",
          "text": "Valid if current time before expiration"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[2]",
          "text": "Remaining is max minus used"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].title",
          "text": "Spending Limit Enforcer Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[0]",
          "text": "Reset counters before checking"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[1]",
          "text": "Check all three limits: per-tx, daily, weekly"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[2]",
          "text": "Reset daily if new day, weekly if 7+ days passed"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[2].hints[1]",
          "text": "Check contains() before adding"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[3].title",
          "text": "Time Lock Enforcer Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[0]",
          "text": "Try bumps from 255 down to 0"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[2]",
          "text": "Check if derived address matches expected"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[2].hints[2]",
          "text": "Collect into Vec<Vec<u8>>"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[3].hints[1]",
          "text": "Signer seeds include all seeds plus bump"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].title",
          "text": "Nested PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].content",
          "text": "Generate PDAs derived from other PDA addresses."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].hints[0]",
          "text": "Include parent address in child seeds"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].title",
          "text": "Counter PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].content",
          "text": "Generate unique PDAs using incrementing counters."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[0]",
          "text": "Increment counter after each generation"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[2]",
          "text": "Batch generation calls generate_next multiple times"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].title",
          "text": "PDA Collision Detector Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[0]",
          "text": "Check if seeds match any existing entry"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[1]",
          "text": "Return error if collision detected"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[1]",
          "text": "Compound inflation year over year"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[2]",
          "text": "APY is inflation divided by staked percentage"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].title",
          "text": "Fee Burn Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].hints[1]",
          "text": "Burn is percentage of total fee"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].title",
          "text": "Rent Economics Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[0]",
          "text": "Annual rent is bytes times rate"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[1]",
          "text": "Exemption is annual times threshold years"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[2]",
          "text": "Rent due is annual times period"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].title",
          "text": "Supply Flow Tracker Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[0]",
          "text": "Total excludes burned tokens"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[1]",
          "text": "Apply flow by subtracting from source, adding to destination"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[2]",
          "text": "Net flow is inflow minus outflow"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].title",
          "text": "Vesting Schedule Impact Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].content",
          "text": "Calculate token unlock impact on supply."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[0]",
          "text": "0 before cliff, linear after, full at end"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[1]",
          "text": "Monthly unlock is difference between consecutive months"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[2]",
          "text": "Check multiple months to find peak"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].title",
          "text": "Protocol Sustainability Score Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[0]",
          "text": "Net issuance is inflation minus burn"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[1]",
          "text": "Burn ratio is burn divided by inflation"
        }
      ],
      "englishLikeMatches": [
        {
          "path": "courses.solana-fundamentals.description",
          "englishWordCount": 14,
          "excerpt": "Introduccion practica para dominar los fundamentos de Solana con modelos mentales claros y flujo de trabajo reproducible."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].content",
          "englishWordCount": 269,
          "excerpt": "# Solana modelo mental Solana development gets much easier once you stop thinking in terms of \"contracts that own state\" y start thinking in terms of \"programs that operate on cuentas.\" On Solana, the durable state of yo..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 17,
          "excerpt": "On Solana, mutable app state is cuenta data. Programs validate y mutate those cuentas but do not hold mutable state internally."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "The runtime checks the message envelope y authorization: fee payer, freshness via blockhash, required signatures, y instruccion payloads."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].explanation",
          "englishWordCount": 12,
          "excerpt": "Read/write sets let the runtime detect conflicts y parallelize independent work deterministically."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].content",
          "englishWordCount": 243,
          "excerpt": "# Cuentas model analisis profundo Every on-chain object on Solana is an cuenta con a standard envelope. You can reason about any cuenta using a small set of fields: address, lamports, owner, executable flag, y data bytes..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Executable cuentas are code containers; they are not ordinary mutable data cuentas."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].explanation",
          "englishWordCount": 13,
          "excerpt": "SPL token state uses dedicated cuenta layouts y authorization rules enforced by the token program."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].content",
          "englishWordCount": 303,
          "excerpt": "# Transacciones & instrucciones An instruccion is the smallest executable unit on Solana: `programId + account metas + opaque data bytes`. A transaccion wraps one or more instrucciones plus signatures y message metadata...."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].content",
          "englishWordCount": 61,
          "excerpt": "# Build a SOL transfer transaccion Implement a deterministic `buildTransferTx(params)` helper in the project file: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` - Use `@solana/web3.js` - Return a trans..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[2]",
          "englishWordCount": 14,
          "excerpt": "Mirror this logic in the real project helper in src/lib/cursos/solana-fundamentals/project/walletManager.ts."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Comportamiento de programas, diseno determinista de PDAs y modelo mental de SPL tokens con controles de seguridad."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].content",
          "englishWordCount": 240,
          "excerpt": "# Programs: what they are (y aren’t) A Solana program is executable cuenta code, not an object that secretly owns mutable storage. Your program receives cuentas from the transaccion, verifies constraints, y writes only t..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Cuenta lists are part of the instruccion contract; hidden discovery would break determinism y scheduling assumptions."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].content",
          "englishWordCount": 235,
          "excerpt": "# Direcciones Derivadas de Programa (PDAs) A Direccion Derivada de Programa (PDA) is a deterministic cuenta address derived from seeds plus a program ID, con one key property: it is intentionally off-curve, so no private..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "invoke_signed proves seed derivation to runtime, which grants PDA signer semantics para that invocation."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].content",
          "englishWordCount": 230,
          "excerpt": "# SPL Tokens fundamentos SPL Token is Solana’s standard token program family para fungible assets. A token mint cuenta defines token-level configuration: decimals, total supply accounting, y authorities such as mint auth..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "Associated Token Cuentas standardize where fungible token balances are stored para each owner/mint."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "englishWordCount": 13,
          "excerpt": "Carteras can only hold SOL while token balances are separate program-owned cuentas"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "SPL balances are state in token cuentas, not direct fields on cartera system cuentas."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].content",
          "englishWordCount": 53,
          "excerpt": "# Cartera Manager CLI-sim Implement a deterministic CLI parser + command executor in: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` Required behavior: - `address` prints the active pubkey - `build-tran..."
        },
        {
          "path": "courses.anchor-development.description",
          "englishWordCount": 19,
          "excerpt": "Curso orientado a proyectos para pasar de lo basico a ingenieria real con Anchor: modelado determinista de cuentas, construccion de instrucciones, disciplina de testing y UX de cliente confiable."
        },
        {
          "path": "courses.anchor-development.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Anchor architecture, cuenta constraints, y PDA foundations con explicit ownership of seguridad-critical decisions."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].content",
          "englishWordCount": 350,
          "excerpt": "# Anchor modelo mental Anchor is best understood as a contract between three layers that must agree on shape: your Rust handlers, generated interface metadata (IDL), y client-side instruccion builders. In raw Solana prog..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].content",
          "englishWordCount": 264,
          "excerpt": "# Cuentas, constraints, y safety Most serious Solana vulnerabilities come from cuenta validation mistakes, not from arithmetic. Anchor’s constraint system exists to turn those checks into declarative, auditable rules. Yo..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].content",
          "englishWordCount": 242,
          "excerpt": "# PDAs in Anchor Direcciones Derivadas de Programa are the backbone of predictable cuenta topology in Anchor applications. A PDA is derived from seed bytes plus program ID y intentionally lives off the ed25519 curve, so ..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].content",
          "englishWordCount": 67,
          "excerpt": "# Initialize Counter PDA (deterministic) Implement deterministic helper functions para a Counter project: - `deriveCounterPda(programId, authorityPubkey)` - `buildInitCounterIx(params)` This leccion validates client-side..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[1]",
          "englishWordCount": 15,
          "excerpt": "The init instruccion must include four keys in fixed order: counter PDA, authority, payer, system program."
        },
        {
          "path": "courses.anchor-development.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Deterministic instruccion builders, stable state emulation, y pruebas strategy that separates pure logic from network integration."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].content",
          "englishWordCount": 40,
          "excerpt": "# Increment instruccion builder + state layout Implement deterministic increment behavior in pure TypeScript: - Build a reusable state representation para counter data. - Implement `applyIncrement` as a pure transition f..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].content",
          "englishWordCount": 245,
          "excerpt": "# Pruebas strategy without flakiness A reliable Solana curriculum should teach deterministic engineering first, then optional network integration. Flaky tests are usually caused by external dependencies: RPC latency, fau..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].content",
          "englishWordCount": 253,
          "excerpt": "# Client composition & UX Once instruccion layouts y PDA logic are deterministic, client integration becomes a composition exercise: cartera adapter para signing, provider/connection para transport, transaccion builder p..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].content",
          "englishWordCount": 49,
          "excerpt": "# Counter project checkpoint Compose the full deterministic flow: 1. Derive counter PDA from authority + program ID. 2. Build init instruccion metadata. 3. Build increment instruccion metadata. 4. Emulate state transitio..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[1]",
          "englishWordCount": 13,
          "excerpt": "Use fixed key order y fixed JSON key order to satisfy strict expected output matching."
        },
        {
          "path": "courses.solana-frontend.description",
          "englishWordCount": 17,
          "excerpt": "Curso orientado a proyectos para crear dashboards de Solana listos para produccion: reducers deterministas, pipelines de eventos reproducibles y UX de transacciones confiable."
        },
        {
          "path": "courses.solana-frontend.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Modela correctamente estado de wallet/cuentas, disena UX del ciclo de vida de transacciones y aplica reglas deterministas para debugging reproducible."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].content",
          "englishWordCount": 468,
          "excerpt": "# Cartera state + cuentas modelo mental para UI devs Most Solana frontend bugs are not visual bugs. They are model bugs. A dashboard can look polished while silently computing balances from the wrong cuenta class, mixing..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].content",
          "englishWordCount": 355,
          "excerpt": "# Transaccion lifecycle para UI: pending/confirmed/finalized, optimistic UI Frontend transaccion UX is a state machine problem. Users press one button, but your app traverses multiple phases: intent creation, transaccion..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].content",
          "englishWordCount": 354,
          "excerpt": "# Data correctness: dedupe, ordering, idempotency, correction events Frontend teams frequently assume event streams are perfectly ordered y unique. Production systems rarely behave that way. You can receive duplicate eve..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].content",
          "englishWordCount": 34,
          "excerpt": "# Build core state model + reducer from events Implement a deterministic reducer para dashboard state: - apply event stream transitions para balances y mint metadata - enforce idempotency by event id - support correction..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Corrections should mark replaced event ids y remove their effects from state transitions."
        },
        {
          "path": "courses.solana-frontend.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Construye reducer, snapshots de replay, metricas de consulta y salidas deterministas de dashboard estables bajo datos parciales o demorados."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].content",
          "englishWordCount": 28,
          "excerpt": "# Implement event stream simulator + replay timeline + snapshots Build deterministic replay tooling: - replay sorted events by (ts, id) - snapshot every N applied events - compute stable checksum para replay output - ret..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].content",
          "englishWordCount": 30,
          "excerpt": "# Implement query layer + computed metrics Implement dashboard query/view logic: - search/filter/sort rows deterministically - compute total y row valueUsd con fixed-scale integer math - expose stable view model para UI ..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].content",
          "englishWordCount": 386,
          "excerpt": "# Production UX: caching, pagination, error banners, skeletons, rate limits After model correctness, frontend quality is mostly about user trust under imperfect conditions. Users do not evaluate your dashboard by clean d..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[3].content",
          "englishWordCount": 27,
          "excerpt": "# Emit stable DashboardSummary from fixtures Compose deterministic checkpoint output: - owner, token count, totalValueUsd - top tokens sorted deterministically - recent activity rows - invariants y determinism metadata (..."
        },
        {
          "path": "courses.defi-solana.description",
          "englishWordCount": 21,
          "excerpt": "Curso avanzado orientado a proyectos para construir sistemas de swaps: planeacion determinista estilo Jupiter sin dependencia online, ranking de rutas, seguridad de minOut y diagnosticos reproducibles."
        },
        {
          "path": "courses.defi-solana.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Comprende matematica CPMM, anatomia de cotizacion y tradeoffs de routing determinista con protecciones de usuario enfocadas en seguridad."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].content",
          "englishWordCount": 521,
          "excerpt": "# AMM fundamentos on Solana: pools, fees, slippage, y impacto de precio When users click “Swap,” they usually assume there is one objective truth: the current price. In practice, frontend swap systems compute an estimate..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].content",
          "englishWordCount": 390,
          "excerpt": "# Quote anatomy: in/out, fees, minOut, y worst-case execution A production quote is not one number. It is a structured object that must tell users what they send, what they likely receive, how much they pay in fees, y wh..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].content",
          "englishWordCount": 407,
          "excerpt": "# Routing: why two-hop can beat one-hop Users often assume direct pair routes are always best because they are simpler. In fragmented liquidity systems, that assumption fails frequently. A direct SOL -> JUP pool might ha..."
        },
        {
          "path": "courses.defi-solana.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Construye cotizacion determinista, seleccion de rutas y checks de seguridad minOut; luego empaqueta artefactos de checkpoint estables para revisiones reproducibles."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].content",
          "englishWordCount": 29,
          "excerpt": "# Implement route enumeration y best-route selection Implement deterministic route planner: - enumerate one-hop y two-hop candidates - quote each candidate at exact input size - select best route using stable tie-breaker..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].content",
          "englishWordCount": 35,
          "excerpt": "# Implement slippage/minOut, fee breakdown, y safety invariants Implement deterministic safety layer: - apply slippage to compute minOut - simulate route con virtual reserve updates - return structured errors para invali..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].content",
          "englishWordCount": 404,
          "excerpt": "# Production swap UX: stale quotes, protection, y simulation A deterministic route engine is necessary but not sufficient para production. Users experience DeFi through timing, messaging, y safety affordances. A mathemat..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].content",
          "englishWordCount": 29,
          "excerpt": "# Produce stable SwapPlan + SwapSummary checkpoint Compose deterministic checkpoint artifacts: - build swap plan from selected route quote - include fixtureHash y modelVersion - emit stable summary con path, minOut, fee ..."
        },
        {
          "path": "courses.solana-security.description",
          "englishWordCount": 18,
          "excerpt": "Laboratorio determinista de vulnerabilidades para auditores de Solana que necesitan evidencia de exploits repetible, guias de remediacion precisas y artefactos de auditoria de alta senal."
        },
        {
          "path": "courses.solana-security.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Modelado de amenazas centrado en cuentas, reproduccion determinista de exploits y disciplina de evidencia para hallazgos de auditoria creibles."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].content",
          "englishWordCount": 562,
          "excerpt": "# Solana threat model para auditors: cuentas, owners, signers, writable, PDAs Seguridad work on Solana starts con one non-negotiable fact: instruccion callers choose the cuenta list. Programs do not receive trusted impli..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Without owner checks, cuenta substitution allows attacker-controlled bytes to be parsed as trusted state."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].content",
          "englishWordCount": 445,
          "excerpt": "# Evidence chain: reproduce, trace, impact, fix, verify Strong seguridad reports are built on evidence chains, not opinions. In the Solana context, that means moving from a claim such as “missing signer check exists” to ..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].content",
          "englishWordCount": 475,
          "excerpt": "# Common Solana bug classes y mitigations Auditors on Solana repeatedly encounter the same core bug families. The implementation details differ across protocols, but exploit mechanics are surprisingly consistent: identit..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "Seguridad failures are usually adversarial edge cases, so tests must target those edges directly."
        },
        {
          "path": "courses.solana-security.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Explotar, corregir, verificar y producir artefactos listos para auditoria con trazas deterministas y conclusiones respaldadas por invariantes."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].content",
          "englishWordCount": 43,
          "excerpt": "# Break it: exploit missing signer + owner checks Implement a deterministic exploit-proof formatter para signer/owner vulnerabilities. Expected output fields: - scenario - before/after vault balance - before/after recipi..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].content",
          "englishWordCount": 30,
          "excerpt": "# Break it: exploit PDA spoof mismatch Implement a deterministic PDA spoof proof output. You must show: - expected PDA - accepted PDA - mismatch boolean - trace hash This leccion validates evidence generation para deriva..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].content",
          "englishWordCount": 30,
          "excerpt": "# Fix it: validations + invariant suite Implement patch validation output that confirms: - signer check - owner check - PDA check - safe u64 arithmetic - exploit blocked state con error code Keep output deterministic par..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].content",
          "englishWordCount": 455,
          "excerpt": "# Writing audit reports: severity, likelihood, blast radius, remediation A strong audit report is an engineering document, not a narrative essay. It should allow a reader to answer four questions quickly: what failed, ho..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].content",
          "englishWordCount": 29,
          "excerpt": "# Checkpoint: deterministic AuditReport JSON + markdown Create the final deterministic checkpoint payload: - curso + version - scenario IDs - finding count This checkpoint mirrors the final curso artifact produced by the..."
        },
        {
          "path": "courses.token-engineering.description",
          "englishWordCount": 20,
          "excerpt": "Curso orientado a proyectos para equipos que lanzan tokens reales en Solana: planeacion determinista de Token-2022, diseno de autoridades, simulacion de supply y disciplina operativa de lanzamiento."
        },
        {
          "path": "courses.token-engineering.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Comprende primitivas de token, anatomia de politicas de mint y controles de extensiones Token-2022 con enfoque explicito de gobernanza y amenazas."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].content",
          "englishWordCount": 392,
          "excerpt": "# SPL tokens vs Token-2022: what extensions change Token engineering starts con a clean boundary between base token semantics y configurable policy. Legacy SPL Token gives you a stable fungible primitive: mint metadata, ..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].content",
          "englishWordCount": 365,
          "excerpt": "# Mint anatomy: authorities, decimals, supply, freeze, mint A production token launch succeeds or fails on parameter discipline. The mint cuenta is a compact policy object: it defines decimal precision, minting authority..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].content",
          "englishWordCount": 360,
          "excerpt": "# Extension safety pitfalls: fee configs, delegate abuse, default cuenta state Token-2022 extensions let teams express policy in a standard token framework, but policy power is exactly where operational failures happen. ..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].content",
          "englishWordCount": 35,
          "excerpt": "# Validate token config + derive deterministic addresses offline Implement strict config validation y deterministic pseudo-derivation: - validate decimals, u64 strings, recipient totals, extension fields - derive stable ..."
        },
        {
          "path": "courses.token-engineering.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Construye flujos deterministas de validacion, planificacion y simulacion que produzcan artefactos de lanzamiento revisables y criterios claros de go/no-go."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].content",
          "englishWordCount": 32,
          "excerpt": "# Build Token-2022 initialization instruccion plan Create a deterministic offline initialization plan: - create mint cuenta step - init mint step con decimals - append selected extension steps in stable order - base64 en..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].hints[0]",
          "englishWordCount": 12,
          "excerpt": "Add base steps first: create mint cuenta, then initialize mint con decimals."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].content",
          "englishWordCount": 28,
          "excerpt": "# Build mint-to + transfer-fee math + simulation Implement pure simulation para transfer fees y launch distribution: - fee = min(maxFee, floor(amount * feeBps / 10000)) - aggregate distribution totals deterministically -..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].content",
          "englishWordCount": 359,
          "excerpt": "# Launch checklist: params, upgrade/authority strategy, airdrop/pruebas plan A successful token launch is an operations exercise as much as a programming task. By the time users see your token in carteras, dozens of choi..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].content",
          "englishWordCount": 27,
          "excerpt": "# Emit stable LaunchPackSummary Compose full project output as stable JSON: - normalized authorities y extensions - supply totals y optional fee model examples - deterministic plan metadata y invariants - fixtures hash +..."
        },
        {
          "path": "courses.solana-mobile.description",
          "englishWordCount": 18,
          "excerpt": "Construye dApps moviles de Solana listas para produccion con MWA, arquitectura robusta de sesiones de wallet, UX de firma explicita y operaciones de distribucion disciplinadas."
        },
        {
          "path": "courses.solana-mobile.modules[0].description",
          "englishWordCount": 17,
          "excerpt": "Protocolo base de MWA, control del ciclo de vida de sesiones y patrones resilientes de handoff con wallet para apps moviles en produccion."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[0].content",
          "englishWordCount": 344,
          "excerpt": "# Mobile Cartera Vision general Solana Mobile development is built around the Solana Mobile Stack (SMS), a set of standards y tooling designed para secure, high-quality crypto-native mobile experiences. SMS is more than ..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[1].content",
          "englishWordCount": 237,
          "excerpt": "# MWA Integration Integrating Mobile Cartera Adapter typically starts con `@solana-mobile/mobile-wallet-adapter` APIs y an interaction pattern built around `transact()`. Within a transaccion session, the app can authoriz..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].content",
          "englishWordCount": 25,
          "excerpt": "# Build a Mobile Transaccion Function Implement a helper that formats a deterministic MWA transaccion request summary string. Expected output format: `<cluster>|<payer>|<instructionCount>` Use this exact order y delimite..."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[0].content",
          "englishWordCount": 261,
          "excerpt": "# dApp Store Submission Publishing to the Solana dApp Store requires more than packaging binaries. Teams should treat submission as a product, compliance, y seguridad review process. A strong submission demonstrates safe..."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[1].content",
          "englishWordCount": 284,
          "excerpt": "# Mobile Mejores practicas Mobile crypto UX requires balancing speed, safety, y trust. Users make high-stakes decisions on small screens, often on unstable networks. Solana mobile apps should therefore optimize para expl..."
        },
        {
          "path": "courses.solana-testing.description",
          "englishWordCount": 18,
          "excerpt": "Construye sistemas de testing robustos para Solana en entornos locales, simulados y de red con invariantes de seguridad explicitas y controles de confianza de calidad de release."
        },
        {
          "path": "courses.solana-testing.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Estrategia central de pruebas en capas unit/integration con flujos deterministas y cobertura de casos adversariales."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[0].content",
          "englishWordCount": 313,
          "excerpt": "# Pruebas Approaches Pruebas Solana programs requires multiple layers because failures can occur in logic, cuenta validation, transaccion composition, or network behavior. A production pruebas strategy usually combines u..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[1].content",
          "englishWordCount": 244,
          "excerpt": "# Bankrun Pruebas Solana Bankrun provides deterministic, high-speed test execution para Solana programs from TypeScript environments. It emulates a local bank-like runtime where transacciones can be processed predictably..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[0].content",
          "englishWordCount": 249,
          "excerpt": "# Fuzzing con Trident Fuzzing explores large input spaces automatically to find bugs that handcrafted tests miss. Para Solana y Anchor programs, Trident-style fuzzing workflows generate randomized instruccion sequences y..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[1].content",
          "englishWordCount": 220,
          "excerpt": "# Devnet Pruebas Devnet pruebas bridges the gap between deterministic local tests y real-world network conditions. While local validadores y Bankrun are ideal para speed y reproducibility, devnet reveals behavior under r..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[2].content",
          "englishWordCount": 216,
          "excerpt": "# CI/CD Pipeline para Solana A mature Solana CI/CD pipeline enforces quality gates across code, tests, seguridad checks, y despliegue workflows. Para program teams, CI is not just linting Rust y TypeScript; it is about p..."
        },
        {
          "path": "courses.solana-indexing.description",
          "englishWordCount": 18,
          "excerpt": "Construye un indexador de eventos de Solana de nivel produccion con decodificacion determinista, contratos de ingesta resilientes, recuperacion por checkpoints y salidas analiticas confiables."
        },
        {
          "path": "courses.solana-indexing.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Modelo de eventos, decodificacion de cuentas token y parseo de metadatos de transaccion para pipelines de indexacion confiables."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].content",
          "englishWordCount": 318,
          "excerpt": "# Events model: transacciones, logs, y program instrucciones Indexing Solana starts con understanding where data lives y how to extract structured events from raw chain data. Unlike EVM chains where events are explicit l..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Solana programs emit events via logs y state changes, not explicit event topics."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Idempotent ingestion ensures the same transaccion processed twice creates only one event."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].content",
          "englishWordCount": 219,
          "excerpt": "# Token cuenta decoding y SPL layout SPL Token cuentas follow a standardized binary layout that indexers must parse to track balances y mint operations. Understanding this layout enables you to extract meaningful data fr..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Standard SPL Token cuentas are 165 bytes, containing mint, owner, amount, y optional fields."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Amounts are stored as little-endian u64 y must be converted using the mint's decimal places."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[2].content",
          "englishWordCount": 52,
          "excerpt": "# Challenge: Decode token cuenta + diff token balances Implement deterministic token cuenta decoding y balance diffing: - Parse a 165-byte SPL Token cuenta layout - Extract mint, owner, y amount fields - Compute balance ..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].content",
          "englishWordCount": 240,
          "excerpt": "# Transaccion meta parsing: logs, errors, y inner instrucciones Transaccion metadata provides the context needed to index complex operations. Understanding how to parse logs, handle errors, y traverse inner instrucciones..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].content",
          "englishWordCount": 44,
          "excerpt": "# Challenge: Index transacciones to normalized events Implement a transaccion indexer that produces normalized Event objects: - Parse instruccion logs y identify event types - Extract transfer events con from/to/amount/m..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].content",
          "englishWordCount": 228,
          "excerpt": "# Pagination, checkpointing, y caching semantics Production indexers must handle large datasets efficiently while maintaining consistency. Pagination, checkpointing, y caching form the backbone of scalable indexing infra..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[2].content",
          "englishWordCount": 213,
          "excerpt": "# Analytics aggregation: per cartera, per token metrics Raw event data becomes valuable through aggregation. Building analytics pipelines enables insights into user behavior, token flows, y protocol usage patterns. Per-c..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].content",
          "englishWordCount": 50,
          "excerpt": "# Checkpoint: Produce stable JSON analytics summary Implement the final analytics checkpoint that produces a deterministic summary: - Aggregate events into per-cartera y per-token metrics - Generate sorted, stable JSON o..."
        },
        {
          "path": "courses.solana-payments.description",
          "englishWordCount": 19,
          "excerpt": "Construye flujos de pago en Solana de nivel produccion con validaciones robustas, idempotencia segura ante reintentos, webhooks seguros y comprobantes deterministas para conciliacion."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].content",
          "englishWordCount": 264,
          "excerpt": "# Address validation y memo strategies Payment flows on Solana require robust address validation y thoughtful memo strategies. Unlike traditional payment systems con cuenta numbers, Solana uses base58-encoded public keys..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[1].content",
          "englishWordCount": 221,
          "excerpt": "# Idempotency keys y replay protection Payment systems must handle network failures gracefully. Idempotency ensures that retrying a failed request produces the same outcome as the original, preventing duplicate charges y..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].content",
          "englishWordCount": 48,
          "excerpt": "# Challenge: Create payment intent con validation Implement a payment intent creator con full validation: - Validate recipient address format (base58, 32 bytes) - Validate amount (positive, within limits) - Generate dete..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[3].content",
          "englishWordCount": 216,
          "excerpt": "# Transaccion building y key metadata Building payment transacciones requires careful attention to instruccion construction, cuenta metadata, y program interactions. The goal is creating valid, efficient transacciones th..."
        },
        {
          "path": "courses.solana-payments.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Construccion de transacciones, verificacion de autenticidad de webhook y generacion determinista de recibos con manejo claro de estados de error."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].content",
          "englishWordCount": 36,
          "excerpt": "# Challenge: Build transfer transaccion Implement a transfer transaccion builder: - Build SystemProgram.transfer para SOL transfers - Build TokenProgram.transfer para SPL transfers - Return instruccion bundle con correct..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].content",
          "englishWordCount": 187,
          "excerpt": "# Webhook signing y verification Webhooks enable asynchronous payment notifications. Seguridad requires cryptographic signing so recipients can verify webhook authenticity y detect tampering. Webhook signing uses HMAC-SH..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].content",
          "englishWordCount": 195,
          "excerpt": "# Error state machine y receipt format Payment flows require well-defined state machines to handle the complexity of asynchronous confirmations, failures, y retries. Clear state transitions y receipt formats ensure relia..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].content",
          "englishWordCount": 43,
          "excerpt": "# Challenge: Verify webhook y produce receipt Implement the final payment flow checkpoint: - Verify signed webhook signature (HMAC-SHA256) - Extract payment details from payload - Generate standardized receipt JSON - Inc..."
        },
        {
          "path": "courses.solana-nft-compression.description",
          "englishWordCount": 15,
          "excerpt": "Domina la ingenieria de NFTs comprimidos en Solana: compromisos Merkle, sistemas de pruebas, modelado de colecciones y controles de seguridad de nivel produccion."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Construccion de arboles, hashing de hojas, mecanica de insercion y modelo de compromiso on-chain/off-chain detras de activos comprimidos."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].content",
          "englishWordCount": 278,
          "excerpt": "# Merkle trees para state compression Compressed NFTs (cNFTs) on Solana use Merkle trees to dramatically reduce storage costs. Understanding Merkle trees is essential para working con compressed NFTs y building compressi..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[1].content",
          "englishWordCount": 214,
          "excerpt": "# Leaf hashing conventions y metadata Leaf hashing determines how NFT metadata is committed to the Merkle tree. Understanding these conventions ensures compatibility con compression standards y proper proof generation. L..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].content",
          "englishWordCount": 42,
          "excerpt": "# Challenge: Implement Merkle tree insert + root updates Build a Merkle tree implementation con insertions: - Insert leaves y compute new root - Update parent hashes up the tree - Handle tree growth y depth limits - Retu..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].content",
          "englishWordCount": 227,
          "excerpt": "# Proof generation y path computation Merkle proofs enable verification of leaf inclusion without accessing the entire tree. Understanding proof generation is essential para working con compressed NFTs y building verific..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement proof generation + verifier Build a complete proof system: - Generate proofs from a Merkle tree y leaf index - Verify proofs against a root hash - Handle invalid proofs (wrong siblings, wrong index..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[1].content",
          "englishWordCount": 216,
          "excerpt": "# Collection mints y metadata simulation Compressed NFT collections use a collection mint as the parent NFT, enabling grouping y verification of related assets. Understanding this hierarchy is essential para building col..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].content",
          "englishWordCount": 254,
          "excerpt": "# Attack surface: invalid proofs y replay Compressed NFTs introduce unique seguridad considerations. Understanding attack vectors y mitigations is critical para building secure compression-aware applications. Invalid pro..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].content",
          "englishWordCount": 53,
          "excerpt": "# Checkpoint: Simulate mint + verify ownership proof Complete the compression lab checkpoint: - Simulate minting a cNFT (insert leaf, update root) - Generate ownership proof para the minted NFT - Verify the proof against..."
        },
        {
          "path": "courses.solana-governance-multisig.description",
          "englishWordCount": 18,
          "excerpt": "Construye sistemas DAO y tesoreria multisig listos para produccion con conteo de votos determinista, seguridad por timelock y controles de ejecucion seguros."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Ciclo de vida de propuestas, mecanicas de voto deterministas, politica de quorum y seguridad de timelock para una gobernanza DAO creible."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].content",
          "englishWordCount": 247,
          "excerpt": "# DAO model: proposals, voting, y execution Decentralized gobernanza on Solana follows a proposal-based model where token holders vote on changes y the DAO treasury executes approved decisions. Understanding this flow is..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[1].content",
          "englishWordCount": 185,
          "excerpt": "# Quorum math y vote weight calculation Accurate vote counting is critical para legitimate gobernanza outcomes. Understanding quorum requirements, vote weight calculation, y edge cases ensures fair decision-making. Quoru..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].content",
          "englishWordCount": 169,
          "excerpt": "# Timelock states y execution scheduling Timelocks provide a critical safety layer between gobernanza approval y execution. Understanding timelock states y transitions ensures reliable proposal execution. Timelock states..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Construccion de transacciones multisig, controles de aprobacion, defensas contra replay y patrones de ejecucion segura de tesoreria."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].content",
          "englishWordCount": 176,
          "excerpt": "# Multisig transaccion building y approvals Multisig carteras provide collective control over treasury funds. Understanding multisig construction, approval flows, y seguridad patterns is essential para treasury operation..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].content",
          "englishWordCount": 34,
          "excerpt": "# Challenge: Implement multisig tx builder + approval rules Build a multisig transaccion system: - Create transacciones con instrucciones - Record signer approvals - Enforce threshold requirements - Handle approval revoc..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].content",
          "englishWordCount": 191,
          "excerpt": "# Safe defaults: owner checks y replay guards Gobernanza y multisig systems require robust seguridad defaults. Understanding common vulnerabilities y their mitigations protects treasury funds. Owner checks validate that ..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].content",
          "englishWordCount": 48,
          "excerpt": "# Challenge: Execute proposal y produce treasury diff Complete the gobernanza simulator checkpoint: - Execute approved proposals con timelock validation - Apply treasury state changes atomically - Generate execution trac..."
        },
        {
          "path": "courses.solana-performance.description",
          "englishWordCount": 17,
          "excerpt": "Domina la ingenieria de rendimiento en Solana con flujos de optimizacion medibles: compute budget, layouts de datos, eficiencia de encoding y modelado de costos determinista."
        },
        {
          "path": "courses.solana-performance.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Modelo de compute, decisiones de layout de cuenta/datos y estimacion determinista de costos para razonar rendimiento a nivel transaccion."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].content",
          "englishWordCount": 234,
          "excerpt": "# Compute model: budgets, costs, y limits Solana's compute model enforces deterministic execution limits through compute budgets. Understanding this model is essential para building efficient programs that stay within li..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[1].content",
          "englishWordCount": 198,
          "excerpt": "# Cuenta layout diseno y serialization cost Cuenta data layout significantly impacts compute costs. Well-designed layouts minimize serialization overhead y reduce cuenta access costs. Serialization formats affect cost. B..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement estimateCost(op) model Build a compute cost estimation system: - Model costs para different operation types - Cuenta para instruccion complexity - Include memory access costs - Return baseline meas..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].content",
          "englishWordCount": 172,
          "excerpt": "# Instruccion data size y encoding optimization Instruccion data size directly impacts transaccion cost y throughput. Optimizing encoding reduces fees y increases the operations possible within compute limits. Compact en..."
        },
        {
          "path": "courses.solana-performance.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Optimizacion de layout, ajuste de compute budget y analisis before/after de rendimiento con salvaguardas de correccion."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].content",
          "englishWordCount": 42,
          "excerpt": "# Challenge: Implement optimized layout/codec Optimize an cuenta data layout while preserving semantics: - Reduce data size through compact encoding - Maintain all original functionality - Preserve backward compatibility..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].content",
          "englishWordCount": 176,
          "excerpt": "# Compute budget instruccion fundamentos Compute budget instrucciones give developers control over resource allocation y transaccion prioritization. Understanding these tools enables precise optimization. setComputeUnitL..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "Specific limits optimize costs - you pay para the limit requested, not actual usage."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].content",
          "englishWordCount": 172,
          "excerpt": "# Micro-optimizations y tradeoffs Rendimiento optimization involves balancing competing concerns. Understanding tradeoffs helps make informed decisions about when y what to optimize. Readability vs rendimiento is a const..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].content",
          "englishWordCount": 40,
          "excerpt": "# Checkpoint: Compare before/after + output perf report Complete the optimization lab checkpoint: - Measure baseline rendimiento metrics - Apply optimization techniques - Verify correctness is preserved - Generate rendim..."
        },
        {
          "path": "courses.defi-swap-aggregator.description",
          "englishWordCount": 17,
          "excerpt": "Domina la agregacion de swaps en Solana para produccion: parseo determinista de cotizaciones, tradeoffs de optimizacion de rutas, seguridad de slippage y ejecucion consciente de confiabilidad."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Mecanica de swap de tokens, proteccion de slippage, composicion de rutas y construccion determinista de SwapPlan con tradeoffs transparentes."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].content",
          "englishWordCount": 403,
          "excerpt": "# Swap modelo mental: mints, ATAs, decimals, y routes Token swaps on Solana follow a fundamentally different model than centralized exchanges. Understanding the building blocks — mints, associated token cuentas (ATAs), d..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "AMM programs interact con SPL token cuentas. Native SOL must be wrapped into the SPL token format so it can be processed by swap programs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].content",
          "englishWordCount": 377,
          "excerpt": "# Slippage y impacto de precio: protecting swap outcomes Slippage is the difference between the expected output amount at quote time y the actual amount received at execution time. In volatile markets con active trading,..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Token amounts are integers. Floating-point math can produce off-by-one errors that cause transaccion failures or incorrect minimum amounts."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].content",
          "englishWordCount": 402,
          "excerpt": "# Route visualization: understanding swap legs y fees Swap routes reveal the path your tokens take through DeFi liquidity. Visualizing routes helps users understand why a multi-hop path might yield more output than a dir..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].content",
          "englishWordCount": 65,
          "excerpt": "# Challenge: Build a normalized SwapPlan from a quote Parse a raw aggregator quote response y produce a normalized SwapPlan: - Extract input/output mints y amounts from the quote - Calculate minOutAmount using BigInt sli..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Ejecucion con maquina de estados, anatomia de transacciones, patrones de confiabilidad para retry/staleness y reportes de ejecucion de alto valor."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].content",
          "englishWordCount": 68,
          "excerpt": "# Challenge: Implement swap UI state machine Build a deterministic state machine para the swap UI flow: - States: idle → quoting → ready → sending → confirming → success | error - Process a sequence of events y track all..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].hints[1]",
          "englishWordCount": 12,
          "excerpt": "If an event is not valid para the current state, transition to 'error' con a descriptive message."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].content",
          "englishWordCount": 418,
          "excerpt": "# Swap transaccion anatomy: instrucciones, cuentas, y compute A swap transaccion on Solana is a carefully ordered sequence of instrucciones that together achieve an atomic token exchange. Understanding each instruccion's..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 13,
          "excerpt": "Compute budget instrucciones configure the transaccion's CU limit y price before any program execution begins."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "ALTs allow transacciones to reference many cuentas without exceeding the 1232-byte transaccion size limit."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].content",
          "englishWordCount": 382,
          "excerpt": "# Reliability patterns: retries, stale quotes, y latency Production swap flows must handle the reality of network latency, expired quotes, y transaccion failures. Reliability engineering separates toy swap implementation..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].content",
          "englishWordCount": 68,
          "excerpt": "# Checkpoint: Generate a SwapRunReport Build the final swap run report that combines all curso concepts: - Summarize the route con leg details y total fees (using BigInt summation) - Compute the effective price as outAmo..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Collect errors from both the state machine result y any additional errors array."
        },
        {
          "path": "courses.defi-clmm-liquidity.description",
          "englishWordCount": 19,
          "excerpt": "Domina la ingenieria de liquidez concentrada en DEX de Solana: matematicas de ticks, diseno de estrategias por rango, dinamicas de fees e impermanent loss y reportes deterministas de posiciones LP."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Conceptos de liquidez concentrada, matematicas tick/precio y comportamiento de posiciones por rango para razonar sobre ejecucion CLMM."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].content",
          "englishWordCount": 645,
          "excerpt": "# CLMM vs constant product: why ticks exist Concentrated Liquidity Market Makers (CLMMs) represent a fundamental evolution in automated market maker diseno. To understand why they exist, we must first understand the limi..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Ticks provide discrete price points para position boundaries, liquidity transitions, y efficient fee tracking at tick crossings."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].content",
          "englishWordCount": 553,
          "excerpt": "# Price, tick, y sqrtPrice: core conversions The mathematical foundation of every CLMM rests on three interrelated representations of price: the human-readable price, the tick index, y the sqrtPriceX64. Understanding how..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Token amounts in a CLMM position are linear functions of sqrtPrice, making on-chain computation simpler y more gas-efficient."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].content",
          "englishWordCount": 627,
          "excerpt": "# Range positions: in-range y out-of-range dynamics A CLMM position is defined by its lower tick y upper tick. These two boundaries determine the price range in which the position is active, earns fees, y holds a mix of ..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].content",
          "englishWordCount": 61,
          "excerpt": "# Challenge: Implement tick/price conversion helpers Implement the core tick math functions used in every CLMM integration: - Convert a tick index to a human-readable price using price = 1.0001^tick - Convert the price t..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Simulacion de acumulacion de fees, tradeoffs de estrategias por rango, riesgos de precision y reportes deterministas de riesgo de posicion."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].content",
          "englishWordCount": 66,
          "excerpt": "# Challenge: Simulate position fee accrual Implement a fee accrual simulator para a CLMM position over a price path: - Convert lower y upper tick boundaries to prices - Walk through each price in the path y determine in-..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].content",
          "englishWordCount": 628,
          "excerpt": "# Range strategies: tight, wide, y rebalancing rules Choosing the right price range is the most important decision a CLMM liquidity provider makes. The range determines capital efficiency, fee income, impermanent loss ex..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "Tight ranges concentrate capital para higher efficiency y fee share, but the position goes out-of-range more often, requiring active management."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 18,
          "excerpt": "Full-range positions replicate constant product behavior y never go out-of-range, making them suitable para highly volatile or unpredictable pairs."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].content",
          "englishWordCount": 666,
          "excerpt": "# CLMM risks: rounding, overflow, y tick spacing errors Building reliable CLMM integrations requires awareness of precision risks that can cause incorrect calculations, failed transacciones, or lost funds. This leccion c..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].content",
          "englishWordCount": 64,
          "excerpt": "# Checkpoint: Generate a Position Report Implement a comprehensive LP position report generator that combines all CLMM concepts: - Convert tick boundaries to human-readable prices - Determine in-range or out-of-range sta..."
        },
        {
          "path": "courses.defi-lending-risk.description",
          "englishWordCount": 15,
          "excerpt": "Domina el riesgo de lending en Solana: mecanicas de utilizacion y tasas, analisis de rutas de liquidacion, seguridad de oraculos y reportes deterministas de escenarios."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Mecanica de pools de lending, modelos de tasa impulsados por utilizacion y bases de health factor necesarias para analisis de riesgo defendible."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].content",
          "englishWordCount": 530,
          "excerpt": "# Lending pool model: supply, borrow, y utilization Lending protocols are the backbone of decentralized finance. They enable users to earn yield on idle assets by supplying them to a shared pool, while borrowers draw fro..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].content",
          "englishWordCount": 435,
          "excerpt": "# Interest rate curves y the kink model Interest rates in lending protocols are not fixed. They adjust dynamically based on pool utilization to balance supply y demand para liquidity. The piecewise-linear \"kink\" model is..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "Above the kink, slope2 (the jump multiplier) applies, causing borrow rates to spike sharply y discourage further borrowing."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Supply rate = borrowRate * utilization * (1 - reserveFactor). Since utilization < 1 y reserveFactor > 0, the supply rate is always less than the borrow rate."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].content",
          "englishWordCount": 440,
          "excerpt": "# Health factor monitoring y liquidation preview The health factor is the single number that determines whether a lending position is safe or subject to liquidation. Monitoring health factors in real time is essential pa..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].content",
          "englishWordCount": 85,
          "excerpt": "# Challenge: Compute utilization-based interest rates Implement the kink-based interest rate model used by lending protocols: - Calculate the utilization ratio from total supply y total borrowed - Apply the piecewise-lin..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Calculo de health factor, mecanicas de liquidacion, manejo de fallas de oraculos y reportes de riesgo multi-escenario para mercados estresados."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].content",
          "englishWordCount": 74,
          "excerpt": "# Challenge: Compute health factor y liquidation status Implement the health factor computation para a multi-asset lending position: - Sum collateral y borrow values from an array of position objects - Compute weighted a..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].content",
          "englishWordCount": 530,
          "excerpt": "# Liquidation mechanics: bonus, close factor, y bad debt Liquidation is the enforcement mechanism that keeps lending protocols solvent. When a borrower's health factor falls below 1.0, external actors called liquidators ..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 17,
          "excerpt": "The liquidation bonus compensates liquidators para gas costs y risk, ensuring positions are liquidated promptly to protect the protocol."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 20,
          "excerpt": "Bad debt materializes when rapid price drops make collateral worth less than the debt, leaving the protocol con unrecoverable losses."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].content",
          "englishWordCount": 573,
          "excerpt": "# Oracle risk y stale pricing in lending Lending protocols depend entirely on accurate, timely price feeds to compute collateral values, health factors, y liquidation eligibility. Oracles — the services that bring off-ch..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "Using price minus confidence para collateral gives a conservative valuation, protecting the protocol when oracle publishers disagree or markets are volatile."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Operating on stale prices is dangerous. Pausing operations prevents incorrect liquidations y under-collateralized borrows during oracle outages."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].content",
          "englishWordCount": 78,
          "excerpt": "# Checkpoint: Generate a multi-scenario risk report Build the final risk report that combines all curso concepts: - Evaluate a base case using current position prices - Apply price overrides from multiple named scenarios..."
        },
        {
          "path": "courses.defi-perps-risk-console.description",
          "englishWordCount": 16,
          "excerpt": "Domina la ingenieria de riesgo de perps en Solana: contabilidad precisa de PnL y funding, monitoreo de margen, simulacion de liquidaciones y reportes deterministas en consola."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Mecanica de futuros perpetuos, logica de acumulacion de funding y bases de modelado de PnL para diagnosticos precisos de posiciones."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].content",
          "englishWordCount": 608,
          "excerpt": "# Perpetual futures: base positions, entry price, y mark vs oracle Perpetual futures (perps) are synthetic derivatives that let traders gain exposure to an asset's price movement without holding the underlying token. Unl..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].content",
          "englishWordCount": 601,
          "excerpt": "# Funding rates: why they exist y how they accrue Funding rates are the mechanism that tethers a perpetual contract's price to the underlying spot price. Without funding, the perp price could drift arbitrarily far from r..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "A positive premium (mark > oracle) produces a positive funding rate. Longs pay shorts, which discourages excessive long demand y pushes the perp price back toward spot."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].content",
          "englishWordCount": 561,
          "excerpt": "# PnL visualization: tracking profit over time Profit y loss (PnL) tracking in perpetual futures requires careful accounting across multiple dimensions: unrealized PnL from price movement, realized PnL from closed portio..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].content",
          "englishWordCount": 56,
          "excerpt": "# Challenge: Calculate perpetual futures PnL Implement a PnL calculator para perpetual futures positions: - Compute unrealized PnL based on entry price vs mark price - Handle both long y short positions correctly - Calcu..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].content",
          "englishWordCount": 71,
          "excerpt": "# Challenge: Simulate funding rate accrual Build a funding accrual simulator that processes discrete funding intervals: - Iterate through an array of funding rates y compute the payment para each period - Longs pay (subt..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Monitoreo de margen y liquidaciones, errores comunes de implementacion y salidas deterministas de consola de riesgo para observabilidad en produccion."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].content",
          "englishWordCount": 600,
          "excerpt": "# Margin ratio y liquidation thresholds Margin is the collateral that backs a leveraged position. When the margin falls below a critical threshold relative to the position's notional value, the protocol forcibly closes t..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 27,
          "excerpt": "The maintenance buffer ensures that when a position is liquidated, there is still margin left to pay liquidation fees y absorb slippage during the close. Without it, positions could go underwater, creating bad debt."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].content",
          "englishWordCount": 752,
          "excerpt": "# Common bugs: sign errors, units, y funding direction Perpetual futures implementations are mathematically straightforward — the formulas are basic arithmetic. Yet sign errors, unit mismatches, y funding direction bugs ..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 37,
          "excerpt": "When size carries the direction sign, every formula that uses size must cuenta para the sign — not just PnL, but also notional value, funding payments, y liquidation price. Keeping size positive y branching on a separate..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].content",
          "englishWordCount": 75,
          "excerpt": "# Checkpoint: Generate a Risk Console Report Build the comprehensive risk console report that integrates all curso concepts: - Calculate unrealized PnL y ROE para the position - Accumulate funding payments across all pro..."
        },
        {
          "path": "courses.defi-tx-optimizer.description",
          "englishWordCount": 16,
          "excerpt": "Domina la optimizacion de transacciones DeFi en Solana: ajuste de compute y fees, estrategia ALT, patrones de confiabilidad y planificacion determinista de estrategias de envio."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].content",
          "englishWordCount": 564,
          "excerpt": "# Why DeFi transacciones fail: CU limits, size, y blockhash expiry DeFi transacciones on Solana fail para three primary reasons: compute budget exhaustion, transaccion size overflow, y blockhash expiry. Understanding eac..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "Solana allocates 200,000 CUs by default. DeFi transacciones almost always need more, requiring an explicit SetComputeUnitLimit instruccion."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Expired blockhash transacciones are never processed y produce no on-chain record. The client must detect the timeout y resubmit con a fresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].content",
          "englishWordCount": 463,
          "excerpt": "# Compute budget instrucciones y priority fee strategy The Compute Budget Program provides two critical instrucciones that every serious DeFi transaccion should include: `SetComputeUnitLimit` y `SetComputeUnitPrice`. Tog..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Cuenta state may change between simulation y execution, causing minor CU variations. A 10% margin absorbs these differences."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].content",
          "englishWordCount": 462,
          "excerpt": "# Transaccion cost estimation y fee planning Accurate fee estimation is the foundation of a good DeFi user experience. Users need to know what a transaccion will cost before they sign it. Validadores need sufficient fees..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].content",
          "englishWordCount": 79,
          "excerpt": "# Challenge: Build a transaccion plan con compute budgeting Build a transaccion planning function that analyzes a set of instrucciones y produces a complete transaccion plan: - Sum estimatedCU from all instrucciones y ad..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Planificacion de Address Lookup Table, patrones de confiabilidad/retry, UX de errores accionables y reportes completos de estrategia de envio."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].content",
          "englishWordCount": 97,
          "excerpt": "# Challenge: Plan Address Lookup Table usage Build a function that determines the optimal Address Lookup Table strategy para a transaccion: - Collect all unique cuenta keys across instrucciones - Check which keys exist i..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].content",
          "englishWordCount": 550,
          "excerpt": "# Reliability patterns: retry, re-quote, resend vs rebuild Production DeFi applications must handle transaccion failures gracefully. The difference between a frustrating y a reliable experience comes down to retry strate..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "Rebuilding is necessary when the transaccion's blockhash is stale or when on-chain state has changed (e.g., slippage exceeded). Simple network issues only require resending the same bytes."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "englishWordCount": 12,
          "excerpt": "To prevent many clients from retrying at the exact same moment y overwhelming the network"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].content",
          "englishWordCount": 586,
          "excerpt": "# UX: actionable error messages para transaccion failures Raw Solana error messages are cryptic. \"Transaccion simulation failed: Error processing Instruccion 2: custom program error: 0x1771\" tells a developer something b..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].content",
          "englishWordCount": 89,
          "excerpt": "# Checkpoint: Generate a send strategy report Build the final send strategy report that combines all curso concepts into a comprehensive transaccion optimization plan: - Build a tx plan: sum CU estimates con 10% margin (..."
        },
        {
          "path": "courses.solana-mobile-signing.description",
          "englishWordCount": 19,
          "excerpt": "Domina la firma de wallets moviles en Solana para produccion: sesiones Android MWA, restricciones de deep links en iOS, reintentos resilientes y telemetria determinista de sesion."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Restricciones de plataforma, patrones UX de conexion, comportamiento de timeline de firma y construccion tipada de requests en Android/iOS."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].content",
          "englishWordCount": 709,
          "excerpt": "# Mobile signing reality check: Android vs iOS constraints Mobile cartera signing on Solana is fundamentally different from browser-based cartera interactions. The constraints imposed by Android y iOS operating systems s..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "Android MWA uses foreground services to maintain a persistent communication channel between the dApp y cartera, enabling multi-request sessions without app switching."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].content",
          "englishWordCount": 715,
          "excerpt": "# Cartera connection UX patterns: connect, reconnect, y recovery Cartera connection on mobile is the first interaction users have con your dApp. A smooth connection flow builds trust; a broken one drives users away. This..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "Network mismatches should be communicated clearly to the user con instrucciones on how to resolve them, avoiding confusing silent failures."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].content",
          "englishWordCount": 667,
          "excerpt": "# Signing session timeline: request, cartera, y response flow Understanding the complete lifecycle of a mobile signing request is essential para building reliable dApps. Every sign request passes through multiple stages,..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].content",
          "englishWordCount": 70,
          "excerpt": "# Challenge: Build a typed sign request Implement a sign request builder para Mobile Cartera Adapter: - Validate the payload type (transaccion or message) - Validate payload data (base64 para transacciones, non-empty str..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[2]",
          "englishWordCount": 13,
          "excerpt": "App identity requires at least name y URI. Icon is optional but should default to empty string."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Persistencia de sesion, seguridad en pantallas de revision, maquinas de estado de retry y reportes deterministas de sesion para apps moviles en produccion."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].content",
          "englishWordCount": 59,
          "excerpt": "# Challenge: Session persistence y restoration Implement a session persistence manager para mobile cartera sessions: - Process a sequence of actions: save, restore, clear, y expire_check - Track cartera address y last si..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].content",
          "englishWordCount": 632,
          "excerpt": "# Mobile transaccion review: what users need to see Transaccion review screens are the last line of defense between a user y a potentially harmful transaccion. On mobile, screen real estate is limited y user attention is..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 17,
          "excerpt": "Token amounts must be converted to human-readable format using the token's decimal configuration y include the symbol para clarity."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Balance change summaries (e.g., -1.5 SOL, +150 USDC) are the most user-friendly way to communicate what a transaccion will do."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].content",
          "englishWordCount": 710,
          "excerpt": "# One-tap retry: handling offline, rejected, y timeout states Mobile environments are inherently unreliable. Users move between WiFi y cellular, enter tunnels, close apps mid-transaccion, y carteras crash. A robust retry..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].content",
          "englishWordCount": 59,
          "excerpt": "# Checkpoint: Generate a session report Implement a session report generator that summarizes a complete mobile signing session: - Count total requests, successful signs, y failed signs - Sum retry attempts across all req..."
        },
        {
          "path": "courses.solana-pay-commerce.description",
          "englishWordCount": 16,
          "excerpt": "Domina la integracion comercial de Solana Pay: encoding robusto de URLs, flujos de tracking QR y pagos, UX de confirmacion y artefactos deterministas de conciliacion POS."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Especificacion de Solana Pay, rigor de encoding de URL, anatomia de transfer requests y patrones deterministas de builder/encoder."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].content",
          "englishWordCount": 589,
          "excerpt": "# Solana Pay modelo mental y URL encoding rules Solana Pay is an open specification para encoding payment requests into URLs that carteras can parse y execute. Unlike traditional payment processors that rely on centraliz..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "The Solana Pay specification uses the 'solana:' scheme followed immediately by the recipient address con no slashes."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Transaccion requests allow the server to build arbitrarily complex transacciones. Transfer requests only support simple single-token transfers."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].content",
          "englishWordCount": 631,
          "excerpt": "# Transfer request anatomy: recipient, amount, reference, y labels A Solana Pay transfer request URL contains everything a cartera needs to construct y submit a payment transaccion. Each component of the URL serves a spe..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 22,
          "excerpt": "The reference public key is included as a non-signer cuenta in the transfer instruccion. The merchant polls getSignaturesForAddress(reference) to detect when the payment transaccion confirms."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 20,
          "excerpt": "Solana Pay URLs use human-readable decimal amounts. The cartera handles the conversion to raw units based on the token's decimal configuration."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].content",
          "englishWordCount": 473,
          "excerpt": "# URL builder: live preview of Solana Pay URLs Building Solana Pay URLs correctly requires understanding how each parameter contributes to the final encoded string. In this leccion, we walk through the construction proce..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].content",
          "englishWordCount": 73,
          "excerpt": "# Challenge: Encode a Solana Pay transfer request URL Build a function that encodes a Solana Pay transfer request URL from input parameters: - Validate the recipient address (must be 32-44 characters of valid base58) - V..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Maquinas de estado de tracking por reference, UX de confirmacion, manejo de fallos y generacion determinista de recibos POS."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].content",
          "englishWordCount": 84,
          "excerpt": "# Challenge: Track payment references through confirmation states Build a reference tracking state machine that processes payment events: - States flow: pending -> found -> confirmed -> finalized (or pending -> expired) ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].content",
          "englishWordCount": 644,
          "excerpt": "# Confirmation UX: pending, confirmed, y expired states The user experience during payment confirmation is the most critical moment in any Solana Pay integration. Between the customer scanning the QR code y the merchant ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "englishWordCount": 13,
          "excerpt": "Confirmed is sufficient para low-value POS transacciones; finalized is needed para irreversible digital fulfillment"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "Para coffee-shop-scale payments, confirmed commitment provides a strong enough guarantee. Finalized adds 6-12 seconds of latency y is only necessary when fulfillment is irreversible."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 22,
          "excerpt": "Expired requests should be clearly communicated. The customer may have been in the middle of approving — they need to know the request expired y can try again."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].content",
          "englishWordCount": 698,
          "excerpt": "# Error handling y edge cases in payment flows Production payment systems encounter a wide range of failure modes that must be handled gracefully. Solana Pay integrations face challenges unique to blockchain payments: ne..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].content",
          "englishWordCount": 78,
          "excerpt": "# Checkpoint: Generate a POS receipt Build the final POS receipt generator that combines all curso concepts: - Reconstruct the Solana Pay URL from payment data (recipient, amount, spl-token, reference, label) - Generate ..."
        },
        {
          "path": "courses.wallet-ux-engineering.description",
          "englishWordCount": 16,
          "excerpt": "Domina la ingenieria UX de wallets en Solana para produccion: estado de conexion determinista, seguridad de red, resiliencia RPC y patrones de confiabilidad medibles."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Diseno de conexion de wallet, network gating y arquitectura determinista de maquina de estados para onboarding y reconexion predecibles."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].content",
          "englishWordCount": 701,
          "excerpt": "# Connection UX that doesn't suck: a diseno checklist Cartera connection is the first interaction a user has con any Solana dApp. If this experience is slow, confusing, or error-prone, most users will leave before they e..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 18,
          "excerpt": "Skeleton UI reserves the layout space para cartera-dependent content, preventing jarring shifts when the connection resolves y data loads."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].content",
          "englishWordCount": 715,
          "excerpt": "# Network gating y wrong-network recovery Solana has multiple clusters: mainnet-beta, devnet, testnet, y localnet. Unlike EVM chains where the cartera controls the network y emits chain-change events, Solana's network se..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 31,
          "excerpt": "Each Solana cluster has a unique genesis hash. Comparing the RPC's genesis hash against known values is the only reliable detection method, since URL strings can be misleading y carteras don't always expose network info."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "While cuenta addresses are identical across clusters, the cuenta states (balances, data, existence) are completely different. All cached RPC data must be cleared on network switch."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].content",
          "englishWordCount": 605,
          "excerpt": "# Connection state machine: states, events, y transitions Cartera connection logic in most dApps is implemented as a tangle of boolean flags, useEffect hooks, y conditional renders. This approach leads to impossible stat..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].content",
          "englishWordCount": 73,
          "excerpt": "# Challenge: Implement cartera connection state machine Build a deterministic state machine para cartera connection management: - States: disconnected, connecting, connected, error - Process a sequence of events y track ..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Invalidacion de cache, resiliencia y monitoreo de salud RPC, y reportes medibles de calidad UX de wallet para operaciones en produccion."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].content",
          "englishWordCount": 85,
          "excerpt": "# Challenge: Cache invalidation on cartera events Build a cache invalidation engine that processes cartera events y invalidates the correct cache entries: - Cache entries have tags: \"cuenta\" (cartera-specific data), \"net..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].content",
          "englishWordCount": 686,
          "excerpt": "# RPC reads y caching strategy para cartera apps Every interaction in a Solana cartera application ultimately depends on RPC calls: fetching balances, loading token cuentas, reading program state, y confirming transaccio..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "englishWordCount": 12,
          "excerpt": "Cuenta states differ across clusters, so cached devnet data would be wrong para mainnet"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 26,
          "excerpt": "The same cuenta address can have completely different state on mainnet vs devnet. Without the network in the key, switching clusters would return stale data from the previous cluster."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "SWR prioritizes responsiveness by serving stale data instantly while refreshing in the background. This eliminates loading states para data that has only slightly exceeded its TTL."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].content",
          "englishWordCount": 859,
          "excerpt": "# RPC health monitoring y graceful degradation RPC endpoints are the lifeline of every Solana cartera application. When they go down, become slow, or return stale data, your app becomes unusable. Production cartera apps ..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].content",
          "englishWordCount": 74,
          "excerpt": "# Checkpoint: Generate a Cartera UX Report Build the final cartera UX quality report that combines all curso concepts: - Count connection attempts (CONNECT events) y successful connections (CONNECTED events) - Calculate ..."
        },
        {
          "path": "courses.sign-in-with-solana.description",
          "englishWordCount": 20,
          "excerpt": "Domina la autenticacion SIWS en Solana para produccion: entradas estandarizadas, invariantes estrictas de verificacion, ciclo de vida de nonce resistente a replay y reportes listos para auditoria."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Razon de SIWS, semantica estricta de campos de entrada, comportamiento de render en wallets y construccion determinista de sign-in input."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].content",
          "englishWordCount": 806,
          "excerpt": "# Why SIWS exists: replacing connect-y-signMessage Before Sign-In Con Solana (SIWS) became a standard, dApps authenticated cartera holders using a two-step pattern: connect the cartera, then call `signMessage` con an arb..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 25,
          "excerpt": "Without structured format, carteras treat signMessage payloads as opaque bytes y cannot validate or warn about the content, making it easy para malicious dApps to disguise harmful payloads as sign-in requests."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "The server generates a unique nonce para each sign-in attempt. After successful verification, the nonce is marked as consumed. Any reuse of the same nonce is rejected as a replay attack."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].content",
          "englishWordCount": 826,
          "excerpt": "# SIWS input fields y seguridad rules The Sign-In Con Solana input is a structured object that defines every parameter of an authentication request. Each field has specific validation rules, seguridad implications, y ren..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "If the client generates nonces, an attacker can replay a previously captured nonce-signature pair. Server-generated nonces ensure each authentication attempt is unique y controlled by the server."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "The domain field must be a plain domain name. Protocol prefixes, paths, ports, y query strings must be rejected to ensure consistent domain matching."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[2].content",
          "englishWordCount": 818,
          "excerpt": "# Message preview: how carteras render SIWS requests When a dApp sends a SIWS sign-in request to a cartera, the cartera transforms the structured input into a human-readable message that the user sees on the approval scr..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].content",
          "englishWordCount": 69,
          "excerpt": "# Challenge: Build a validated SIWS sign-in input Implement a function that creates a validated Sign-In Con Solana input: - Validate domain (non-empty, must not include protocol prefix) - Validate nonce (at least 8 chara..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Invariantes de verificacion server-side, defensas nonce contra replay, gestion de sesiones y reportes deterministas de auditoria de autenticacion."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].content",
          "englishWordCount": 59,
          "excerpt": "# Challenge: Verify a SIWS sign-in response Implement server-side verification of a SIWS sign-in output: - Check domain matches expected domain - Check nonce matches expected nonce - Check issuedAt is not in the future r..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].content",
          "englishWordCount": 791,
          "excerpt": "# Sessions y logout: what to store y what not to store After a successful SIWS sign-in verification, the server must establish a session so the user does not need to re-authenticate on every request. Session management p..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 30,
          "excerpt": "Cartera addresses are publicly known. Using them as session IDs would allow anyone who knows a user's address to impersonate their session. Random tokens ensure only the authenticated client can present a valid session."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 22,
          "excerpt": "Cartera disconnection signals the user's intent to end the interaction. The dApp should respect this by invalidating the session, preventing confusion about authentication state."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].content",
          "englishWordCount": 881,
          "excerpt": "# Replay protection y nonce registry diseno Replay attacks are the most critical threat to any signature-based authentication system. In a replay attack, an adversary captures a valid signed message y submits it again to..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].content",
          "englishWordCount": 80,
          "excerpt": "# Checkpoint: Generate an auth audit report Build the final auth audit report that combines all curso concepts: - Process an array of authentication attempts con address, nonce, y verified status - Track used nonces to d..."
        },
        {
          "path": "courses.priority-fees-compute-budget.description",
          "englishWordCount": 15,
          "excerpt": "Ingenieria defensiva de fees en Solana con planificacion determinista de compute, politica adaptativa de prioridad y contratos de confiabilidad UX orientados a confirmacion."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Mecanicas de inclusion, acoplamiento compute/fee y diseno de politicas guiado por explorer con enfoque determinista de confiabilidad."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].content",
          "englishWordCount": 587,
          "excerpt": "# Fee markets on Solana: what actually moves inclusion Priority fees on Solana are often explained as a simple slider, but production systems need a more precise model. Inclusion is influenced by contention para compute,..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "A large CU request con weak price can lose inclusion, while aggressive price on oversized CU can overpay."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].content",
          "englishWordCount": 542,
          "excerpt": "# Compute budget fundamentos y common failure modes Most transaccion failures blamed on \"network issues\" are actually planning errors in compute budget y payload sizing. A defensive client treats compute planning as a de..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[2].content",
          "englishWordCount": 465,
          "excerpt": "# Explorer: compute budget planner inputs to plan Explorers are useful only when they expose policy tradeoffs clearly. Para a fee y compute planner, that means visualizing how input estimates, percentile targets, y confi..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implementar planners deterministas, motores de politica de confirmacion y artefactos estables de estrategia de fees para revision de release."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].content",
          "englishWordCount": 12,
          "excerpt": "Implement policy-based priority fee estimation using synthetic sample arrays y deterministic warnings."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[2].content",
          "englishWordCount": 12,
          "excerpt": "Encode confirmation UX policy para processed, confirmed, y finalized states using deterministic risk bands."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].content",
          "englishWordCount": 15,
          "excerpt": "Build stable markdown output para a fee strategy summary that users y support teams can review quickly."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[4].content",
          "englishWordCount": 12,
          "excerpt": "Produce a deterministic checkpoint report JSON para the Fee Optimizer final project artifact."
        },
        {
          "path": "courses.bundles-atomicity.description",
          "englishWordCount": 17,
          "excerpt": "Disena flujos defensivos multi-transaccion en Solana con validacion determinista de atomicidad, modelado de compensaciones y reportes de seguridad listos para auditoria."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Modelo de atomicidad, riesgos de flujos multi-transaccion y validacion defensiva de seguridad para proteger expectativas del usuario."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].content",
          "englishWordCount": 525,
          "excerpt": "# Atomicity concepts y why users assume all-or-nothing Users rarely think in transaccion graphs. They think in intents: \"swap my token\" or \"close my position.\" When a workflow spans multiple transacciones, user expectati..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].content",
          "englishWordCount": 503,
          "excerpt": "# Multi-transaccion flows: approvals, ATA creation, swaps, refunds A reliable flow simulator must encode where partial execution risk lives. In practice, risk points cluster at boundaries: before value transfer, during v..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[2].content",
          "englishWordCount": 463,
          "excerpt": "# Explorer: flow graph steps y risk points Flow graph explorers are most valuable when they highlight risk semantics, not just sequence order. A defensive explorer should display each step con dependency context, idempot..."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implementar validadores deterministas de atomicidad, patrones de manejo de fallos y composicion estable de bundles para revision de release."
        },
        {
          "path": "courses.mempool-ux-defense.description",
          "englishWordCount": 16,
          "excerpt": "Ingenieria defensiva de UX para swaps con gradacion de riesgo determinista, politicas de slippage acotadas y comunicacion de seguridad lista para incidentes."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Riesgos entre quote y ejecucion, guardrails de slippage y decisiones de frescura para swaps mas seguros en produccion."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].content",
          "englishWordCount": 530,
          "excerpt": "# What can go wrong between quote y execution A swap quote is a prediction, not a guarantee. Between quote generation y execution, liquidity changes, competing orders land, y network conditions shift. Users often assume ..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[1].content",
          "englishWordCount": 482,
          "excerpt": "# Slippage controls y guardrails Slippage settings are a policy surface, not a cosmetic preference. Defensive swap UX defines explicit bounds, context-aware defaults, y clear consequences when users attempt risky overrid..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[2].content",
          "englishWordCount": 448,
          "excerpt": "# Explorer: quote freshness timer y decision table A quote freshness explorer should make policy behavior obvious under time pressure. Users y engineers need to see when a quote transitions from safe to warning to blocke..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[0].content",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic swap risk grading from quote, slippage, impact, hops, y liquidity inputs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.description",
          "englishWordCount": 15,
          "excerpt": "Construye pipelines deterministas de indexacion en produccion con ingesta segura ante duplicados, manejo de reorg e informes centrados en integridad."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].content",
          "englishWordCount": 509,
          "excerpt": "# Indexing 101: logs, cuentas, y transaccion parsing Reliable indexers are not just fast parsers. They are consistency systems that decide what to trust, when to trust it, y how to recover from changing chain history. On..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[1].content",
          "englishWordCount": 457,
          "excerpt": "# Reorgs y fork choice: why confirmed is not finalized Confirmation labels are useful but often misunderstood in indexing pipelines. A confirmed event has stronger confidence than processed, but it is not equivalent to f..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[2].content",
          "englishWordCount": 462,
          "excerpt": "# Explorer: ingest to dedupe to confirm to apply A pipeline explorer should explain transformation stages clearly so engineers can inspect where correctness can break. Para indexing reliability, the core stages are inges..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implementar logica de confirmaciones, planeacion de backfill/idempotencia y chequeos de integridad para reportes de pipeline estables."
        },
        {
          "path": "courses.rpc-reliability-latency.description",
          "englishWordCount": 15,
          "excerpt": "Disena clientes RPC multi-proveedor en Solana para produccion con politicas deterministas de retry, routing, cache y observabilidad."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Real-world RPC failure behavior, endpoint selection strategy, y deterministic retry policy modeling."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].content",
          "englishWordCount": 520,
          "excerpt": "# RPC failures in real life: timeouts, 429s, stale nodes Reliable client infrastructure begins con realistic failure assumptions. RPC calls fail para many reasons: transient network timeouts, provider rate limits, stale ..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].content",
          "englishWordCount": 430,
          "excerpt": "# Multi-endpoint strategies: hedged requests y fallbacks Multi-endpoint diseno is more than adding a backup URL. It is a scheduling problem where each request should be sent to the most suitable endpoint given recent hea..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].content",
          "englishWordCount": 460,
          "excerpt": "# Explorer: retry/backoff simulator Retry y backoff policies determine whether clients recover gracefully or amplify outages. A simulator should make schedule behavior explicit so teams can reason about user latency y pr..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Build deterministic policy engines para routing, retries, metrics reduction, y health report exports."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].content",
          "englishWordCount": 12,
          "excerpt": "Export deterministic JSON y markdown health report artifacts para multi-provider reliability review."
        },
        {
          "path": "courses.rust-data-layout-borsh.description",
          "englishWordCount": 18,
          "excerpt": "Ingenieria de layout de datos en Solana con enfoque Rust y tooling determinista a nivel de bytes, junto con practicas de esquema seguras para compatibilidad."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Alignment behavior, Borsh encoding rules, y practico parsing safety para stable byte-level contracts."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].content",
          "englishWordCount": 555,
          "excerpt": "# Memory layout: alignment, padding, y why Solana cuentas care Rust layout behavior is deterministic inside one compiled binary but can vary when assumptions are implicit. Para Solana cuentas, this matters because raw by..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].content",
          "englishWordCount": 492,
          "excerpt": "# Struct y enum layout pitfalls plus Borsh rules Borsh is widely used because it gives deterministic serialization across languages, but teams still get tripped up by how enums, vectors, y strings map to bytes. Understan..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[2].content",
          "englishWordCount": 443,
          "excerpt": "# Explorer: layout visualizer para field offsets A layout visualizer turns abstract alignment rules into concrete numbers engineers can review. Instead of debating whether a struct is \"probably fine,\" teams can inspect e..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic layout analysis, encoding/decoding, safe parsing, y compatibility-focused reporting helpers."
        },
        {
          "path": "courses.rust-errors-invariants.description",
          "englishWordCount": 19,
          "excerpt": "Construye librerias de guardas por invariantes tipadas con artefactos de evidencia determinista, contratos de error seguros para compatibilidad y reportes listos para auditoria."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].content",
          "englishWordCount": 536,
          "excerpt": "# Error taxonomy: recoverable vs fatal Rust encourages explicit error modeling, but teams still produce weak error contracts when they rely on ad hoc strings or inconsistent wrappers. In Solana y Anchor-adjacent systems,..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[1].content",
          "englishWordCount": 513,
          "excerpt": "# Result<T, E> patterns, ? operator, y context Result-based control flow is one of Rust's strongest tools para building robust services y on-chain-adjacent clients. The key is not merely using Result, but designing error..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].content",
          "englishWordCount": 452,
          "excerpt": "# Explorer: invariant decision tree An invariant decision tree helps teams reason about guard ordering y failure priority. Not every invariant should be checked in arbitrary order. Early checks should prevent expensive w..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement guard helpers, evidence-chain generation, y stable audit reporting para reliability y incident response."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.description",
          "englishWordCount": 15,
          "excerpt": "Simula y optimiza comportamiento de costo de compute con tooling determinista Rust-first y gobernanza de rendimiento guiada por presupuesto."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Rust rendimiento modelo mentals, data-structure tradeoffs, y deterministic cost reasoning para reliable optimization decisions."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].content",
          "englishWordCount": 493,
          "excerpt": "# Rendimiento modelo mental: allocations, clones, hashing Rust rendimiento work in Solana ecosystems is mostly about data movement discipline. Teams often chase micro-optimizations while ignoring dominant costs such as r..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].content",
          "englishWordCount": 472,
          "excerpt": "# Data structures: Vec, HashMap, BTreeMap tradeoffs Data structure choice is one of the highest leverage rendimiento decisions in Rust systems. Vec offers compact contiguous storage y predictable iteration speed. HashMap..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].content",
          "englishWordCount": 451,
          "excerpt": "# Explorer: cost model sandbox A cost sandbox lets teams test optimization hypotheses without waiting para full benchmark infrastructure. Provide operation counts, compute weighted costs, y inspect which buckets dominate..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.description",
          "englishWordCount": 16,
          "excerpt": "Ingenieria de pipelines async con enfoque Rust-first y concurrencia acotada, reducers seguros ante replay y reportes operativos deterministas."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].content",
          "englishWordCount": 501,
          "excerpt": "# Async fundamentals: futures, tasks, channels Rust async systems are built on explicit scheduling rather than implicit thread-per-task models. Futures represent pending work, executors poll futures, y channels coordinat..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[1].content",
          "englishWordCount": 446,
          "excerpt": "# Concurrency limits y backpressure Backpressure is not optional in high-volume pipelines. Without it, producer speed can overwhelm reducers, retries, or storage sinks. A resilient diseno sets explicit concurrency caps y..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[2].content",
          "englishWordCount": 465,
          "excerpt": "# Explorer: pipeline graph y concurrency Pipeline graphs help teams communicate stage boundaries, concurrency budgets, y retry behaviors. A graph that shows ingest, dedupe, retry, y snapshot stages con explicit capacitie..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implement deterministic scheduling, retries, dedupe/reducer stages, y report exports para reorg-safe pipeline operations."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.description",
          "englishWordCount": 16,
          "excerpt": "Seguridad de macros y codegen en Rust ensenada mediante parser determinista y tooling de generacion de chequeos con salidas amigables para auditoria."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].content",
          "englishWordCount": 489,
          "excerpt": "# Macro modelo mental: declarative vs procedural Rust macros come in two broad forms: declarative macros para pattern-based expansion y procedural macros para syntax-aware transformation. Anchor relies heavily on macro-d..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].content",
          "englishWordCount": 455,
          "excerpt": "# Safety through codegen: constraint checks Constraint codegen converts compact declarations into explicit runtime guards. Typical constraints include signer presence, cuenta ownership, has-one relations, y mutability re..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].content",
          "englishWordCount": 451,
          "excerpt": "# Explorer: constraint builder to generated checks A constraint builder explorer helps engineers see how DSL choices affect generated code y runtime safety outcomes. Input one attribute line, observe parsed AST, generate..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Parse DSL constraints, generate checks, run deterministic evaluations, y publish stable safety reports."
        },
        {
          "path": "courses.anchor-upgrades-migrations.description",
          "englishWordCount": 17,
          "excerpt": "Disena flujos de release seguros para produccion en Anchor con planificacion determinista de migraciones, gates de upgrade, playbooks de rollback y evidencia de readiness."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Authority lifecycle, cuenta versioning strategy, y deterministic upgrade risk modeling para Anchor releases."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].content",
          "englishWordCount": 552,
          "excerpt": "# Upgrade authority lifecycle in Anchor programs Anchor makes instruccion development easier, but upgrade safety still depends on disciplined control of program authority. In production Solana systems, most upgrade incid..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[1].content",
          "englishWordCount": 504,
          "excerpt": "# Cuenta versioning y migration strategy Solana cuentas are long-lived state containers, so program upgrades must respect historical data. In Anchor, adding or changing cuenta fields can be safe, risky, or catastrophic d..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].content",
          "englishWordCount": 453,
          "excerpt": "# Explorer: upgrade risk matrix A useful upgrade explorer should show cause-y-effect between release inputs y safety outcomes. If a flag changes, engineers should immediately see how severity y readiness changes. This le..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Safety validation gates, rollback planning, y deterministic readiness artifacts para controlled migration execution."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].content",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic blocking issue checks para authority, artifact hash, y dry-run status."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].content",
          "englishWordCount": 450,
          "excerpt": "# Rollback strategy y incident playbooks Even strong upgrade plans can encounter surprises: incompatible downstream clients, unexpected cuenta edge cases, or release pipeline mistakes. Teams that recover quickly are the ..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].content",
          "englishWordCount": 14,
          "excerpt": "Produce the final deterministic checkpoint artifact con release tag, readiness flag, y migration batch count."
        },
        {
          "path": "courses.solana-reliability.description",
          "englishWordCount": 19,
          "excerpt": "Ingenieria de confiabilidad enfocada en produccion para sistemas Solana: tolerancia a fallos, retries, deadlines, circuit breakers y degradacion gradual con resultados operativos medibles."
        },
        {
          "path": "courses.solana-reliability.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Implement fault-tolerance building blocks con clear failure classification, retry boundaries, y deterministic recovery behavior."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[0].content",
          "englishWordCount": 221,
          "excerpt": "Fault tolerance in Solana systems is not just about catching errors. It is about deciding which failures are safe to retry, which should fail fast, y how to preserve user trust while doing both. A practico reliability mo..."
        },
        {
          "path": "courses.solana-reliability.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Build resilience mechanisms (circuit breakers, bulkheads, y rate controls) that protect core user flows during provider instability."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[0].content",
          "englishWordCount": 187,
          "excerpt": "Resilience patterns are controls that prevent localized failures from becoming system-wide incidents. On Solana integrations, they are especially important because provider health can change quickly under bursty network ..."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].content",
          "englishWordCount": 13,
          "excerpt": "Implement a circuit breaker pattern that opens after consecutive failures y closes after a recovery period."
        },
        {
          "path": "courses.solana-testing-strategies.description",
          "englishWordCount": 19,
          "excerpt": "Estrategia integral de testing para Solana orientada a produccion: pruebas unitarias deterministas, integraciones realistas, fuzz/property testing y reportes de confianza para release."
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Build deterministic unit y integration pruebas layers con clear ownership of invariants, fixtures, y failure diagnostics."
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[0].content",
          "englishWordCount": 160,
          "excerpt": "Pruebas Solana systems effectively requires layered confidence, not one giant test suite. Unit tests validate pure logic: math, state transitions, y invariant checks. They should be fast, deterministic, y run on every ch..."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Use fuzzing, property-based tests, y mutation-style checks to expose edge-case failures before release."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[0].content",
          "englishWordCount": 156,
          "excerpt": "Avanzado pruebas techniques uncover failures that example-based tests rarely find. Fuzzing explores broad random input space to trigger parser edge cases, boundary overflows, y unexpected state combinations. It is especi..."
        },
        {
          "path": "courses.solana-program-optimization.description",
          "englishWordCount": 16,
          "excerpt": "Disena rendimiento de nivel produccion en Solana: compute budgeting, eficiencia de layout de cuentas, tradeoffs de memoria/rent y workflows de optimizacion deterministas."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Optimize compute-heavy paths con explicit CU budgets, operation-level profiling, y predictable rendimiento tradeoffs."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Compute units are the hard resource budget that shapes what your Solana program can do in a single transaccion. Rendimiento optimization starts by treating CU usage as a contract, not an afterthought. A reliable optimiza..."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Diseno memory/storage-efficient cuenta layouts con rent-aware sizing, serialization discipline, y safe migration planning."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[0].content",
          "englishWordCount": 96,
          "excerpt": "Cuenta data optimization is both a cost y correctness discipline. Poor layouts increase rent, slow parsing, y make migrations fragile. Diseno principles: - Keep hot fields compact y easy to parse. - Use fixed-size repres..."
        },
        {
          "path": "courses.solana-tokenomics-design.description",
          "englishWordCount": 16,
          "excerpt": "Disena economias de token robustas en Solana con disciplina de distribucion, seguridad de vesting, incentivos de staking y mecanicas de gobernanza defendibles operativamente."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Model token allocation y vesting systems con explicit fairness, unlock predictability, y deterministic accounting rules."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[0].content",
          "englishWordCount": 93,
          "excerpt": "Token distribution is a seguridad y credibility decision, not just a spreadsheet exercise. Allocation y vesting rules shape long-term trust in the protocol. A strong distribution model answers: - who receives tokens y wh..."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Diseno staking y gobernanza mechanics con clear incentive alignment, anti-manipulation constraints, y measurable participation health."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[0].content",
          "englishWordCount": 93,
          "excerpt": "Staking y gobernanza systems must balance participation incentives con manipulation resistance. Rewarding lock behavior is useful, but poorly tuned models can over-concentrate influence. Core diseno questions: 1) How is ..."
        },
        {
          "path": "courses.solana-defi-primitives.description",
          "englishWordCount": 17,
          "excerpt": "Construye fundamentos practicos de DeFi en Solana: mecanicas AMM, contabilidad de liquidez, primitivas de lending y patrones de composicion seguros ante flash loans."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Implement AMM y liquidity primitives con deterministic math, slippage-aware outputs, y LP accounting correctness."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[0].content",
          "englishWordCount": 96,
          "excerpt": "AMM fundamentals are simple in formula but subtle in implementation quality. The invariant math must be deterministic, fee handling explicit, y rounding behavior consistent across paths. Para constant-product pools, rout..."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Model lending y flash-loan flows con collateral safety, utilization-aware pricing, y strict repayment invariants."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[0].content",
          "englishWordCount": 85,
          "excerpt": "Lending primitives y flash-loan logic are powerful but unforgiving. Safety depends on strict collateral valuation, clear LTV/threshold rules, y deterministic repayment checks. A practico lending model should define: - co..."
        },
        {
          "path": "courses.solana-nft-standards.description",
          "englishWordCount": 16,
          "excerpt": "Implementa NFTs de Solana con estandares listos para produccion: integridad de metadata, disciplina de colecciones y comportamientos avanzados programables/no transferibles."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build core NFT functionality con standards-compliant metadata, collection verification, y deterministic asset-state handling."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[0].content",
          "englishWordCount": 78,
          "excerpt": "NFT architecture on Solana combines token mechanics con metadata y collection semantics. A correct implementation requires more than minting a token con supply one. Core components include: - mint/state ownership correct..."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implement avanzado NFT behaviors (soulbound y programmable flows) con explicit policy controls y safe update semantics."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[0].content",
          "englishWordCount": 72,
          "excerpt": "Avanzado NFT features introduce policy complexity that must be explicit. Soulbound behavior, programmable restrictions, y dynamic metadata updates all expand failure surface. Para soulbound models, non-transferability mu..."
        },
        {
          "path": "courses.solana-cpi-patterns.description",
          "englishWordCount": 16,
          "excerpt": "Domina la composicion CPI en Solana con validacion segura de cuentas, disciplina de firmantes PDA y patrones deterministas de orquestacion multi-programa."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build CPI fundamentals con strict cuenta/signer checks, ownership validation, y safe PDA signing boundaries."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[0].content",
          "englishWordCount": 86,
          "excerpt": "Invocacion entre Programas (CPI) is where Solana composability becomes practico y where many seguridad failures appear. The caller controls cuenta lists, so every CPI boundary must be treated as untrusted input. Safe CPI..."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Compose avanzado multi-program flows con atomicity awareness, consistency checks, y deterministic failure handling."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[0].content",
          "englishWordCount": 88,
          "excerpt": "Multi-program composition introduces sequencing y consistency risk. Even when each CPI call is correct in isolation, combined flows can violate business invariants if ordering or rollback assumptions are weak. Robust com..."
        },
        {
          "path": "courses.solana-mev-strategies.description",
          "englishWordCount": 20,
          "excerpt": "Ingenieria enfocada en produccion para ordenamiento de transacciones en Solana: routing consciente de MEV, estrategia de bundles, modelado de liquidacion/arbitraje y controles de ejecucion que protegen al usuario."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Understand MEV mechanics y transaccion ordering realities, then model opportunities y risks con deterministic safety-aware policies."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[0].content",
          "englishWordCount": 162,
          "excerpt": "Maximal Extractable Value (MEV) on Solana is fundamentally about transaccion ordering under limited blockspace. Whether you are building trading tools, liquidation infrastructure, or user-facing apps, you need a realisti..."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Diseno avanzado ordering/bundle strategies con explicit risk controls, failure handling, y user-impact guardrails."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[0].content",
          "englishWordCount": 123,
          "excerpt": "Avanzado transaccion-ordering strategies require disciplined orchestration, not just faster opportunity scans. Bundle-oriented execution is valuable because it can express dependency sets y all-or-nothing intent, but bun..."
        },
        {
          "path": "courses.solana-deployment-cicd.description",
          "englishWordCount": 17,
          "excerpt": "Ingenieria de despliegue para produccion en programas Solana: estrategia de entornos, gates de release, controles de calidad CI/CD y flujos operativos seguros para upgrades."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Model environment-specific despliegue behavior con deterministic configs, artifact checks, y release preflight validation."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[0].content",
          "englishWordCount": 132,
          "excerpt": "Solana despliegue is not one command; it is a release system con environment-specific risk. Localnet, devnet, y mainnet each serve different validation goals, y production quality depends on using them intentionally. A r..."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Build CI/CD pipelines that enforce build/test/seguridad gates, compatibility checks, y controlled rollout/rollback evidence."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[0].content",
          "englishWordCount": 116,
          "excerpt": "CI/CD para Solana should enforce release quality, not just automate command execution. A practico pipeline includes staged gates: 1) static quality gate (lint/type/seguridad checks), 2) deterministic unit/integration tes..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.description",
          "englishWordCount": 19,
          "excerpt": "Construye integraciones cross-chain mas seguras en Solana con mensajeria estilo Wormhole, verificacion de attestations y controles deterministas del estado del bridge."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].content",
          "englishWordCount": 133,
          "excerpt": "Cross-chain messaging is a trust-boundary problem before it is a transport problem. In Wormhole-style systems, messages are observed, attested, y consumed across different chain environments, each con independent failure..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement asset-bridging patterns con strict supply/accounting invariants, replay protection, y reconciliation workflows."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Token bridging requires strict supply y state invariants. Lock-y-mint y burn-y-mint models both rely on one central rule: represented supply across chains must remain coherent. Critical controls include: - single-consume..."
        },
        {
          "path": "courses.solana-oracle-pyth.description",
          "englishWordCount": 18,
          "excerpt": "Integra feeds de oraculos en Solana de forma segura: validacion de precios, politicas de confianza/staleness y agregacion multi-fuente para decisiones de protocolo resilientes."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand oracle data semantics (price, confidence, staleness) y enforce deterministic validation before business logic."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[0].content",
          "englishWordCount": 110,
          "excerpt": "Oracle integration is a risk-control problem, not a data-fetch problem. Price feeds must be evaluated para freshness, confidence, y contextual fitness before they drive protocol decisions. A safe oracle validation pipeli..."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Diseno multi-oracle aggregation y consensus policies that reduce single-source failure risk while remaining explainable y testable."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Multi-oracle aggregation reduces single-point dependency but adds policy complexity. The goal is not to average blindly; it is to produce a robust decision value con clear confidence in adverse conditions. Common strateg..."
        },
        {
          "path": "courses.solana-dao-tooling.description",
          "englishWordCount": 17,
          "excerpt": "Construye sistemas DAO listos para produccion en Solana: gobernanza de propuestas, integridad de votacion, controles de tesoreria y flujos deterministas de ejecucion/reporting."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Implement gobernanza mechanics con explicit proposal lifecycle rules, voting-power logic, y deterministic state transitions."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[0].content",
          "englishWordCount": 106,
          "excerpt": "DAO gobernanza architecture is a system of enforceable process rules. Proposal creation, voting, y execution must be deterministic, auditable, y resistant to manipulation. A robust gobernanza model defines: 1) proposal l..."
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Engineer treasury y execution tooling con policy gates, timelock safeguards, y auditable automation outcomes."
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[0].content",
          "englishWordCount": 106,
          "excerpt": "DAO treasury management is where gobernanza intent becomes real financial action. Treasury tooling must therefore combine flexibility con strict policy constraints. Core controls include: - spending limits y role-based a..."
        },
        {
          "path": "courses.solana-gaming.description",
          "englishWordCount": 19,
          "excerpt": "Construye sistemas de juego on-chain listos para produccion en Solana: modelos de estado eficientes, integridad de turnos, controles de equidad y economia escalable de progresion de jugadores."
        },
        {
          "path": "courses.solana-gaming.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Diseno game state y turn logic con deterministic transitions, storage efficiency, y anti-cheat validation boundaries."
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[0].content",
          "englishWordCount": 133,
          "excerpt": "On-chain game diseno on Solana is a systems-engineering tradeoff between fairness, responsiveness, y cost. The best designs keep critical rules verifiable while minimizing expensive state writes. Core architecture decisi..."
        },
        {
          "path": "courses.solana-gaming.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement fairness-oriented randomness y integrity controls that keep gameplay auditable y dispute-resistant."
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Randomness is one of the hardest fairness problems in blockchain games because execution is deterministic. Robust designs avoid naive pseudo-randomness tied directly to manipulable context. Practico fairness patterns inc..."
        },
        {
          "path": "courses.solana-permanent-storage.description",
          "englishWordCount": 19,
          "excerpt": "Integra almacenamiento descentralizado permanente con Solana usando flujos estilo Arweave: content addressing, integridad de manifests y acceso verificable a datos de largo plazo."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand permanent-storage architecture y build deterministic linking between Solana state y external immutable content."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[0].content",
          "englishWordCount": 119,
          "excerpt": "Permanent storage integration is a data durability contract. On Solana, storing full content on-chain is often impractical, so systems rely on immutable external storage references anchored by on-chain metadata. A robust..."
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Work con manifests, verification pipelines, y cost/rendimiento controls para reliable long-lived data serving."
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[0].content",
          "englishWordCount": 96,
          "excerpt": "Manifests turn many stored assets into one navigable root, but they introduce their own integrity responsibilities. A manifest is only trustworthy if path mapping y referenced content IDs are validated consistently. Key ..."
        },
        {
          "path": "courses.solana-staking-economics.description",
          "englishWordCount": 18,
          "excerpt": "Comprende staking y economia de validadores en Solana para decisiones del mundo real: estrategia de delegacion, dinamica de recompensas, efectos de comision y sostenibilidad operativa."
        },
        {
          "path": "courses.solana-staking-economics.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Aprende native staking mechanics con deterministic reward modeling, validador selection criteria, y delegation risk framing."
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[0].content",
          "englishWordCount": 108,
          "excerpt": "Solana staking economics is an incentives system connecting delegators, validadores, y network seguridad. Good delegation decisions require more than chasing headline APY. Delegators should evaluate: 1) validador rendimi..."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Analyze validador-side economics, operational cost pressure, y incentive alignment para long-term network health."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Validador economics balances revenue opportunities against operational costs y reliability obligations. Sustainable validadores optimize para long-term trust, not short-term extraction. Revenue sources include inflation ..."
        },
        {
          "path": "courses.solana-account-abstraction.description",
          "englishWordCount": 17,
          "excerpt": "Implementa patrones de smart-wallet/abstraccion de cuentas en Solana con autorizacion programable, controles de recuperacion y validacion de transacciones guiada por politicas."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build smart-cartera fundamentals including multisig y social-recovery designs con clear trust y failure boundaries."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Cuenta abstraction on Solana shifts control from a single key to programmable policy. Smart carteras can enforce richer authorization logic, but policy complexity must be managed carefully. A robust smart-cartera diseno ..."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement programmable validation policies (limits, allowlists, time/risk rules) con deterministic enforcement y auditability."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Programmable validation is where smart carteras deliver real value, but it is also where subtle policy bugs appear. Typical controls include spending limits, destination allowlists, time windows, y risk-score gates. Thes..."
        },
        {
          "path": "courses.solana-pda-mastery.description",
          "englishWordCount": 17,
          "excerpt": "Domina ingenieria avanzada de PDAs en Solana: diseno de esquemas de seeds, disciplina de bump y uso seguro de PDAs cross-program a escala de produccion."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build strong PDA foundations con deterministic derivation, canonical seed composition, y collision-resistant namespace strategy."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[0].content",
          "englishWordCount": 113,
          "excerpt": "Direcciones Derivadas de Programa (PDAs) are deterministic authority y state anchors on Solana. Their power comes from predictable derivation; their risk comes from inconsistent seed discipline. A strong PDA diseno stand..."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement avanzado PDA patterns (nested/counter/stateful) while preserving seguridad invariants y migration safety."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[0].content",
          "englishWordCount": 102,
          "excerpt": "Avanzado PDA patterns solve real scaling y composability needs but increase diseno complexity. Nested PDAs, counter-based PDAs, y multi-tenant PDA namespaces each require explicit invariants around uniqueness, lifecycle,..."
        },
        {
          "path": "courses.solana-economics.description",
          "englishWordCount": 17,
          "excerpt": "Analiza dinamicas economicas de Solana en contexto de produccion: interaccion inflacion/fee-burn, flujos de staking, movimiento de supply y tradeoffs de sostenibilidad de protocolos."
        },
        {
          "path": "courses.solana-economics.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand Solana macro token economics (inflation, burn, rewards, fees) con deterministic scenario modeling."
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[0].content",
          "englishWordCount": 112,
          "excerpt": "Solana economics is the interaction of issuance, burn, staking rewards, y usage demand. Sustainable protocol decisions require understanding these flows as a system, not isolated metrics. Core mechanisms include: 1) infl..."
        },
        {
          "path": "courses.solana-economics.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Model token flow dynamics y sustainability signals using supply categories, unlock events, y behavior-driven liquidity effects."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[0].content",
          "englishWordCount": 115,
          "excerpt": "Token flow analysis turns abstract economics into operational insight. The key is to track where tokens are (staked, circulating, locked, treasury, pending unlock) y how they move over time. Useful flow metrics include: ..."
        }
      ],
      "totals": {
        "exactEnglishCount": 866,
        "englishLikeCount": 457
      }
    },
    {
      "locale": "pt-BR",
      "exactEnglishMatches": [
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].options[0]",
          "text": "To calculate NFT metadata size"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "It is the user who paid the creation fee forever"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "What does `executable: true` indicate?"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].options[1]",
          "text": "Token balances are program-specific state managed by the token program"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "This is your active signer public key."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[1]",
          "text": "Convert SOL to lamports using 1_000_000_000 multiplier."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[0]",
          "text": "A client-only simulation mode"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[1]",
          "text": "Calling one on-chain program from another on-chain program"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].prompt",
          "text": "Why are PDAs useful?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].options[0]",
          "text": "They let programs derive deterministic addresses without private keys"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].options[1]",
          "text": "The runtime on behalf of the program when invoke_signed seeds match"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].prompt",
          "text": "What happens if you change a seed?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[0]",
          "text": "The PDA stays the same but bump changes"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[2]",
          "text": "You derive a different PDA address"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].explanation",
          "text": "Seed bytes are part of the hash input, so any change yields a different derived address."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "A compressed NFT ledger entry"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[2].prompt",
          "text": "What authority controls minting?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[0]",
          "text": "Parse flags in pairs: --key value."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[2]",
          "text": "Construct JSON object in fixed key order before JSON.stringify."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does Anchor generate automatically from your program definitions?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Automatic PDA funding from devnet faucets"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A JSON interface used by clients/tests/tooling to call your program correctly"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "A private key format used only by on-chain programs"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is a seeds constraint verifying?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "That a token mint has 9 decimals"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].prompt",
          "text": "Why is a PDA considered off-curve?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].options[0]",
          "text": "It is derived to avoid having a corresponding private key"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].explanation",
          "text": "Off-curve means no user-held private key exists; programs authorize via seed proofs."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].prompt",
          "text": "What breaks if you change one PDA seed value?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[1]",
          "text": "Only the bump changes while address stays fixed"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[2]",
          "text": "Nothing changes unless RPC endpoint changes"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].explanation",
          "text": "PDA derivation is seed-sensitive. Any seed change creates a different address namespace."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].title",
          "text": "Initialize Counter PDA (deterministic)"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[0]",
          "text": "Use a deterministic hash-like reducer over programId + authorityPubkey + static seed."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[0]",
          "text": "Represent state as a pure JS structure so increment can be deterministic in tests."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[1]",
          "text": "Return a new state object from applyIncrement; avoid mutating the input object in-place."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the main role of optional integration tests?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Validate network execution paths after deterministic logic is proven"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Replace all unit tests"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Avoid asserting exact outputs"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Integration tests add runtime confidence but should not replace deterministic core checks."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do simulation failures happen even before final send succeeds?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because fee payer is irrelevant"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[0]",
          "text": "Compose the checkpoint from deterministic helper functions to keep output stable."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Where do SPL token balances actually live?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why keep raw amounts as integer strings in model code?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because decimals are always 9"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "Show pending overlays first, mutate durable balances only after stronger confirmation"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[2]",
          "text": "Disable activity feed until finalized"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "Optimistic overlays are useful, but confirmed state must remain authoritative."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].options[2]",
          "text": "Because commitment levels require it by protocol"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Phase-specific metrics enable actionable incident diagnosis."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is ordering by (ts, id) preferred over timestamp-only replay?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Stable ordering prevents environment-dependent state divergence."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should happen when the same event id arrives twice?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Idempotency guarantees deterministic behavior under retries."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[0]",
          "text": "Sort by (ts, id) before applying events."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[1]",
          "text": "Deduplicate by event id before snapshot interval checks."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[2]",
          "text": "Build checksum from stable snapshot metadata, not random values."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[0]",
          "text": "Use fixed-scale integers (micro USD) instead of floating point."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[1]",
          "text": "Apply filter -> search -> sort in a deterministic order."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "To reduce CSS size only"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because rate limits require it"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the main risk of generic one-size-fits-all error banners?"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Users cannot distinguish recovery actions across failure classes"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "They always break hydration"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Which metric should drive route selection at execution size?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Deterministic outAmount from full route simulation"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Displayed ticker price only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Lowest hop count only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Route quality is output-at-size, not headline spot labels."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does slippage tolerance directly determine?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "The minOut acceptance bound"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the deterministic minOut formula?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "minOut is a bounded percentage reduction from outAmount."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Why keep per-hop fee breakdowns?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Per-hop fee attribution makes route behavior auditable."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Minimize hop count always"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Choose first enumerated route"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "Why simulate virtual reserves per candidate route?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Virtual simulation avoids shared-state contamination."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].content",
          "text": "# Implement token/pool model + constant-product quote calc Implement deterministic CPMM quoting: - out = (reserveOut * inAfterFee) / (reserveIn + inAfterFee) - fee = floor(inAmount * feeBps / 10000) - impactBps from spot..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].hints[0]",
          "text": "Use inAfterFee = inAmount - floor(inAmount * feeBps / 10000)."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].hints[2]",
          "text": "Keep sorting deterministic to avoid route flicker."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[0]",
          "text": "Use virtual pool copies so fixture reserves are not mutated."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[2]",
          "text": "Return structured errors when pools or route links are invalid."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].prompt",
          "text": "What should happen when quote freshness expires?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].options[2]",
          "text": "Increase slippage automatically without notifying user"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Freshness boundaries should trigger deterministic recomputation."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which failures are not solved by blind retries?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].explanation",
          "text": "Planner errors require input/route changes, not repetition."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[0]",
          "text": "Keep output key order stable: swapPlan first, swapSummary second."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[1]",
          "text": "Path should be deterministic symbols along route hops."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[2]",
          "text": "Include fixtureHash + modelVersion under determinism metadata."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because owner checks improve rendering speed"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Because owner checks replace signer checks"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Only that an amount field exists"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the purpose of trace hashing in an audit workflow?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].options[1]",
          "text": "To replace structured test assertions"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Which sequence represents a valid evidence chain?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "Reproduce -> trace -> impact -> fix -> verify"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[1]",
          "text": "Fix -> reproduce -> trace -> release"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Accepting any PDA-like prefix"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Trusting client-provided bump values"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Deterministic re-derivation closes spoofable PDA substitution paths."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Because most exploitable bugs only appear under malformed or adversarial input"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Because traces are optional without them"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[0]",
          "text": "Compute drained lamports from recipient before/after."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[1]",
          "text": "Include deterministic field ordering in the JSON output."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[2]",
          "text": "The explanation should mention missing signer/owner validation."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].hints[2]",
          "text": "Keep output key order stable."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[1]",
          "text": "Use fixedBlockedExploit to set blocked status."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[2]",
          "text": "Return error code only when blocked is true."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].options[1]",
          "text": "They are interchangeable labels"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Good reports separate damage potential from exploit feasibility."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which recommendation is most actionable?"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[0]",
          "text": "Return stable, minimal checkpoint metadata."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[2]",
          "text": "Preserve scenarioIds order as provided."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why generate an offline deterministic launch pack before devnet/mainnet actions?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should supply checks use integer math instead of floating-point UI values?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "To avoid rounding drift in launch invariants"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Because decimals are always zero"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the primary role of freeze authority?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[0]",
          "text": "It can materially change effective fee behavior across transfer sizes"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "It is ignored once mint is initialized"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is a core risk of permanent delegate configuration?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].hints[2]",
          "text": "Keep output key order stable so checkpoint tests are reproducible."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].hints[1]",
          "text": "Append extension steps in deterministic order so plan labels are stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[0]",
          "text": "Transfer fee formula: fee = min(maxFee, floor(amount * feeBps / 10000))."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[2]",
          "text": "Fail when distributed amount exceeds initial supply."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is parameter closure required before execution?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Single-source configuration prevents mismatched launch behavior."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the purpose of hard stop launch criteria?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "To halt execution when invariants or authority assumptions fail"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Hard stop rules prevent progressing through unsafe operational states."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[0]",
          "text": "Keep checkpoint JSON key ordering fixed so output is stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[2]",
          "text": "Include determinism metadata (fixtures hash + encoding version) in the final object."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[0]",
          "text": "Add validation before returning the formatted string."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[1]",
          "text": "instructionCount should be treated as a number but returned as text."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].content",
          "text": "# Write a Counter Program Bankrun Test Implement a helper that returns the expected counter value after a sequence of increment operations. This mirrors a deterministic assertion you would use in a Bankrun test. Return t..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[0]",
          "text": "Use Array.reduce to sum increments."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[2]",
          "text": "Convert final number to string before returning."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the primary source of event data on Solana?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Explicit event topics like EVM"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is idempotency important in indexing?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "To prevent duplicate events during replays or forks"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "To improve RPC response times"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "As little-endian u64, then divided by 10^decimals"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[1].note",
          "text": "Inner CPI call at depth 2"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Success bubbles up from inner to outer"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[0]",
          "text": "Parse log entries to identify event types"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[1]",
          "text": "Extract fields using regex patterns"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It provides stable ordering during concurrent writes"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Cursor-based pagination handles concurrent writes without missing or duplicating entries."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What enables indexer recovery after crashes?"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Periodic checkpointing of last processed position"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Re-indexing from genesis on every start"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Caching all data in memory"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Checkpoints allow indexers to resume from the last known good position."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].hints[3]",
          "text": "Include metadata like timestamps"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the purpose of SPL Memo in payments?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What should never be included in a memo?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Memos are public on-chain; sensitive data should be hashed or kept off-chain."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[0]",
          "text": "Use base58 alphabet to validate the recipient address format."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[2]",
          "text": "Generate an idempotency key if not provided in the input."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].hints[2]",
          "text": "Key order matters: SOL transfer needs [from, to], SPL transfer needs [source, mint, dest, owner]."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Different key orders produce different signatures"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Canonicalization ensures consistent serialization so signatures match regardless of object construction order."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Initial state after intent creation"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Payment complete, generate receipt"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[0]",
          "text": "HMAC-SHA256: H(key, message) = SHA256((key XOR outer_pad) || SHA256((key XOR inner_pad) || message))"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[1]",
          "text": "Use constant-time comparison to prevent timing attacks on signature verification."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[2]",
          "text": "Verify the timestamp is recent (within 5 minutes) to prevent replay attacks."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a Merkle root commit to?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The tree depth only"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[0]",
          "text": "Start by validating the leaf index is within bounds."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[1]",
          "text": "At each level, find the sibling node (left or right of current)."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[3]",
          "text": "Traverse up to the root, collecting all updated node hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[4]",
          "text": "Use deterministic ordering: left hash comes before right hash."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].prompt",
          "text": "What determines concatenation order during verification?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[0]",
          "text": "The leaf index bits at each level"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[1]",
          "text": "The size of the sibling hashes"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[2]",
          "text": "The tree root hash"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].explanation",
          "text": "Each bit of the leaf index determines if the current hash goes left or right in the concatenation."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[1].explanation",
          "text": "log2(1024) = 10, so proofs contain 10 sibling hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[0]",
          "text": "To generate a proof, collect the sibling hash at each level from leaf to root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[1]",
          "text": "The sibling is at index+1 if current is left, index-1 if current is right."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[3]",
          "text": "Use the same ordering (left || right) when combining hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[4]",
          "text": "The proof is valid if the recomputed root matches the stored root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do old proofs fail after tree updates?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "The root changes when leaves are added/modified"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "The proof format changes"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "The leaf hashes are encrypted"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Adding leaves changes parent hashes up to the root, invalidating previous proofs."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "How can metadata attacks be prevented?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Hash verification against leaf commitments"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Using shorter metadata URIs"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Verifying metadata hashes ensures the off-chain data matches the on-chain commitment."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[0]",
          "text": "Validate the mint request has all required fields (leafIndex, nftId, owner)."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[2]",
          "text": "Insert the leaf by computing hashes up to the root, collecting sibling hashes as proof."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What determines voting power in most DAOs?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Token balance at snapshot block"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Voting power is typically proportional to token holdings at a specific snapshot time."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Anyone can trigger execution"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].content",
          "text": "# Challenge: Implement quorum/voting state machine Build a deterministic voting system: - Calculate vote weights from token balances - Check quorum requirements - Determine pass/fail based on thresholds - Handle abstenti..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[1]",
          "text": "Check if totalVoteWeight >= quorumThreshold to determine quorumMet."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[2]",
          "text": "Calculate support percentage as forWeight / (forWeight + againstWeight) when there are non-abstain votes."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does 2-of-3 multisig mean?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].options[0]",
          "text": "2 signatures required from 3 possible signers"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why track approvals on-chain?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[1]",
          "text": "Process actions in order - each action updates the signer's status."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[2]",
          "text": "Track the cumulative approved weight to compare against threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[3]",
          "text": "A proposal is 'approved' when approvedWeight >= threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[4]",
          "text": "A proposal is 'rejected' when no pending signers remain but threshold is not met."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "What is a replay attack in multisig systems?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Sending duplicate approval requests"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].hints[0]",
          "text": "First validate the proposal status is 'approved'."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The network automatically extends the limit"
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].hints[2]",
          "text": "Each byte of data adds 10 compute units."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Lower fees, higher throughput"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[0]",
          "text": "Sort fields by size (largest first) to minimize padding gaps."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[1]",
          "text": "Consider if u64 fields can be reduced to u32 based on maxValue."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[2]",
          "text": "Boolean flags can be packed into a single byte as bit flags."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[3]",
          "text": "Calculate bytes saved as originalSize - optimizedSize."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of setComputeUnitPrice?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Enable additional program features"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why request specific compute unit limits?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "Optimizing without profiling or evidence of need"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Premature optimization wastes effort on theoretical rather than measured bottlenecks."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[0]",
          "text": "Compute savings by subtracting 'after' from 'before' metrics."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[1]",
          "text": "Use approximate conversion: 1 SOL = $20, 1 SOL = 1,000,000,000 lamports."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why must native SOL be wrapped before swapping?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Native SOL cannot be transferred on Solana"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Solana automatically creates the ATA"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The tokens are sent to the system program"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is 50 basis points of slippage on a 1,000,000 output?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why should minOutAmount use BigInt instead of floating point?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Floating point introduces rounding errors in token amounts"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "BigInt is faster than floating point"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Single-hop direct route"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Total execution cost includes fees + impact"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[0]",
          "text": "Use BigInt arithmetic to avoid floating point errors when computing minOutAmount."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[1]",
          "text": "Slippage in basis points: minOut = outAmount - (outAmount * slippageBps / 10000)."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[3]",
          "text": "The priceImpactPct comes directly from the quote response."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].hints[0]",
          "text": "Define a TRANSITIONS map: each key is a state, each value maps event names to next states."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "They reduce the number of required signatures"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Retryable — get fresh blockhash"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[0]",
          "text": "Use BigInt to sum fee amounts across all route legs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[1]",
          "text": "Effective price = outAmount / inAmount, formatted to 9 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the main advantage of CLMMs over constant product AMMs?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Capital efficiency — LPs concentrate liquidity where trades happen"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "CLMMs allow LPs to allocate capital to specific price ranges, dramatically improving capital efficiency compared to spreading liquidity across all prices."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs use ticks to discretize the price space?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "To reduce the number of tokens in the pool"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs store sqrtPrice instead of price directly?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "It simplifies the AMM math — token amounts become linear in sqrtPrice"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "It uses less storage space on-chain"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Price within range, position is active"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "All SOL was sold as price rose through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Position reactivates when price returns to range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "All USDC was sold as price fell through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[0]",
          "text": "Price at a tick index = 1.0001^tickIndex. Use Math.pow(1.0001, tick)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[1]",
          "text": "Reverse conversion: tick = round(ln(price) / ln(1.0001))."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[2]",
          "text": "sqrtPriceX64 = BigInt(round(sqrt(price) * 2^64)) — Solana CLMM uses Q64.64 fixed-point."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[3]",
          "text": "Tick spacing alignment: floor(tick / spacing) * spacing."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[0]",
          "text": "Convert ticks to prices: lowerPrice = 1.0001^lowerTick, upperPrice = 1.0001^upperTick."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[2]",
          "text": "Fees only accrue when the position is in range. fee = floor(volumePerPeriod * feeRate)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[3]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[4]",
          "text": "Current status is based on the last price in the path relative to the range."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the main tradeoff of using a tight price range?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Lower fees but less impermanent loss"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "More tokens required to open the position"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When should an LP consider a full-range (all ticks) position?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "JavaScript Number cannot safely represent 128-bit integers"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "sqrtPriceX64 is a u128 value that can exceed JavaScript's Number.MAX_SAFE_INTEGER (2^53 - 1). BigInt provides arbitrary precision integer arithmetic."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "They are rejected by the program"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Floor division rounds toward negative infinity: floor(-100/64) = -2, so -100 aligns to -2 * 64 = -128. This is correct CLMM behavior."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[1]",
          "text": "Status is 'in-range' if lowerPrice <= currentPrice <= upperPrice."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[3]",
          "text": "IL formula: lpValue = sqrt(priceRatio) + sqrt(1/priceRatio); compare to holdValue = 2*sqrt(priceRatio)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[4]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimals."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a utilization ratio of 80% mean?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "80% of supplied assets are currently borrowed"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "80% of borrowers have been liquidated"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The pool has 80% of its maximum capacity"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Utilization = totalBorrowed / totalSupply. At 80%, four-fifths of all deposited assets are currently lent out to borrowers."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does the reserve factor affect supplier yield?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "It reduces supplier yield by skimming a percentage of borrow interest"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It increases supplier yield by adding protocol subsidies"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "It has no effect on supplier yield"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "The reserve factor takes a cut of borrow interest before distributing the rest to suppliers, reducing their effective APY."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What happens to borrow rates when utilization exceeds the kink?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "They increase steeply according to slope2"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "They remain constant at the kink rate"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "They decrease to attract more borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is the supply rate always lower than the borrow rate?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The protocol subsidizes borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Only 20% buffer remaining — consider adding collateral"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[0]",
          "text": "Utilization = totalBorrowed / totalSupply. Handle the zero-supply edge case."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[1]",
          "text": "Below kink: borrowRate = baseRate + (utilization/kink) * slope1."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[2]",
          "text": "Above kink: borrowRate = baseRate + slope1 + ((util - kink)/(1 - kink)) * slope2."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[3]",
          "text": "Supply rate = borrowRate * utilization * (1 - reserveFactor)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[1]",
          "text": "Effective threshold = weighted average of liquidationThreshold by collateral value."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[2]",
          "text": "Health factor = (collateralValue * effectiveThreshold) / borrowValue."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[3]",
          "text": "Max additional borrow = max(0, collateralValue * threshold - currentBorrow)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of the liquidation bonus?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It incentivizes liquidators to repay debt by offering collateral at a discount"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When does bad debt occur in a lending protocol?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "When collateral value is insufficient to cover outstanding debt after liquidation"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "When the reserve factor is set too high"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "When utilization drops below the kink"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "To be conservative — using (price - confidence) prevents over-valuing collateral during uncertainty"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Confidence intervals make prices more accurate"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should a protocol do when all oracle feeds are stale?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "Use the last known price regardless of age"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Estimate the price from on-chain DEX data"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[2]",
          "text": "Track the worst health factor across all scenarios."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[3]",
          "text": "Count how many scenarios result in isLiquidatable: true."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do perpetual futures protocols use a mark price instead of the last-traded price?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Mark price smooths out manipulation by incorporating oracle data, preventing artificial liquidations"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Mark price is cheaper to compute on-chain"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Last-traded price is not available on Solana"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Mark price incorporates the oracle price as a stability anchor. Using last-traded price alone would allow a single large trade to trigger cascading liquidations through price manipulation."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Weighted average: (8 * 20 + 2 * 30) / 10 = (160 + 60) / 10 = $22.00. The entry price shifts toward the new fill price proportional to the additional size."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "When the perpetual mark price is above the oracle (spot) price, who pays funding?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Longs pay shorts — the positive premium makes long positions expensive to hold"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Both sides pay the protocol a fee"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "A 10 SOL-PERP position at $25 entry faces a 0.01% funding rate. What is the per-period payment?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "text": "Funding payment = size * entryPrice * rate = 10 * 25 * 0.0001 = $0.025 per funding interval."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Position snapshot at current mark price"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Long PnL = size * (mark - entry)"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Positive rate: longs pay funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "True return includes funding drag"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[0]",
          "text": "Long PnL = size * (markPrice - entryPrice). Short PnL = size * (entryPrice - markPrice)."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[1]",
          "text": "Notional value = size * markPrice — represents the total position value."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[2]",
          "text": "ROE (return on equity) = unrealizedPnL / margin * 100."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[0]",
          "text": "Funding payment per period = size * entryPrice * fundingRate."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[1]",
          "text": "Longs pay when rate is positive (totalFunding -= payment). Shorts receive."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[2]",
          "text": "Average funding rate = sum(rates) / count."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[3]",
          "text": "Net margin impact = (totalFunding / margin) * 100, as a percentage."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is the maintenance margin rate set above zero?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "What causes a cascading liquidation spiral?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Forced position closes push the price further, triggering more liquidations in a feedback loop"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Too many traders opening positions at the same time"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Oracle prices updating too slowly"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "text": "When liquidation engines close positions by selling into the market, the selling pressure moves the price further against remaining positions, triggering their liquidations too — a self-reinforcing feedback loop."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should position size always be stored as a positive number?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Positive numbers use less storage space"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "A long position has a positive funding rate of 0.01%. What happens to the trader's balance?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The balance decreases — longs pay when the funding rate is positive"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The balance increases — longs receive positive funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Nothing — funding only affects shorts"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Positive funding rate means the perp is trading above spot. Longs pay shorts to discourage the long-heavy imbalance. The long trader's effective margin decreases by the funding payment amount."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[0]",
          "text": "Effective margin = initial margin + unrealized PnL + funding payments."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[1]",
          "text": "Margin ratio = effectiveMargin / notionalValue."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[3]",
          "text": "Generate alerts based on margin ratio vs maintenance margin rate thresholds."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[4]",
          "text": "Sort alerts by severity: CRITICAL > WARNING > INFO."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How is the priority fee calculated in lamports?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "The CU price is denominated in micro-lamports per CU. Dividing by 1,000,000 converts micro-lamports to lamports. The ceiling function ensures rounding up to the nearest lamport."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is setting the CU limit to exactly the simulated value risky?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The runtime does not accept exact values"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Simulation always underreports CU usage by 50%"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Low compute = minimal priority fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Higher compute increases priority cost proportionally"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "High CU + high priority = significant fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[1]",
          "text": "Cap compute unit limit at 1,400,000 (Solana max)."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[2]",
          "text": "Priority fee = ceil(computeUnitLimit * computeUnitPrice / 1_000_000) in lamports."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[3]",
          "text": "Total fee = base fee (5000 lamports) + priority fee."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].hints[3]",
          "text": "Recommend 'legacy' if fits without LUT, 'use-existing-lut' if LUT helps enough, 'create-new-lut' if still too large."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "When the blockhash has expired or pool state has changed"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Whenever any error occurs"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Only when the user manually clicks retry"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add random jitter to retry delays?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To make the delay shorter on average"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Jitter is required by the Solana protocol"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Without jitter, all clients using the same backoff formula would retry simultaneously, creating thundering herd problems on the RPC infrastructure."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Slippage exceeded -> actionable message"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Balance error -> show exact shortfall"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[1]",
          "text": "Fee estimates: low = 100 microlamports/CU, medium = 1000, high = 10000."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[2]",
          "text": "Retry policy: 3 retries, 500ms base delay, 2x backoff, always refresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[3]",
          "text": "Use the same CU calculation: ceil(totalCU * 1.1) capped at 1,400,000."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Foreground services maintaining a session channel"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Deep links passed between applications"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Shared local storage between apps"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "iOS suspends app execution on background transitions, preventing persistent channels"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "iOS uses a different blockchain protocol"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "iOS does not allow arbitrary background processes or persistent inter-app communication. When the user switches apps, the dApp's execution context is suspended."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Detect available connection methods (MWA, deep links, QR)"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "Capability detection ensures you only present connection methods that are actually available on the user's device."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Request sent via MWA session or deep link"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "User decision - timing is unpredictable"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[3]",
          "text": "Generate a requestId from type + payload prefix if not provided."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[0]",
          "text": "Process actions sequentially: each action modifies the session state."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[3]",
          "text": "Expire check clears session if current time >= expiresAt."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "As raw lamports or smallest unit values"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Raw simulation logs from the RPC response"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].title",
          "text": "Retry State Machine Flow"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "User action triggers request construction"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[0]",
          "text": "Count requests by status: 'signed' = success, 'rejected'/'timeout'/'error' = failure."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[2]",
          "text": "Session duration = sessionEnd - sessionStart in seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "solana:<recipient> (single colon, no slashes)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "solana://<recipient> (double slashes like HTTP)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "pay:<recipient> (custom pay scheme)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "When the amount exceeds 100 SOL"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How does the reference parameter enable payment tracking?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "It creates a webhook that notifies the merchant"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What amount value represents 2.5 USDC in a Solana Pay URL?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "amount=2.5 (human-readable decimal)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Native SOL transfer — no spl-token parameter"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[0]",
          "text": "Solana Pay URL format: solana:<recipient>?amount=<amount>&spl-token=<mint>&reference=<ref>&label=<label>&message=<msg>"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[1]",
          "text": "Validate recipient: must be 32-44 characters of valid base58."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[2]",
          "text": "Amount must be a positive finite number."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[0]",
          "text": "Track state transitions: pending -> found -> confirmed -> finalized."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[1]",
          "text": "The 'found' event sets the signature. 'confirmation' increments the counter."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[2]",
          "text": "Timeout check expires the reference if still pending after expiryTimeout seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[3]",
          "text": "Record each state change in the history array."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Confirmed is never sufficient — always use finalized"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What should happen when the payment request expires?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Silently restart the polling loop"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Redirect the customer to a different payment method"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Exponential backoff recovers from transient failures"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Never auto-complete mismatched payments"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Track processed references to prevent double fulfillment"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[0]",
          "text": "Generate receiptId from the last 8 chars of reference + timestamp."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[1]",
          "text": "Reconstruct the Solana Pay URL from payment data."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[2]",
          "text": "Currency is 'SPL' if splToken is present, otherwise 'SOL'."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What should happen when auto-connect fails silently on page load?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Show the connect button without an error message"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Display an error toast telling the user to reconnect"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Auto-connect is a background optimization. If it fails, the user never initiated the action, so showing an error would be confusing. Simply display the default connect button."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why should you show skeleton UI during the connecting phase?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It makes the page load faster"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How do you reliably detect which Solana cluster an RPC endpoint is connected to?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What must happen to cached data when the network changes?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Only token balances need to be refreshed"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Cached data can be retained since addresses are the same across clusters"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "User clicks Connect, show loading state"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[0]",
          "text": "Define a TRANSITIONS map: each state maps event types to next states."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[2]",
          "text": "Error state stores the error message. Disconnected clears all session data."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[2]",
          "text": "DISCONNECT invalidates all non-'global' entries."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[3]",
          "text": "Track invalidation counts per event in the event log."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must cache keys include the network cluster?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "The Solana RPC protocol requires cluster identification"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What does the stale-while-revalidate pattern do when a cache entry is past its TTL?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Blocks until fresh data is fetched from the RPC"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Primary endpoint responding normally"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Latency spike detected, slot behind tip"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Automatic failover to healthy secondary"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Primary recovered, restoring as default"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[1]",
          "text": "Average connect time = total durationMs from CONNECTED events / count."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[2]",
          "text": "Cache hit rate = hits / (hits + misses) * 100."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[3]",
          "text": "RPC health = healthy checks / total checks * 100."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "signMessage does not produce valid Ed25519 signatures"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does SIWS prevent replay attacks?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "By requiring a unique, server-generated nonce that is consumed after verification"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must nonces be generated server-side rather than client-side?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Client-generated nonces allow attackers to reuse previously valid nonce-signature pairs"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Client-side random number generators are too slow"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What format must the domain field use?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Plain domain name without protocol prefix (e.g., example.com)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[0]",
          "text": "Domain should not include protocol (https://). Strip or reject it."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[2]",
          "text": "Address must be 32-44 characters (Solana base58 public key)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[3]",
          "text": "If no statement is provided, default to 'Sign in to <domain>'."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[1]",
          "text": "issuedAt must be <= currentTime (not in the future)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[2]",
          "text": "expirationTime (if present) must be > currentTime."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The dApp should invalidate the server-side session (treat it as logout)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Atomic SET NX ensures only one request can consume the nonce"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Replay blocked: nonce was already consumed"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[0]",
          "text": "Track used nonces in a map. If a nonce was already used, it's a replay attempt."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[2]",
          "text": "Use an address set to count unique addresses."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does a wide p90 vs p50 spread usually indicate?"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A volatile fee regime where a guard premium may be needed"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "Floor protects small estimates."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Large payload triggers heap recommendation."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[0].content",
          "text": "Implement a deterministic compute budget planner. No RPC calls; operate only on provided input data."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[0]",
          "text": "Use percentile targeting from sorted synthetic fee samples."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[1]",
          "text": "Apply volatility guard if p90 vs p50 spread exceeds policy threshold."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[2].hints[0]",
          "text": "Map risk score bands to processed/confirmed/finalized UX levels."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].hints[1]",
          "text": "Avoid timestamps or random IDs in output."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[4].hints[1]",
          "text": "Checkpoint report should avoid nondeterministic fields."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do users still expect atomic behavior in multi-tx flows?"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because protocols always guarantee it"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].title",
          "text": "Flow Graph Risk Walkthrough"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "No compensation path after swap failure."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Still verify idempotency on each step."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[0].hints[1]",
          "text": "Emit explicit edges from dependency relationships."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[1].hints[1]",
          "text": "Flag non-idempotent steps because retries can break all-or-nothing guarantees."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].content",
          "text": "Encode deterministic failure handling metadata, including compensation state."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].hints[0]",
          "text": "Generate deterministic idempotency keys from stable inputs."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[3].hints[0]",
          "text": "No real Jito calls. Build deterministic data structures only."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].content",
          "text": "Generate a stable markdown flow safety report checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[0]",
          "text": "Render a stable markdown report as the final checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[1]",
          "text": "Keep the PASS/FAIL status deterministic from issue count."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Slippage is user tolerance; impact is market footprint"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They are identical metrics"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Slippage is a user-configured bound, while impact reflects route liquidity response to trade size."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[1].hints[0]",
          "text": "Clamp recommended BPS to policy bounds."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[2].hints[0]",
          "text": "Teach difference: impact is market footprint, slippage is user tolerance."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[3].hints[0]",
          "text": "Map risk grades to deterministic banner copy."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[4].hints[1]",
          "text": "Do not include timestamps or random IDs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "It reduces RPC cost directly"
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[0].hints[1]",
          "text": "Sort by key so output is deterministic across runs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[1].hints[0]",
          "text": "Apply only confirmed-depth events to state."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[0]",
          "text": "Integrity checks must fail on negative balances."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[1]",
          "text": "Finalized keys must always be a subset of applied keys."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].title",
          "text": "RPC failures in real life: timeouts, 429s, stale nodes"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is slot lag important in endpoint scoring?"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Fast responses can still be wrong if the node is stale"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Slot lag is equivalent to timeout"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Latency alone cannot guarantee freshness of chain state."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Fast but less reliable under pressure."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].title",
          "text": "Explorer: retry/backoff simulator"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].title",
          "text": "RPC Multi-Provider Client Project Journey"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[0].hints[0]",
          "text": "Build a deterministic retry schedule including the first attempt."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[1].hints[1]",
          "text": "Tie-break deterministically by endpoint ID."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[2].hints[1]",
          "text": "Use tighter TTL when node lag grows."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].title",
          "text": "Checkpoint: RPC health report export"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].hints[1]",
          "text": "Ensure field order is stable in JSON output."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Alignment inserts padding bytes"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "RPC forces 8-byte packets"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "u64 alignment usually forces padding after smaller fields."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "u32 length + UTF-8 bytes + u8 field"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[0].hints[1]",
          "text": "Struct total size should be aligned to max field alignment."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].title",
          "text": "Challenge: implement borshEncode/borshDecode helpers"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].hints[0]",
          "text": "Borsh strings are length-prefixed little-endian u32 + UTF-8 bytes."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].title",
          "text": "Challenge: zero-copy vs Borsh tradeoff model"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[0]",
          "text": "Model tradeoffs deterministically: read speed vs schema flexibility."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[1]",
          "text": "Recommendation should be pure function of inputs."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[3].hints[0]",
          "text": "Validate byte length before field parsing."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].title",
          "text": "Checkpoint: stable layout report"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should export stable JSON + markdown."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].title",
          "text": "Error taxonomy: recoverable vs fatal"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why are typed error codes preferred over free-form strings?"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable machine-readable semantics"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "They reduce compile time"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].title",
          "text": "Explorer: invariant decision tree"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].title",
          "text": "Invariant Guard Library Project Journey"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].title",
          "text": "Challenge: implement InvariantError + ensure helpers"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].hints[0]",
          "text": "Return typed error payloads, not raw strings."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[1].title",
          "text": "Challenge: implement deterministic EvidenceChain"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].title",
          "text": "Challenge: deterministic invariant case runner"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].hints[0]",
          "text": "Property-ish deterministic tests can still run as fixed case sets."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].title",
          "text": "Challenge: implement formatReport() stable markdown"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].content",
          "text": "Format a deterministic markdown evidence report."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].title",
          "text": "Checkpoint: invariant audit report"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].content",
          "text": "Export deterministic invariant audit checkpoint artifacts."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should capture deterministic summary fields only."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[1]",
          "text": "No wall-clock timestamps in exported artifact."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why use deterministic cost models before microbenchmarks?"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable regression signals in CI"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They replace all profiling"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Deterministic models make relative regressions easy to catch early."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].title",
          "text": "Data structures: Vec, HashMap, BTreeMap tradeoffs"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].title",
          "text": "Explorer: cost model sandbox"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].title",
          "text": "Compute Budget Profiler (Sim)"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].title",
          "text": "Challenge: implement CostModel::estimate()"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].content",
          "text": "Estimate deterministic operation costs from fixed weighting rules."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].title",
          "text": "Challenge: optimize function metrics"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[0]",
          "text": "Treat optimization as deterministic metric diffs, not runtime benchmarking."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[1]",
          "text": "Clamp reduced metrics at zero."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].title",
          "text": "Challenge: model serialization overhead"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[0]",
          "text": "Show why repeated encode/decode loops are expensive."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[1]",
          "text": "Keep the model deterministic by counting bytes instead of timing."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].content",
          "text": "Generate stable optimization suggestions from deterministic metrics."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[0]",
          "text": "Output suggestions as a stable, sorted list."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[1]",
          "text": "Use threshold-based recommendations to avoid noisy advice."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].title",
          "text": "Checkpoint: stable perf report"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].hints[1]",
          "text": "Use deterministic percentage rounding."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].title",
          "text": "Async fundamentals: futures, tasks, channels"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].title",
          "text": "Reorg-safe Async Pipeline Project Journey"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].title",
          "text": "Challenge: implement Pipeline::run()"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].hints[1]",
          "text": "No real timers; simulate progression by decrementing remaining ticks."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[1].title",
          "text": "Challenge: implement RetryPolicy schedule"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].title",
          "text": "Challenge: idempotency key dedupe"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].content",
          "text": "Deduplicate replay events by deterministic idempotency keys."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].hints[0]",
          "text": "Use idempotency keys to collapse duplicate replay events."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[3].content",
          "text": "Build deterministic snapshot state from simulated event streams."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].title",
          "text": "Checkpoint: pipeline run report"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint output should mirror deterministic pipeline run artifacts."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "It verifies expansion matches policy intent"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].title",
          "text": "Safety through codegen: constraint checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].title",
          "text": "Explorer: constraint builder to generated checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].content",
          "text": "Parse mini-DSL constraints into deterministic AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].hints[0]",
          "text": "Parse mini DSL lines into typed AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].content",
          "text": "Generate stable pseudo-code from parsed constraint AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[0]",
          "text": "Generate stable pseudo-code output from AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[1]",
          "text": "One deterministic line per constraint node."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].title",
          "text": "Challenge: deterministic golden-file checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].content",
          "text": "Compare generated check output against deterministic golden strings."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[0]",
          "text": "Golden tests compare generated output strings exactly."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[1]",
          "text": "Keep check output deterministic to make golden tests meaningful."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].content",
          "text": "Execute generated constraints on deterministic sample input."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].hints[1]",
          "text": "Return deterministic failure reasons."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].title",
          "text": "Checkpoint: generated safety report"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].content",
          "text": "Export deterministic markdown safety report from generated checks."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].hints[0]",
          "text": "Render a deterministic markdown report from generated check results."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].title",
          "text": "Upgrade authority lifecycle in Anchor programs"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Compare approved build hash to expected programdata hash policy input"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Rely on signer memory without written report"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is release communication part of upgrade safety?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Because Anchor automatically writes support tickets"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because all upgrades are backward compatible"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].title",
          "text": "Explorer: upgrade risk matrix"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].title",
          "text": "Challenge: implement migration step planner"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].hints[1]",
          "text": "requiresMigration should be true only when toVersion > fromVersion."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].title",
          "text": "Challenge: implement upgrade safety gate checks"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[1]",
          "text": "Return issueCount plus ordered issue code array."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[2]",
          "text": "Keep order stable to make report diffs deterministic."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What should happen first when rollback trigger thresholds are hit?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Continue migration batches to avoid confusion"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Delete all historical reports"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Trigger conditions should map to immediate deterministic response actions."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add deterministic fixtures after an incident?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "To prove policy changes prevent the same failure path"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To increase deploy complexity without benefit"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "To replace all code reviews"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].title",
          "text": "Challenge: build stable upgrade markdown summary"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].hints[2]",
          "text": "Return plain markdown string without trailing spaces."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].title",
          "text": "Checkpoint: upgrade readiness artifact"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[0]",
          "text": "ready is true only when issueCount equals 0."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[1]",
          "text": "Return stable keys in releaseTag, ready, migrationBatches order."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[2]",
          "text": "Checkpoint output should be machine-readable deterministic JSON."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[0]",
          "text": "Use match on the BackoffStrategy enum to handle each case"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[2]",
          "text": "should_retry simply checks if attempt is less than max_attempts"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].content",
          "text": "Implement a deadline management system to enforce time limits on operations."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].hints[0]",
          "text": "Store the absolute expiration timestamp in the Deadline struct"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].content",
          "text": "Implement a fallback mechanism that provides alternative execution paths when primary operations fail."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].hints[1]",
          "text": "Only call fallback if primary returns None"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].hints[1]",
          "text": "record_success should reset everything to Closed state"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[0]",
          "text": "Always refill before checking if consumption is possible"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[2]",
          "text": "Use min() to ensure tokens don't exceed capacity"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].content",
          "text": "Implement an error classification system to determine if errors are retryable."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[1]",
          "text": "should_retry can use matches! macro or match on classify result"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[2]",
          "text": "batch_classify can use iter().map().collect() pattern"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].title",
          "text": "Test Assertion Framework Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].hints[1]",
          "text": "Use format! to create descriptive error messages"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[2].hints[0]",
          "text": "Use vec![0; size] to create zero-filled data of specified size"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].title",
          "text": "Test Scenario Builder Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].hints[1]",
          "text": "Push strings into vectors (use to_string() to convert &str)"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].title",
          "text": "Fuzz Input Generator Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].hints[1]",
          "text": "Generate bytes by taking random % 256"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[2].content",
          "text": "Implement a property verifier that checks invariants hold across operations."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].title",
          "text": "Boundary Value Analyzer Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[1]",
          "text": "Typical value is the midpoint of the range"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[2]",
          "text": "Return all 7 boundary values as test cases"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].content",
          "text": "Implement a compute unit counter to estimate operation costs."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[0]",
          "text": "Loop cost is overhead plus iterations times per-iteration cost"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[2]",
          "text": "Apply safety margin by multiplying budget by the percentage"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].title",
          "text": "Data Structure Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[0]",
          "text": "Use copy_from_slice to write data efficiently"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[1]",
          "text": "Track the highest written position as 'used'"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[2]",
          "text": "Always check bounds before read/write operations"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].title",
          "text": "Batch Operation Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].content",
          "text": "Optimize batch operations to minimize compute units."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[0]",
          "text": "Use to_le_bytes() to convert integers to bytes"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[1]",
          "text": "Use from_le_bytes() to convert bytes back to integers"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[2]",
          "text": "Alignment formula: if remainder, add (alignment - remainder)"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[0]",
          "text": "Annual rent is data size times lamports per byte per year"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[1]",
          "text": "Exemption threshold is annual rent times threshold years"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[2]",
          "text": "Check if balance is greater than or equal to minimum"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].title",
          "text": "Zero-Copy Deserializer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[0]",
          "text": "Use copy_from_slice to read fixed-size data into stack arrays"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[2]",
          "text": "Always advance offset after reading"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].title",
          "text": "Vesting Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[0]",
          "text": "Use saturating_sub to avoid underflow when calculating elapsed time"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[2]",
          "text": "Releasable is simply vested minus already released"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].title",
          "text": "Token Allocation Distributor Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[0]",
          "text": "Use iter().map().sum() to calculate total percentage"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[2]",
          "text": "Use find() to locate allocation by recipient"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].title",
          "text": "Release Schedule Generator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].hints[0]",
          "text": "Divide duration by intervals to get interval duration"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[0]",
          "text": "Use compound interest formula: A = P(1 + r/n)^(nt)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[1]",
          "text": "Convert basis points to decimal by dividing by 10000"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[0]",
          "text": "If delegated_to is Some, voting power is 0 (they gave it away)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[1]",
          "text": "Use filter to find voters who delegated to a specific address"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[2]",
          "text": "Sum staked amounts to calculate delegated power"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].title",
          "text": "Proposal Threshold Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].hints[0]",
          "text": "Convert basis points to amount: (supply * bps) / 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[1].title",
          "text": "Constant Product AMM Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].title",
          "text": "Liquidity Provider Calculator Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].hints[2]",
          "text": "Rewards are proportional to LP token holdings"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].content",
          "text": "Implement a time-weighted average price oracle."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[0]",
          "text": "Use retain() to filter out old observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[1]",
          "text": "Calculate duration between consecutive observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[2]",
          "text": "TWAP is weighted sum divided by total duration"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[0]",
          "text": "Max borrow is collateral value times LTV ratio"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[1]",
          "text": "Position is liquidatable when borrowed exceeds threshold * value"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[2]",
          "text": "Health factor shows how close to liquidation (higher is safer)"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].title",
          "text": "Interest Rate Model Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].content",
          "text": "Implement a utilization-based interest rate model."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].hints[0]",
          "text": "Utilization is borrowed divided by supplied"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].content",
          "text": "Implement flash loan validation logic."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[0]",
          "text": "Fee is amount times fee_bps divided by 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[1]",
          "text": "Total repay is principal plus fee"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[1].title",
          "text": "NFT Metadata Parser Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[2].hints[2]",
          "text": "Only verify if collection is complete"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].title",
          "text": "Attribute Rarity Calculator Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].content",
          "text": "Calculate NFT attribute rarity scores."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[0]",
          "text": "Rarity percentage is (count / total) * 100"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[1]",
          "text": "Rarity score is inverse of rarity (1 / rarity)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[1].hints[2]",
          "text": "Use any() to check if address is in restrictions list"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].title",
          "text": "Dynamic NFT Updater Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].content",
          "text": "Implement dynamic NFT attributes that can evolve over time."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[1]",
          "text": "Update last_updated timestamp after successful update"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[2]",
          "text": "Time until update is max(0, next_update - current_time)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[3].hints[2]",
          "text": "Filter equipped items by matching type in items list"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[1].hints[2]",
          "text": "Privilege extension: if caller is signer, child can sign too"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[0]",
          "text": "Convert string seeds to bytes using as_bytes()"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[1]",
          "text": "Simulate PDA finding by trying different bump values"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[0]",
          "text": "Use HashMap insert to register handlers"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[1]",
          "text": "Route by looking up instruction_type in handlers map"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].title",
          "text": "Atomic Swap Orchestrator Challenge"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].content",
          "text": "Implement an atomic swap across multiple programs."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].hints[1]",
          "text": "Atomicity requires output_token of step N equals input_token of step N+1"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[2].content",
          "text": "Validate state consistency across multiple CPI calls."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[0]",
          "text": "Push permission into vector to register"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[2]",
          "text": "Use retain() to remove caller from allowed list"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].title",
          "text": "Arbitrage Opportunity Detector Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].content",
          "text": "Detect arbitrage opportunities across DEXes."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[1]",
          "text": "Profit percent is (sell - buy) / buy * 100"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[2]",
          "text": "Use max_by to find best opportunity"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].title",
          "text": "Liquidation Opportunity Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[0]",
          "text": "Position is liquidatable when borrowed > threshold * collateral_value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[2]",
          "text": "Liquidation profit is bonus percentage of collateral value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].title",
          "text": "Priority Fee Calculator Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[0]",
          "text": "Urgency factor scales the base fee"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[1]",
          "text": "Execution probability decreases as more fees are higher"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[0]",
          "text": "Tip is percentage of total profit"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[1]",
          "text": "Bundle is profitable if profit exceeds tip"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].title",
          "text": "Multi-Hop Arbitrage Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].content",
          "text": "Find multi-hop arbitrage paths across token pairs."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[1]",
          "text": "Two-hop arbitrage goes A -> B -> A through different pools"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[2]",
          "text": "Profit is final output minus initial input"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].title",
          "text": "MEV Simulation Engine Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].content",
          "text": "Simulate MEV extraction to estimate profitability."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].hints[2]",
          "text": "Expected value weights profit by success probability"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[0]",
          "text": "Push config into vector to add"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[1]",
          "text": "Use find() to locate config by environment name"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[0]",
          "text": "Compare binary length against MAX_PROGRAM_SIZE"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[2]",
          "text": "Compression ratio shows percentage size reduction"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].title",
          "text": "Upgrade Authority Manager Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[0]",
          "text": "Push metadata into vector to register"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[1]",
          "text": "can_upgrade checks if authority matches stored authority"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[0]",
          "text": "Track seen stages to enforce ordering constraints"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[2]",
          "text": "Can skip build/test if only documentation files changed"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].title",
          "text": "Version Compatibility Checker Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[1]",
          "text": "Compatibility requires same major, actual >= required"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[2]",
          "text": "Use min_by to find smallest compatible version"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].title",
          "text": "Cross-Chain Messaging Architecture"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].content",
          "text": "Implement VAA (Verified Action Approval) signature verification."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[0]",
          "text": "Check signatures length against MIN_SIGNERS first"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[2]",
          "text": "Quorum is 2/3 of total guardians rounded up"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[0]",
          "text": "Increment sequence before creating message"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[2]",
          "text": "Verify message sequence is within emitted range"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[0]",
          "text": "Use contains() to check if sequence was processed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[1]",
          "text": "Return error if trying to mark already-processed sequence"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[2]",
          "text": "Use retain() to filter out old sequences"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[1].hints[1]",
          "text": "Verify requester matches owner before unlocking"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].title",
          "text": "Wrapped Token Mint Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].hints[1]",
          "text": "Check bounds before minting/burning"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].title",
          "text": "Bridge Rate Limiter Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[0]",
          "text": "Reset window before checking if duration passed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[1]",
          "text": "Only consume if total won't exceed max"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[1].hints[1]",
          "text": "Confidence ratio: conf / |price| < threshold"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[0]",
          "text": "Multiplier formula: smoothing / (period + 1)"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[1]",
          "text": "First EMA equals first price"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[2]",
          "text": "Subsequent EMAs use weighted average formula"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].title",
          "text": "Median Price Calculator Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].content",
          "text": "Calculate median price from multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].hints[2]",
          "text": "Use retain() to filter out outliers"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].content",
          "text": "Implement consensus checking across multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[0]",
          "text": "Check minimum sources first"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[2]",
          "text": "Agreement percent is (agreeing / total) * 100"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].title",
          "text": "Fallback Oracle Manager Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[0]",
          "text": "Store sources in priority order"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[1]",
          "text": "current_source index tracks which is active"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[2]",
          "text": "Fallback if index > 0 (not primary)"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].title",
          "text": "Proposal Lifecycle Manager Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].hints[1]",
          "text": "Voting active only during time window in Active state"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[0]",
          "text": "Delegated voters have 0 voting power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[1]",
          "text": "Quadratic voting uses square root of balance"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[2]",
          "text": "Apply cap after calculating base power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].content",
          "text": "Manage vote delegation between DAO members."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].hints[0]",
          "text": "Remove existing delegation before creating new one"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].title",
          "text": "Treasury Spending Limit Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].hints[1]",
          "text": "Reset period if duration has passed"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[2].hints[2]",
          "text": "Remove operation from list to cancel"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].title",
          "text": "Automated Action Trigger Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[1]",
          "text": "Match on condition type to evaluate"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[2]",
          "text": "Only return non-triggered actions that meet conditions"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[1].hints[1]",
          "text": "Turn complete when all players submitted"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].title",
          "text": "Game State Compressor Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[0]",
          "text": "Use bit shifting to pack x in high 4 bits, y in low 4 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[2]",
          "text": "Health stored as percentage (0-100) fits in 7 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].title",
          "text": "Player Progression Tracker Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[0]",
          "text": "XP formula: base * multiplier^(level-1)"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[1]",
          "text": "Keep leveling up while XP exceeds requirement"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[2]",
          "text": "Check contains() before adding achievement"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[1].hints[1]",
          "text": "Verify by recomputing hash from reveal"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[2].hints[2]",
          "text": "4d6 drop lowest: roll 4, sum all, subtract minimum"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[1]",
          "text": "Generate random number in range [0, total)"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[2]",
          "text": "Find item where cumulative weight exceeds roll"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].title",
          "text": "Storage Cost Estimator Challenge"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].content",
          "text": "Estimate Arweave storage costs based on data size."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].hints[0]",
          "text": "Calculate winston cost then convert to USD"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[3].hints[0]",
          "text": "Sort items by priority before bundling"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[0]",
          "text": "Validate tx_id length before adding"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[1]",
          "text": "Resolve in order: exact, index, fallback"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[0]",
          "text": "Push item to vector to add"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[1]",
          "text": "Filter items where any tag matches"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].title",
          "text": "Staking Rewards Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].hints[0]",
          "text": "Apply commission as (1 - commission) multiplier"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[2].hints[0]",
          "text": "Weight factors: commission 40%, uptime 40%, skip rate 20%"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[0]",
          "text": "Target is total divided by count, clamped to min/max"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[2]",
          "text": "Check all allocations within tolerance percentage"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[1].hints[0]",
          "text": "Sum all cost components"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[2].title",
          "text": "Epoch Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[0]",
          "text": "Only inactive stakes can be activated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[1]",
          "text": "Only active stakes can be deactivated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[2]",
          "text": "Fully active after warmup_epochs from activation"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[1].hints[0]",
          "text": "Use contains() to check ownership"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[2].hints[1]",
          "text": "Check guardian status before approving"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].title",
          "text": "Session Key Manager Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[0]",
          "text": "Valid if current time before expiration"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[2]",
          "text": "Remaining is max minus used"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].title",
          "text": "Spending Limit Enforcer Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[0]",
          "text": "Reset counters before checking"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[1]",
          "text": "Check all three limits: per-tx, daily, weekly"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[2]",
          "text": "Reset daily if new day, weekly if 7+ days passed"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[2].hints[1]",
          "text": "Check contains() before adding"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[3].title",
          "text": "Time Lock Enforcer Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[0]",
          "text": "Try bumps from 255 down to 0"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[2]",
          "text": "Check if derived address matches expected"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[2].hints[2]",
          "text": "Collect into Vec<Vec<u8>>"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[3].hints[1]",
          "text": "Signer seeds include all seeds plus bump"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].title",
          "text": "Nested PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].content",
          "text": "Generate PDAs derived from other PDA addresses."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].hints[0]",
          "text": "Include parent address in child seeds"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].title",
          "text": "Counter PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].content",
          "text": "Generate unique PDAs using incrementing counters."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[0]",
          "text": "Increment counter after each generation"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[2]",
          "text": "Batch generation calls generate_next multiple times"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].title",
          "text": "PDA Collision Detector Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[0]",
          "text": "Check if seeds match any existing entry"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[1]",
          "text": "Return error if collision detected"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[1]",
          "text": "Compound inflation year over year"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[2]",
          "text": "APY is inflation divided by staked percentage"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].title",
          "text": "Fee Burn Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].hints[1]",
          "text": "Burn is percentage of total fee"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].title",
          "text": "Rent Economics Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[0]",
          "text": "Annual rent is bytes times rate"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[1]",
          "text": "Exemption is annual times threshold years"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[2]",
          "text": "Rent due is annual times period"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].title",
          "text": "Supply Flow Tracker Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[0]",
          "text": "Total excludes burned tokens"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[1]",
          "text": "Apply flow by subtracting from source, adding to destination"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[2]",
          "text": "Net flow is inflow minus outflow"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].title",
          "text": "Vesting Schedule Impact Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].content",
          "text": "Calculate token unlock impact on supply."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[0]",
          "text": "0 before cliff, linear after, full at end"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[1]",
          "text": "Monthly unlock is difference between consecutive months"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[2]",
          "text": "Check multiple months to find peak"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].title",
          "text": "Protocol Sustainability Score Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[0]",
          "text": "Net issuance is inflation minus burn"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[1]",
          "text": "Burn ratio is burn divided by inflation"
        }
      ],
      "englishLikeMatches": [
        {
          "path": "courses.solana-fundamentals.description",
          "englishWordCount": 19,
          "excerpt": "Introducao de nivel de producao para iniciantes que querem modelos mentais claros de Solana, debugging de transacoes mais forte e workflows deterministas de wallet manager."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Core execution model, conta semantics, e transacao construction patterns you need before writing programs or complex clients."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].content",
          "englishWordCount": 269,
          "excerpt": "# Solana modelo mental Solana development gets much easier once you stop thinking in terms of \"contracts that own state\" e start thinking in terms of \"programs that operate on contas.\" On Solana, the durable state of you..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 17,
          "excerpt": "On Solana, mutable app state is conta data. Programs validate e mutate those contas but do not hold mutable state internally."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "The runtime checks the message envelope e authorization: fee payer, freshness via blockhash, required signatures, e instrucao payloads."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].explanation",
          "englishWordCount": 12,
          "excerpt": "Read/write sets let the runtime detect conflicts e parallelize independent work deterministically."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].content",
          "englishWordCount": 243,
          "excerpt": "# Contas model analise profunda Every on-chain object on Solana is an conta com a standard envelope. You can reason about any conta using a small set of fields: address, lamports, owner, executable flag, e data bytes len..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Executable contas are code containers; they are not ordinary mutable data contas."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].explanation",
          "englishWordCount": 13,
          "excerpt": "SPL token state uses dedicated conta layouts e authorization rules enforced by the token program."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].content",
          "englishWordCount": 303,
          "excerpt": "# Transacoes & instrucoes An instrucao is the smallest executable unit on Solana: `programId + account metas + opaque data bytes`. A transacao wraps one or more instrucoes plus signatures e message metadata. This design ..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].content",
          "englishWordCount": 61,
          "excerpt": "# Build a SOL transfer transacao Implement a deterministic `buildTransferTx(params)` helper in the project file: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` - Use `@solana/web3.js` - Return a transac..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[2]",
          "englishWordCount": 14,
          "excerpt": "Mirror this logic in the real project helper in src/lib/cursos/solana-fundamentals/project/walletManager.ts."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Program behavior, deterministic PDA design, e SPL token modelo mentals com pratico safety checks."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].content",
          "englishWordCount": 240,
          "excerpt": "# Programs: what they are (e aren’t) A Solana program is executable conta code, not an object that secretly owns mutable storage. Your program receives contas from the transacao, verifies constraints, e writes only to co..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Conta lists are part of the instrucao contract; hidden discovery would break determinism e scheduling assumptions."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].content",
          "englishWordCount": 235,
          "excerpt": "# Enderecos Derivados de Programa (PDAs) A Endereco Derivado de Programa (PDA) is a deterministic conta address derived from seeds plus a program ID, com one key property: it is intentionally off-curve, so no private key..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "invoke_signed proves seed derivation to runtime, which grants PDA signer semantics para that invocation."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].content",
          "englishWordCount": 230,
          "excerpt": "# SPL Tokens fundamentos SPL Token is Solana’s standard token program family para fungible assets. A token mint conta defines token-level configuration: decimals, total supply accounting, e authorities such as mint autho..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "Associated Token Contas standardize where fungible token balances are stored para each owner/mint."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "englishWordCount": 13,
          "excerpt": "Carteiras can only hold SOL while token balances are separate program-owned contas"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "SPL balances are state in token contas, not direct fields on carteira system contas."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].content",
          "englishWordCount": 53,
          "excerpt": "# Carteira Manager CLI-sim Implement a deterministic CLI parser + command executor in: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` Required behavior: - `address` prints the active pubkey - `build-tra..."
        },
        {
          "path": "courses.anchor-development.description",
          "englishWordCount": 20,
          "excerpt": "Curso orientado a projetos para evoluir do basico para engenharia real com Anchor: modelagem deterministica de contas, builders de instrucoes, disciplina de testes e UX de cliente confiavel."
        },
        {
          "path": "courses.anchor-development.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Anchor architecture, conta constraints, e PDA foundations com explicit ownership of seguranca-critical decisions."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].content",
          "englishWordCount": 350,
          "excerpt": "# Anchor modelo mental Anchor is best understood as a contract between three layers that must agree on shape: your Rust handlers, generated interface metadata (IDL), e client-side instrucao builders. In raw Solana progra..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].content",
          "englishWordCount": 264,
          "excerpt": "# Contas, constraints, e safety Most serious Solana vulnerabilities come from conta validation mistakes, not from arithmetic. Anchor’s constraint system exists to turn those checks into declarative, auditable rules. You ..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].content",
          "englishWordCount": 242,
          "excerpt": "# PDAs in Anchor Enderecos Derivados de Programa are the backbone of predictable conta topology in Anchor applications. A PDA is derived from seed bytes plus program ID e intentionally lives off the ed25519 curve, so no ..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].content",
          "englishWordCount": 67,
          "excerpt": "# Initialize Counter PDA (deterministic) Implement deterministic helper functions para a Counter project: - `deriveCounterPda(programId, authorityPubkey)` - `buildInitCounterIx(params)` This licao validates client-side r..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[1]",
          "englishWordCount": 15,
          "excerpt": "The init instrucao must include four keys in fixed order: counter PDA, authority, payer, system program."
        },
        {
          "path": "courses.anchor-development.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Deterministic instrucao builders, stable state emulation, e testes strategy that separates pure logic from network integration."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].content",
          "englishWordCount": 40,
          "excerpt": "# Increment instrucao builder + state layout Implement deterministic increment behavior in pure TypeScript: - Build a reusable state representation para counter data. - Implement `applyIncrement` as a pure transition fun..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].content",
          "englishWordCount": 245,
          "excerpt": "# Testes strategy without flakiness A reliable Solana curriculum should teach deterministic engineering first, then optional network integration. Flaky tests are usually caused by external dependencies: RPC latency, fauc..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].content",
          "englishWordCount": 253,
          "excerpt": "# Client composition & UX Once instrucao layouts e PDA logic are deterministic, client integration becomes a composition exercise: carteira adapter para signing, provider/connection para transport, transacao builder para..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].content",
          "englishWordCount": 49,
          "excerpt": "# Counter project checkpoint Compose the full deterministic flow: 1. Derive counter PDA from authority + program ID. 2. Build init instrucao metadata. 3. Build increment instrucao metadata. 4. Emulate state transitions: ..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[1]",
          "englishWordCount": 13,
          "excerpt": "Use fixed key order e fixed JSON key order to satisfy strict expected output matching."
        },
        {
          "path": "courses.solana-frontend.description",
          "englishWordCount": 20,
          "excerpt": "Curso orientado a projetos para engenheiros frontend que querem dashboards Solana prontos para producao: reducers deterministas, pipelines de eventos reproduziveis e UX de transacao confiavel."
        },
        {
          "path": "courses.solana-frontend.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Modele corretamente estado de wallet/contas, desenhe UX do ciclo de vida de transacoes e imponha regras deterministicas para debugging reproduzivel."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].content",
          "englishWordCount": 468,
          "excerpt": "# Carteira state + contas modelo mental para UI devs Most Solana frontend bugs are not visual bugs. They are model bugs. A dashboard can look polished while silently computing balances from the wrong conta class, mixing ..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].content",
          "englishWordCount": 355,
          "excerpt": "# Transacao lifecycle para UI: pending/confirmed/finalized, optimistic UI Frontend transacao UX is a state machine problem. Users press one button, but your app traverses multiple phases: intent creation, transacao const..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].content",
          "englishWordCount": 354,
          "excerpt": "# Data correctness: dedupe, ordering, idempotency, correction events Frontend teams frequently assume event streams are perfectly ordered e unique. Production systems rarely behave that way. You can receive duplicate eve..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].content",
          "englishWordCount": 34,
          "excerpt": "# Build core state model + reducer from events Implement a deterministic reducer para dashboard state: - apply event stream transitions para balances e mint metadata - enforce idempotency by event id - support correction..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Corrections should mark replaced event ids e remove their effects from state transitions."
        },
        {
          "path": "courses.solana-frontend.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Construa reducer, snapshots de replay, metricas de consulta e outputs deterministicas de dashboard estaveis sob dados parciais ou atrasados."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].content",
          "englishWordCount": 28,
          "excerpt": "# Implement event stream simulator + replay timeline + snapshots Build deterministic replay tooling: - replay sorted events by (ts, id) - snapshot every N applied events - compute stable checksum para replay output - ret..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].content",
          "englishWordCount": 30,
          "excerpt": "# Implement query layer + computed metrics Implement dashboard query/view logic: - search/filter/sort rows deterministically - compute total e row valueUsd com fixed-scale integer math - expose stable view model para UI ..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].content",
          "englishWordCount": 386,
          "excerpt": "# Production UX: caching, pagination, error banners, skeletons, rate limits After model correctness, frontend quality is mostly about user trust under imperfect conditions. Users do not evaluate your dashboard by clean d..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[3].content",
          "englishWordCount": 27,
          "excerpt": "# Emit stable DashboardSummary from fixtures Compose deterministic checkpoint output: - owner, token count, totalValueUsd - top tokens sorted deterministically - recent activity rows - invariants e determinism metadata (..."
        },
        {
          "path": "courses.defi-solana.description",
          "englishWordCount": 21,
          "excerpt": "Curso avancado orientado a projetos para engenheiros que constroem sistemas de swap: planejamento offline deterministico no estilo Jupiter, ranking de rotas, seguranca de minOut e diagnosticos reproduziveis."
        },
        {
          "path": "courses.defi-solana.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Entenda matematica CPMM, anatomia de cotacao e tradeoffs de roteamento deterministico com protecoes de usuario orientadas a seguranca."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].content",
          "englishWordCount": 521,
          "excerpt": "# AMM fundamentos on Solana: pools, fees, slippage, e impacto no preco When users click “Swap,” they usually assume there is one objective truth: the current price. In practice, frontend swap systems compute an estimate ..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].content",
          "englishWordCount": 390,
          "excerpt": "# Quote anatomy: in/out, fees, minOut, e worst-case execution A production quote is not one number. It is a structured object that must tell users what they send, what they likely receive, how much they pay in fees, e wh..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].content",
          "englishWordCount": 407,
          "excerpt": "# Routing: why two-hop can beat one-hop Users often assume direct pair routes are always best because they are simpler. In fragmented liquidity systems, that assumption fails frequently. A direct SOL -> JUP pool might ha..."
        },
        {
          "path": "courses.defi-solana.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Construa cotacao deterministica, selecao de rota e checks de seguranca minOut; depois empacote artefatos de checkpoint estaveis para revisoes reproduziveis."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].content",
          "englishWordCount": 29,
          "excerpt": "# Implement route enumeration e best-route selection Implement deterministic route planner: - enumerate one-hop e two-hop candidates - quote each candidate at exact input size - select best route using stable tie-breaker..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].content",
          "englishWordCount": 35,
          "excerpt": "# Implement slippage/minOut, fee breakdown, e safety invariants Implement deterministic safety layer: - apply slippage to compute minOut - simulate route com virtual reserve updates - return structured errors para invali..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].content",
          "englishWordCount": 404,
          "excerpt": "# Production swap UX: stale quotes, protection, e simulation A deterministic route engine is necessary but not sufficient para production. Users experience DeFi through timing, messaging, e safety affordances. A mathemat..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].content",
          "englishWordCount": 29,
          "excerpt": "# Produce stable SwapPlan + SwapSummary checkpoint Compose deterministic checkpoint artifacts: - build swap plan from selected route quote - include fixtureHash e modelVersion - emit stable summary com path, minOut, fee ..."
        },
        {
          "path": "courses.solana-security.description",
          "englishWordCount": 18,
          "excerpt": "Laboratorio deterministico de vulnerabilidades para auditores Solana que precisam de evidencia de exploit repetivel, orientacao precisa de remediacao e artefatos de auditoria de alto sinal."
        },
        {
          "path": "courses.solana-security.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Modelagem de ameacas centrada em contas, reproducao deterministica de exploits e disciplina de evidencia para achados de auditoria confiaveis."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].content",
          "englishWordCount": 562,
          "excerpt": "# Solana threat model para auditors: contas, owners, signers, writable, PDAs Seguranca work on Solana starts com one non-negotiable fact: instrucao callers choose the conta list. Programs do not receive trusted implicit ..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Without owner checks, conta substitution allows attacker-controlled bytes to be parsed as trusted state."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].content",
          "englishWordCount": 445,
          "excerpt": "# Evidence chain: reproduce, trace, impact, fix, verify Strong seguranca reports are built on evidence chains, not opinions. In the Solana context, that means moving from a claim such as “missing signer check exists” to ..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].content",
          "englishWordCount": 475,
          "excerpt": "# Common Solana bug classes e mitigations Auditors on Solana repeatedly encounter the same core bug families. The implementation details differ across protocols, but exploit mechanics are surprisingly consistent: identit..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "Seguranca failures are usually adversarial edge cases, so tests must target those edges directly."
        },
        {
          "path": "courses.solana-security.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Explorar, corrigir, verificar e produzir artefatos prontos para auditoria com traces deterministicas e conclusoes baseadas em invariantes."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].content",
          "englishWordCount": 43,
          "excerpt": "# Break it: exploit missing signer + owner checks Implement a deterministic exploit-proof formatter para signer/owner vulnerabilities. Expected output fields: - scenario - before/after vault balance - before/after recipi..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].content",
          "englishWordCount": 30,
          "excerpt": "# Break it: exploit PDA spoof mismatch Implement a deterministic PDA spoof proof output. You must show: - expected PDA - accepted PDA - mismatch boolean - trace hash This licao validates evidence generation para derivati..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].content",
          "englishWordCount": 30,
          "excerpt": "# Fix it: validations + invariant suite Implement patch validation output that confirms: - signer check - owner check - PDA check - safe u64 arithmetic - exploit blocked state com error code Keep output deterministic par..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].content",
          "englishWordCount": 455,
          "excerpt": "# Writing audit reports: severity, likelihood, blast radius, remediation A strong audit report is an engineering document, not a narrative essay. It should allow a reader to answer four questions quickly: what failed, ho..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].content",
          "englishWordCount": 29,
          "excerpt": "# Checkpoint: deterministic AuditReport JSON + markdown Create the final deterministic checkpoint payload: - curso + version - scenario IDs - finding count This checkpoint mirrors the final curso artifact produced by the..."
        },
        {
          "path": "courses.token-engineering.description",
          "englishWordCount": 20,
          "excerpt": "Curso orientado a projetos para equipes que lancam tokens Solana reais: planejamento deterministico de Token-2022, design de autoridades, simulacao de supply e disciplina operacional de lancamento."
        },
        {
          "path": "courses.token-engineering.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Entenda primitivas de token, anatomia da politica de mint e controles de extensao do Token-2022 com enquadramento explicito de governanca e ameacas."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].content",
          "englishWordCount": 392,
          "excerpt": "# SPL tokens vs Token-2022: what extensions change Token engineering starts com a clean boundary between base token semantics e configurable policy. Legacy SPL Token gives you a stable fungible primitive: mint metadata, ..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].content",
          "englishWordCount": 365,
          "excerpt": "# Mint anatomy: authorities, decimals, supply, freeze, mint A production token launch succeeds or fails on parameter discipline. The mint conta is a compact policy object: it defines decimal precision, minting authority,..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].content",
          "englishWordCount": 360,
          "excerpt": "# Extension safety pitfalls: fee configs, delegate abuse, default conta state Token-2022 extensions let teams express policy in a standard token framework, but policy power is exactly where operational failures happen. S..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].content",
          "englishWordCount": 35,
          "excerpt": "# Validate token config + derive deterministic addresses offline Implement strict config validation e deterministic pseudo-derivation: - validate decimals, u64 strings, recipient totals, extension fields - derive stable ..."
        },
        {
          "path": "courses.token-engineering.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Construa fluxos deterministicos de validacao, planejamento e simulacao que produzam artefatos de lancamento revisaveis e criterios claros de go/no-go."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].content",
          "englishWordCount": 32,
          "excerpt": "# Build Token-2022 initialization instrucao plan Create a deterministic offline initialization plan: - create mint conta step - init mint step com decimals - append selected extension steps in stable order - base64 encod..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].hints[0]",
          "englishWordCount": 12,
          "excerpt": "Add base steps first: create mint conta, then initialize mint com decimals."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].content",
          "englishWordCount": 28,
          "excerpt": "# Build mint-to + transfer-fee math + simulation Implement pure simulation para transfer fees e launch distribution: - fee = min(maxFee, floor(amount * feeBps / 10000)) - aggregate distribution totals deterministically -..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].content",
          "englishWordCount": 359,
          "excerpt": "# Launch checklist: params, upgrade/authority strategy, airdrop/testes plan A successful token launch is an operations exercise as much as a programming task. By the time users see your token in carteiras, dozens of choi..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].content",
          "englishWordCount": 27,
          "excerpt": "# Emit stable LaunchPackSummary Compose full project output as stable JSON: - normalized authorities e extensions - supply totals e optional fee model examples - deterministic plan metadata e invariants - fixtures hash +..."
        },
        {
          "path": "courses.solana-mobile.description",
          "englishWordCount": 18,
          "excerpt": "Construa dApps Solana mobile prontas para producao com MWA, arquitetura robusta de sessao de wallet, UX explicita de assinatura e operacoes disciplinadas de distribuicao."
        },
        {
          "path": "courses.solana-mobile.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Protocolo base do MWA, controle do ciclo de vida de sessao e padroes resilientes de handoff de wallet para apps mobile em producao."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[0].content",
          "englishWordCount": 344,
          "excerpt": "# Mobile Carteira Visao geral Solana Mobile development is built around the Solana Mobile Stack (SMS), a set of standards e tooling designed para secure, high-quality crypto-native mobile experiences. SMS is more than a ..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[1].content",
          "englishWordCount": 237,
          "excerpt": "# MWA Integration Integrating Mobile Carteira Adapter typically starts com `@solana-mobile/mobile-wallet-adapter` APIs e an interaction pattern built around `transact()`. Within a transacao session, the app can authorize..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].content",
          "englishWordCount": 25,
          "excerpt": "# Build a Mobile Transacao Function Implement a helper that formats a deterministic MWA transacao request summary string. Expected output format: `<cluster>|<payer>|<instructionCount>` Use this exact order e delimiter."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[0].content",
          "englishWordCount": 261,
          "excerpt": "# dApp Store Submission Publishing to the Solana dApp Store requires more than packaging binaries. Teams should treat submission as a product, compliance, e seguranca review process. A strong submission demonstrates safe..."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[1].content",
          "englishWordCount": 284,
          "excerpt": "# Mobile Boas praticas Mobile crypto UX requires balancing speed, safety, e trust. Users make high-stakes decisions on small screens, often on unstable networks. Solana mobile apps should therefore optimize para explicit..."
        },
        {
          "path": "courses.solana-testing.description",
          "englishWordCount": 17,
          "excerpt": "Construa sistemas de teste Solana robustos em ambientes local, simulado e de rede com invariantes de seguranca explicitas e gates de confianca de qualidade de release."
        },
        {
          "path": "courses.solana-testing.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Estrategia central de testes em camadas unit/integration com fluxos deterministicos e cobertura de casos adversariais."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[0].content",
          "englishWordCount": 313,
          "excerpt": "# Testes Approaches Testes Solana programs requires multiple layers because failures can occur in logic, conta validation, transacao composition, or network behavior. A production testes strategy usually combines unit te..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[1].content",
          "englishWordCount": 244,
          "excerpt": "# Bankrun Testes Solana Bankrun provides deterministic, high-speed test execution para Solana programs from TypeScript environments. It emulates a local bank-like runtime where transacoes can be processed predictably, co..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[0].content",
          "englishWordCount": 249,
          "excerpt": "# Fuzzing com Trident Fuzzing explores large input spaces automatically to find bugs that handcrafted tests miss. Para Solana e Anchor programs, Trident-style fuzzing workflows generate randomized instrucao sequences e p..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[1].content",
          "englishWordCount": 220,
          "excerpt": "# Devnet Testes Devnet testes bridges the gap between deterministic local tests e real-world network conditions. While local validadores e Bankrun are ideal para speed e reproducibility, devnet reveals behavior under rea..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[2].content",
          "englishWordCount": 216,
          "excerpt": "# CI/CD Pipeline para Solana A mature Solana CI/CD pipeline enforces quality gates across code, tests, seguranca checks, e implantacao workflows. Para program teams, CI is not just linting Rust e TypeScript; it is about ..."
        },
        {
          "path": "courses.solana-indexing.description",
          "englishWordCount": 18,
          "excerpt": "Construa um indexador de eventos Solana de nivel de producao com decodificacao deterministica, contratos de ingestao resilientes, recuperacao por checkpoints e outputs analiticos confiaveis."
        },
        {
          "path": "courses.solana-indexing.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Modelo de eventos, decodificacao de conta token e parsing de metadados de transacao para pipelines de indexacao confiaveis."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].content",
          "englishWordCount": 318,
          "excerpt": "# Events model: transacoes, logs, e program instrucoes Indexing Solana starts com understanding where data lives e how to extract structured events from raw chain data. Unlike EVM chains where events are explicit log top..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Solana programs emit events via logs e state changes, not explicit event topics."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Idempotent ingestion ensures the same transacao processed twice creates only one event."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].content",
          "englishWordCount": 219,
          "excerpt": "# Token conta decoding e SPL layout SPL Token contas follow a standardized binary layout that indexers must parse to track balances e mint operations. Understanding this layout enables you to extract meaningful data from..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Standard SPL Token contas are 165 bytes, containing mint, owner, amount, e optional fields."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Amounts are stored as little-endian u64 e must be converted using the mint's decimal places."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[2].content",
          "englishWordCount": 52,
          "excerpt": "# Challenge: Decode token conta + diff token balances Implement deterministic token conta decoding e balance diffing: - Parse a 165-byte SPL Token conta layout - Extract mint, owner, e amount fields - Compute balance dif..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].content",
          "englishWordCount": 240,
          "excerpt": "# Transacao meta parsing: logs, errors, e inner instrucoes Transacao metadata provides the context needed to index complex operations. Understanding how to parse logs, handle errors, e traverse inner instrucoes enables c..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].content",
          "englishWordCount": 44,
          "excerpt": "# Challenge: Index transacoes to normalized events Implement a transacao indexer that produces normalized Event objects: - Parse instrucao logs e identify event types - Extract transfer events com from/to/amount/mint - H..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].content",
          "englishWordCount": 228,
          "excerpt": "# Pagination, checkpointing, e caching semantics Production indexers must handle large datasets efficiently while maintaining consistency. Pagination, checkpointing, e caching form the backbone of scalable indexing infra..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[2].content",
          "englishWordCount": 213,
          "excerpt": "# Analytics aggregation: per carteira, per token metrics Raw event data becomes valuable through aggregation. Building analytics pipelines enables insights into user behavior, token flows, e protocol usage patterns. Per-..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].content",
          "englishWordCount": 50,
          "excerpt": "# Checkpoint: Produce stable JSON analytics summary Implement the final analytics checkpoint that produces a deterministic summary: - Aggregate events into per-carteira e per-token metrics - Generate sorted, stable JSON ..."
        },
        {
          "path": "courses.solana-payments.description",
          "englishWordCount": 19,
          "excerpt": "Construa fluxos de pagamento Solana de nivel de producao com validacao robusta, idempotencia segura contra replay, webhooks seguros e recibos deterministas para conciliacao."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].content",
          "englishWordCount": 264,
          "excerpt": "# Address validation e memo strategies Payment flows on Solana require robust address validation e thoughtful memo strategies. Unlike traditional payment systems com conta numbers, Solana uses base58-encoded public keys ..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[1].content",
          "englishWordCount": 221,
          "excerpt": "# Idempotency keys e replay protection Payment systems must handle network failures gracefully. Idempotency ensures that retrying a failed request produces the same outcome as the original, preventing duplicate charges e..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].content",
          "englishWordCount": 48,
          "excerpt": "# Challenge: Create payment intent com validation Implement a payment intent creator com full validation: - Validate recipient address format (base58, 32 bytes) - Validate amount (positive, within limits) - Generate dete..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[3].content",
          "englishWordCount": 216,
          "excerpt": "# Transacao building e key metadata Building payment transacoes requires careful attention to instrucao construction, conta metadata, e program interactions. The goal is creating valid, efficient transacoes that minimize..."
        },
        {
          "path": "courses.solana-payments.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Construcao de transacao, verificacao de autenticidade de webhook e geracao deterministica de recibo com tratamento claro de estados de erro."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].content",
          "englishWordCount": 36,
          "excerpt": "# Challenge: Build transfer transacao Implement a transfer transacao builder: - Build SystemProgram.transfer para SOL transfers - Build TokenProgram.transfer para SPL transfers - Return instrucao bundle com correct key m..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].content",
          "englishWordCount": 187,
          "excerpt": "# Webhook signing e verification Webhooks enable asynchronous payment notifications. Seguranca requires cryptographic signing so recipients can verify webhook authenticity e detect tampering. Webhook signing uses HMAC-SH..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].content",
          "englishWordCount": 195,
          "excerpt": "# Error state machine e receipt format Payment flows require well-defined state machines to handle the complexity of asynchronous confirmations, failures, e retries. Clear state transitions e receipt formats ensure relia..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].content",
          "englishWordCount": 43,
          "excerpt": "# Challenge: Verify webhook e produce receipt Implement the final payment flow checkpoint: - Verify signed webhook signature (HMAC-SHA256) - Extract payment details from payload - Generate standardized receipt JSON - Inc..."
        },
        {
          "path": "courses.solana-nft-compression.description",
          "englishWordCount": 15,
          "excerpt": "Domine a engenharia de NFTs comprimidos na Solana: compromissos Merkle, sistemas de prova, modelagem de colecoes e checagens de seguranca de nivel producao."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Construcao de arvore, hashing de folha, mecanica de insercao e modelo de compromisso on-chain/off-chain por tras de ativos comprimidos."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].content",
          "englishWordCount": 278,
          "excerpt": "# Merkle trees para state compression Compressed NFTs (cNFTs) on Solana use Merkle trees to dramatically reduce storage costs. Understanding Merkle trees is essential para working com compressed NFTs e building compressi..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[1].content",
          "englishWordCount": 214,
          "excerpt": "# Leaf hashing conventions e metadata Leaf hashing determines how NFT metadata is committed to the Merkle tree. Understanding these conventions ensures compatibility com compression standards e proper proof generation. L..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].content",
          "englishWordCount": 42,
          "excerpt": "# Challenge: Implement Merkle tree insert + root updates Build a Merkle tree implementation com insertions: - Insert leaves e compute new root - Update parent hashes up the tree - Handle tree growth e depth limits - Retu..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].content",
          "englishWordCount": 227,
          "excerpt": "# Proof generation e path computation Merkle proofs enable verification of leaf inclusion without accessing the entire tree. Understanding proof generation is essential para working com compressed NFTs e building verific..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement proof generation + verifier Build a complete proof system: - Generate proofs from a Merkle tree e leaf index - Verify proofs against a root hash - Handle invalid proofs (wrong siblings, wrong index..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[1].content",
          "englishWordCount": 216,
          "excerpt": "# Collection mints e metadata simulation Compressed NFT collections use a collection mint as the parent NFT, enabling grouping e verification of related assets. Understanding this hierarchy is essential para building col..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].content",
          "englishWordCount": 254,
          "excerpt": "# Attack surface: invalid proofs e replay Compressed NFTs introduce unique seguranca considerations. Understanding attack vectors e mitigations is critical para building secure compression-aware applications. Invalid pro..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].content",
          "englishWordCount": 53,
          "excerpt": "# Checkpoint: Simulate mint + verify ownership proof Complete the compression lab checkpoint: - Simulate minting a cNFT (insert leaf, update root) - Generate ownership proof para the minted NFT - Verify the proof against..."
        },
        {
          "path": "courses.solana-governance-multisig.description",
          "englishWordCount": 18,
          "excerpt": "Construa sistemas de governanca DAO e tesouraria multisig prontos para producao com contabilizacao deterministica de votos, seguranca de timelock e controles de execucao seguros."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Ciclo de vida de propostas, mecanicas de votacao deterministicas, politica de quorum e seguranca de timelock para uma governanca DAO confiavel."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].content",
          "englishWordCount": 247,
          "excerpt": "# DAO model: proposals, voting, e execution Decentralized governanca on Solana follows a proposal-based model where token holders vote on changes e the DAO treasury executes approved decisions. Understanding this flow is..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[1].content",
          "englishWordCount": 185,
          "excerpt": "# Quorum math e vote weight calculation Accurate vote counting is critical para legitimate governanca outcomes. Understanding quorum requirements, vote weight calculation, e edge cases ensures fair decision-making. Quoru..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].content",
          "englishWordCount": 169,
          "excerpt": "# Timelock states e execution scheduling Timelocks provide a critical safety layer between governanca approval e execution. Understanding timelock states e transitions ensures reliable proposal execution. Timelock states..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Construcao de transacao multisig, controles de aprovacao, defesas contra replay e padroes seguros de execucao de tesouraria."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].content",
          "englishWordCount": 176,
          "excerpt": "# Multisig transacao building e approvals Multisig carteiras provide collective control over treasury funds. Understanding multisig construction, approval flows, e seguranca patterns is essential para treasury operations..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].content",
          "englishWordCount": 34,
          "excerpt": "# Challenge: Implement multisig tx builder + approval rules Build a multisig transacao system: - Create transacoes com instrucoes - Record signer approvals - Enforce threshold requirements - Handle approval revocation - ..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].content",
          "englishWordCount": 191,
          "excerpt": "# Safe defaults: owner checks e replay guards Governanca e multisig systems require robust seguranca defaults. Understanding common vulnerabilities e their mitigations protects treasury funds. Owner checks validate that ..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].content",
          "englishWordCount": 48,
          "excerpt": "# Challenge: Execute proposal e produce treasury diff Complete the governanca simulator checkpoint: - Execute approved proposals com timelock validation - Apply treasury state changes atomically - Generate execution trac..."
        },
        {
          "path": "courses.solana-performance.description",
          "englishWordCount": 17,
          "excerpt": "Domine a engenharia de performance na Solana com fluxos de otimizacao mensuraveis: compute budgets, layouts de dados, eficiencia de encoding e modelagem deterministica de custos."
        },
        {
          "path": "courses.solana-performance.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Modelo de compute, decisoes de layout de conta/dados e estimativa deterministica de custo para raciocinio de performance no nivel de transacao."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].content",
          "englishWordCount": 234,
          "excerpt": "# Compute model: budgets, costs, e limits Solana's compute model enforces deterministic execution limits through compute budgets. Understanding this model is essential para building efficient programs that stay within li..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[1].content",
          "englishWordCount": 198,
          "excerpt": "# Conta layout design e serialization cost Conta data layout significantly impacts compute costs. Well-designed layouts minimize serialization overhead e reduce conta access costs. Serialization formats affect cost. Bors..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement estimateCost(op) model Build a compute cost estimation system: - Model costs para different operation types - Conta para instrucao complexity - Include memory access costs - Return baseline measure..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].content",
          "englishWordCount": 172,
          "excerpt": "# Instrucao data size e encoding optimization Instrucao data size directly impacts transacao cost e throughput. Optimizing encoding reduces fees e increases the operations possible within compute limits. Compact encoding..."
        },
        {
          "path": "courses.solana-performance.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Otimizacao de layout, tuning de compute budget e analise before/after de performance com salvaguardas de corretude."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].content",
          "englishWordCount": 42,
          "excerpt": "# Challenge: Implement optimized layout/codec Optimize an conta data layout while preserving semantics: - Reduce data size through compact encoding - Maintain all original functionality - Preserve backward compatibility ..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].content",
          "englishWordCount": 176,
          "excerpt": "# Compute budget instrucao fundamentos Compute budget instrucoes give developers control over resource allocation e transacao prioritization. Understanding these tools enables precise optimization. setComputeUnitLimit re..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "Specific limits optimize costs - you pay para the limit requested, not actual usage."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].content",
          "englishWordCount": 172,
          "excerpt": "# Micro-optimizations e tradeoffs Desempenho optimization involves balancing competing concerns. Understanding tradeoffs helps make informed decisions about when e what to optimize. Readability vs desempenho is a constan..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].content",
          "englishWordCount": 40,
          "excerpt": "# Checkpoint: Compare before/after + output perf report Complete the optimization lab checkpoint: - Measure baseline desempenho metrics - Apply optimization techniques - Verify correctness is preserved - Generate desempe..."
        },
        {
          "path": "courses.defi-swap-aggregator.description",
          "englishWordCount": 16,
          "excerpt": "Domine a agregacao de swaps em producao na Solana: parsing deterministico de cotacoes, tradeoffs de otimizacao de rotas, seguranca de slippage e execucao orientada a confiabilidade."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Mecanica de swap de token, protecao de slippage, composicao de rotas e construcao deterministica de SwapPlan com tradeoffs transparentes."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].content",
          "englishWordCount": 403,
          "excerpt": "# Swap modelo mental: mints, ATAs, decimals, e routes Token swaps on Solana follow a fundamentally different model than centralized exchanges. Understanding the building blocks — mints, associated token contas (ATAs), de..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "AMM programs interact com SPL token contas. Native SOL must be wrapped into the SPL token format so it can be processed by swap programs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].content",
          "englishWordCount": 377,
          "excerpt": "# Slippage e impacto no preco: protecting swap outcomes Slippage is the difference between the expected output amount at quote time e the actual amount received at execution time. In volatile markets com active trading, ..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Token amounts are integers. Floating-point math can produce off-by-one errors that cause transacao failures or incorrect minimum amounts."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].content",
          "englishWordCount": 402,
          "excerpt": "# Route visualization: understanding swap legs e fees Swap routes reveal the path your tokens take through DeFi liquidity. Visualizing routes helps users understand why a multi-hop path might yield more output than a dir..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].content",
          "englishWordCount": 65,
          "excerpt": "# Challenge: Build a normalized SwapPlan from a quote Parse a raw aggregator quote response e produce a normalized SwapPlan: - Extract input/output mints e amounts from the quote - Calculate minOutAmount using BigInt sli..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Execucao por maquina de estados, anatomia da transacao, padroes de confiabilidade de retry/staleness e relatorios de execucao de alto sinal."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].content",
          "englishWordCount": 68,
          "excerpt": "# Challenge: Implement swap UI state machine Build a deterministic state machine para the swap UI flow: - States: idle → quoting → ready → sending → confirming → success | error - Process a sequence of events e track all..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].hints[1]",
          "englishWordCount": 12,
          "excerpt": "If an event is not valid para the current state, transition to 'error' com a descriptive message."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].content",
          "englishWordCount": 418,
          "excerpt": "# Swap transacao anatomy: instrucoes, contas, e compute A swap transacao on Solana is a carefully ordered sequence of instrucoes that together achieve an atomic token exchange. Understanding each instrucao's role, the co..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 13,
          "excerpt": "Compute budget instrucoes configure the transacao's CU limit e price before any program execution begins."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "ALTs allow transacoes to reference many contas without exceeding the 1232-byte transacao size limit."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].content",
          "englishWordCount": 382,
          "excerpt": "# Reliability patterns: retries, stale quotes, e latency Production swap flows must handle the reality of network latency, expired quotes, e transacao failures. Reliability engineering separates toy swap implementations ..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].content",
          "englishWordCount": 68,
          "excerpt": "# Checkpoint: Generate a SwapRunReport Build the final swap run report that combines all curso concepts: - Summarize the route com leg details e total fees (using BigInt summation) - Compute the effective price as outAmo..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Collect errors from both the state machine result e any additional errors array."
        },
        {
          "path": "courses.defi-clmm-liquidity.description",
          "englishWordCount": 17,
          "excerpt": "Domine engenharia de liquidez concentrada em DEXs Solana: matematica de ticks, design de estrategia por faixa, dinamica de taxas/IL e relatorios deterministas de posicoes LP."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Conceitos de liquidez concentrada, matematica de tick/preco e comportamento de posicoes por faixa para raciocinar sobre execucao CLMM."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].content",
          "englishWordCount": 645,
          "excerpt": "# CLMM vs constant product: why ticks exist Concentrated Liquidity Market Makers (CLMMs) represent a fundamental evolution in automated market maker design. To understand why they exist, we must first understand the limi..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Ticks provide discrete price points para position boundaries, liquidity transitions, e efficient fee tracking at tick crossings."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].content",
          "englishWordCount": 553,
          "excerpt": "# Price, tick, e sqrtPrice: core conversions The mathematical foundation of every CLMM rests on three interrelated representations of price: the human-readable price, the tick index, e the sqrtPriceX64. Understanding how..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Token amounts in a CLMM position are linear functions of sqrtPrice, making on-chain computation simpler e more gas-efficient."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].content",
          "englishWordCount": 627,
          "excerpt": "# Range positions: in-range e out-of-range dynamics A CLMM position is defined by its lower tick e upper tick. These two boundaries determine the price range in which the position is active, earns fees, e holds a mix of ..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].content",
          "englishWordCount": 61,
          "excerpt": "# Challenge: Implement tick/price conversion helpers Implement the core tick math functions used in every CLMM integration: - Convert a tick index to a human-readable price using price = 1.0001^tick - Convert the price t..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Simulacao de acumulacao de taxas, tradeoffs de estrategias de faixa, riscos de precisao e relatorios deterministas de risco de posicao."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].content",
          "englishWordCount": 66,
          "excerpt": "# Challenge: Simulate position fee accrual Implement a fee accrual simulator para a CLMM position over a price path: - Convert lower e upper tick boundaries to prices - Walk through each price in the path e determine in-..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].content",
          "englishWordCount": 628,
          "excerpt": "# Range strategies: tight, wide, e rebalancing rules Choosing the right price range is the most important decision a CLMM liquidity provider makes. The range determines capital efficiency, fee income, impermanent loss ex..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "Tight ranges concentrate capital para higher efficiency e fee share, but the position goes out-of-range more often, requiring active management."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 18,
          "excerpt": "Full-range positions replicate constant product behavior e never go out-of-range, making them suitable para highly volatile or unpredictable pairs."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].content",
          "englishWordCount": 666,
          "excerpt": "# CLMM risks: rounding, overflow, e tick spacing errors Building reliable CLMM integrations requires awareness of precision risks that can cause incorrect calculations, failed transacoes, or lost funds. This licao catalo..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].content",
          "englishWordCount": 64,
          "excerpt": "# Checkpoint: Generate a Position Report Implement a comprehensive LP position report generator that combines all CLMM concepts: - Convert tick boundaries to human-readable prices - Determine in-range or out-of-range sta..."
        },
        {
          "path": "courses.defi-lending-risk.description",
          "englishWordCount": 16,
          "excerpt": "Domine engenharia de risco em lending Solana: mecanicas de utilizacao e juros, analise de caminhos de liquidacao, seguranca de oraculo e relatorios deterministas de cenarios."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Mecanicas de pool de lending, modelos de taxa guiados por utilizacao e fundamentos de health factor necessarios para analise de risco defensavel."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].content",
          "englishWordCount": 530,
          "excerpt": "# Lending pool model: supply, borrow, e utilization Lending protocols are the backbone of decentralized finance. They enable users to earn yield on idle assets by supplying them to a shared pool, while borrowers draw fro..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].content",
          "englishWordCount": 435,
          "excerpt": "# Interest rate curves e the kink model Interest rates in lending protocols are not fixed. They adjust dynamically based on pool utilization to balance supply e demand para liquidity. The piecewise-linear \"kink\" model is..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "Above the kink, slope2 (the jump multiplier) applies, causing borrow rates to spike sharply e discourage further borrowing."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Supply rate = borrowRate * utilization * (1 - reserveFactor). Since utilization < 1 e reserveFactor > 0, the supply rate is always less than the borrow rate."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].content",
          "englishWordCount": 440,
          "excerpt": "# Health factor monitoring e liquidation preview The health factor is the single number that determines whether a lending position is safe or subject to liquidation. Monitoring health factors in real time is essential pa..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].content",
          "englishWordCount": 85,
          "excerpt": "# Challenge: Compute utilization-based interest rates Implement the kink-based interest rate model used by lending protocols: - Calculate the utilization ratio from total supply e total borrowed - Apply the piecewise-lin..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Calculo de health factor, mecanicas de liquidacao, tratamento de falhas de oraculo e relatorios de risco multi-cenario para mercados estressados."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].content",
          "englishWordCount": 74,
          "excerpt": "# Challenge: Compute health factor e liquidation status Implement the health factor computation para a multi-asset lending position: - Sum collateral e borrow values from an array of position objects - Compute weighted a..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].content",
          "englishWordCount": 530,
          "excerpt": "# Liquidation mechanics: bonus, close factor, e bad debt Liquidation is the enforcement mechanism that keeps lending protocols solvent. When a borrower's health factor falls below 1.0, external actors called liquidators ..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 17,
          "excerpt": "The liquidation bonus compensates liquidators para gas costs e risk, ensuring positions are liquidated promptly to protect the protocol."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 20,
          "excerpt": "Bad debt materializes when rapid price drops make collateral worth less than the debt, leaving the protocol com unrecoverable losses."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].content",
          "englishWordCount": 573,
          "excerpt": "# Oracle risk e stale pricing in lending Lending protocols depend entirely on accurate, timely price feeds to compute collateral values, health factors, e liquidation eligibility. Oracles — the services that bring off-ch..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "Using price minus confidence para collateral gives a conservative valuation, protecting the protocol when oracle publishers disagree or markets are volatile."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Operating on stale prices is dangerous. Pausing operations prevents incorrect liquidations e under-collateralized borrows during oracle outages."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].content",
          "englishWordCount": 78,
          "excerpt": "# Checkpoint: Generate a multi-scenario risk report Build the final risk report that combines all curso concepts: - Evaluate a base case using current position prices - Apply price overrides from multiple named scenarios..."
        },
        {
          "path": "courses.defi-perps-risk-console.description",
          "englishWordCount": 16,
          "excerpt": "Domine engenharia de risco de perps na Solana: contabilidade precisa de PnL/funding, monitoramento de margem, simulacao de liquidacao e relatorios deterministas no console."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Mecanica de futuros perpetuos, logica de acumulacao de funding e fundamentos de modelagem de PnL para diagnosticos precisos de posicao."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].content",
          "englishWordCount": 608,
          "excerpt": "# Perpetual futures: base positions, entry price, e mark vs oracle Perpetual futures (perps) are synthetic derivatives that let traders gain exposure to an asset's price movement without holding the underlying token. Unl..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].content",
          "englishWordCount": 601,
          "excerpt": "# Funding rates: why they exist e how they accrue Funding rates are the mechanism that tethers a perpetual contract's price to the underlying spot price. Without funding, the perp price could drift arbitrarily far from r..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "A positive premium (mark > oracle) produces a positive funding rate. Longs pay shorts, which discourages excessive long demand e pushes the perp price back toward spot."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].content",
          "englishWordCount": 561,
          "excerpt": "# PnL visualization: tracking profit over time Profit e loss (PnL) tracking in perpetual futures requires careful accounting across multiple dimensions: unrealized PnL from price movement, realized PnL from closed portio..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].content",
          "englishWordCount": 56,
          "excerpt": "# Challenge: Calculate perpetual futures PnL Implement a PnL calculator para perpetual futures positions: - Compute unrealized PnL based on entry price vs mark price - Handle both long e short positions correctly - Calcu..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].content",
          "englishWordCount": 71,
          "excerpt": "# Challenge: Simulate funding rate accrual Build a funding accrual simulator that processes discrete funding intervals: - Iterate through an array of funding rates e compute the payment para each period - Longs pay (subt..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Monitoramento de margem e liquidacao, armadilhas comuns de implementacao e saidas deterministicas de console de risco para observabilidade em producao."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].content",
          "englishWordCount": 600,
          "excerpt": "# Margin ratio e liquidation thresholds Margin is the collateral that backs a leveraged position. When the margin falls below a critical threshold relative to the position's notional value, the protocol forcibly closes t..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 27,
          "excerpt": "The maintenance buffer ensures that when a position is liquidated, there is still margin left to pay liquidation fees e absorb slippage during the close. Without it, positions could go underwater, creating bad debt."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].content",
          "englishWordCount": 752,
          "excerpt": "# Common bugs: sign errors, units, e funding direction Perpetual futures implementations are mathematically straightforward — the formulas are basic arithmetic. Yet sign errors, unit mismatches, e funding direction bugs ..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 37,
          "excerpt": "When size carries the direction sign, every formula that uses size must conta para the sign — not just PnL, but also notional value, funding payments, e liquidation price. Keeping size positive e branching on a separate ..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].content",
          "englishWordCount": 75,
          "excerpt": "# Checkpoint: Generate a Risk Console Report Build the comprehensive risk console report that integrates all curso concepts: - Calculate unrealized PnL e ROE para the position - Accumulate funding payments across all pro..."
        },
        {
          "path": "courses.defi-tx-optimizer.description",
          "englishWordCount": 16,
          "excerpt": "Domine otimizacao de transacoes DeFi na Solana: ajuste de compute/taxas, estrategia ALT, padroes de confiabilidade e planejamento deterministico de estrategia de envio."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Diagnostico de falha de transacao, mecanica de compute budget, estrategia de priority fee e bases de estimativa de taxas."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].content",
          "englishWordCount": 564,
          "excerpt": "# Why DeFi transacoes fail: CU limits, size, e blockhash expiry DeFi transacoes on Solana fail para three primary reasons: compute budget exhaustion, transacao size overflow, e blockhash expiry. Understanding each failur..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "Solana allocates 200,000 CUs by default. DeFi transacoes almost always need more, requiring an explicit SetComputeUnitLimit instrucao."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Expired blockhash transacoes are never processed e produce no on-chain record. The client must detect the timeout e resubmit com a fresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].content",
          "englishWordCount": 463,
          "excerpt": "# Compute budget instrucoes e priority fee strategy The Compute Budget Program provides two critical instrucoes that every serious DeFi transacao should include: `SetComputeUnitLimit` e `SetComputeUnitPrice`. Together, t..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Conta state may change between simulation e execution, causing minor CU variations. A 10% margin absorbs these differences."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].content",
          "englishWordCount": 462,
          "excerpt": "# Transacao cost estimation e fee planning Accurate fee estimation is the foundation of a good DeFi user experience. Users need to know what a transacao will cost before they sign it. Validadores need sufficient fees to ..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].content",
          "englishWordCount": 79,
          "excerpt": "# Challenge: Build a transacao plan com compute budgeting Build a transacao planning function that analyzes a set of instrucoes e produces a complete transacao plan: - Sum estimatedCU from all instrucoes e add a 10% safe..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Planejamento de Address Lookup Table, padroes de confiabilidade/retry, UX de erro acionavel e relatorio completo de estrategia de envio."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].content",
          "englishWordCount": 97,
          "excerpt": "# Challenge: Plan Address Lookup Table usage Build a function that determines the optimal Address Lookup Table strategy para a transacao: - Collect all unique conta keys across instrucoes - Check which keys exist in avai..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].content",
          "englishWordCount": 550,
          "excerpt": "# Reliability patterns: retry, re-quote, resend vs rebuild Production DeFi applications must handle transacao failures gracefully. The difference between a frustrating e a reliable experience comes down to retry strategy..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "Rebuilding is necessary when the transacao's blockhash is stale or when on-chain state has changed (e.g., slippage exceeded). Simple network issues only require resending the same bytes."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "englishWordCount": 12,
          "excerpt": "To prevent many clients from retrying at the exact same moment e overwhelming the network"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].content",
          "englishWordCount": 586,
          "excerpt": "# UX: actionable error messages para transacao failures Raw Solana error messages are cryptic. \"Transacao simulation failed: Error processing Instrucao 2: custom program error: 0x1771\" tells a developer something but tel..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].content",
          "englishWordCount": 89,
          "excerpt": "# Checkpoint: Generate a send strategy report Build the final send strategy report that combines all curso concepts into a comprehensive transacao optimization plan: - Build a tx plan: sum CU estimates com 10% margin (ca..."
        },
        {
          "path": "courses.solana-mobile-signing.description",
          "englishWordCount": 18,
          "excerpt": "Domine assinatura de wallet mobile em producao na Solana: sessoes Android MWA, restricoes de deep link no iOS, retries resilientes e telemetria deterministica de sessao."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Restricoes de plataforma, padroes de UX de conexao, comportamento de timeline de assinatura e construcao tipada de requests em Android/iOS."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].content",
          "englishWordCount": 709,
          "excerpt": "# Mobile signing reality check: Android vs iOS constraints Mobile carteira signing on Solana is fundamentally different from browser-based carteira interactions. The constraints imposed by Android e iOS operating systems..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "Android MWA uses foreground services to maintain a persistent communication channel between the dApp e carteira, enabling multi-request sessions without app switching."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].content",
          "englishWordCount": 715,
          "excerpt": "# Carteira connection UX patterns: connect, reconnect, e recovery Carteira connection on mobile is the first interaction users have com your dApp. A smooth connection flow builds trust; a broken one drives users away. Th..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "Network mismatches should be communicated clearly to the user com instrucoes on how to resolve them, avoiding confusing silent failures."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].content",
          "englishWordCount": 667,
          "excerpt": "# Signing session timeline: request, carteira, e response flow Understanding the complete lifecycle of a mobile signing request is essential para building reliable dApps. Every sign request passes through multiple stages..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].content",
          "englishWordCount": 70,
          "excerpt": "# Challenge: Build a typed sign request Implement a sign request builder para Mobile Carteira Adapter: - Validate the payload type (transacao or message) - Validate payload data (base64 para transacoes, non-empty string ..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[2]",
          "englishWordCount": 13,
          "excerpt": "App identity requires at least name e URI. Icon is optional but should default to empty string."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Persistencia de sessao, seguranca na tela de revisao de transacao, maquinas de estado de retry e relatorio deterministico de sessao para apps mobile em producao."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].content",
          "englishWordCount": 59,
          "excerpt": "# Challenge: Session persistence e restoration Implement a session persistence manager para mobile carteira sessions: - Process a sequence of actions: save, restore, clear, e expire_check - Track carteira address e last ..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].content",
          "englishWordCount": 632,
          "excerpt": "# Mobile transacao review: what users need to see Transacao review screens are the last line of defense between a user e a potentially harmful transacao. On mobile, screen real estate is limited e user attention is fragm..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 17,
          "excerpt": "Token amounts must be converted to human-readable format using the token's decimal configuration e include the symbol para clarity."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Balance change summaries (e.g., -1.5 SOL, +150 USDC) are the most user-friendly way to communicate what a transacao will do."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].content",
          "englishWordCount": 710,
          "excerpt": "# One-tap retry: handling offline, rejected, e timeout states Mobile environments are inherently unreliable. Users move between WiFi e cellular, enter tunnels, close apps mid-transacao, e carteiras crash. A robust retry ..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].content",
          "englishWordCount": 59,
          "excerpt": "# Checkpoint: Generate a session report Implement a session report generator that summarizes a complete mobile signing session: - Count total requests, successful signs, e failed signs - Sum retry attempts across all req..."
        },
        {
          "path": "courses.solana-pay-commerce.description",
          "englishWordCount": 17,
          "excerpt": "Domine integracao comercial com Solana Pay: encoding robusto de URL, fluxos de rastreamento QR/pagamento, UX de confirmacao e artefatos deterministas de conciliacao POS."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Especificacao Solana Pay, rigor de encoding de URL, anatomia de transfer request e padroes deterministicos de builder/encoder."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].content",
          "englishWordCount": 589,
          "excerpt": "# Solana Pay modelo mental e URL encoding rules Solana Pay is an open specification para encoding payment requests into URLs that carteiras can parse e execute. Unlike traditional payment processors that rely on centrali..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "The Solana Pay specification uses the 'solana:' scheme followed immediately by the recipient address com no slashes."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Transacao requests allow the server to build arbitrarily complex transacoes. Transfer requests only support simple single-token transfers."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].content",
          "englishWordCount": 631,
          "excerpt": "# Transfer request anatomy: recipient, amount, reference, e labels A Solana Pay transfer request URL contains everything a carteira needs to construct e submit a payment transacao. Each component of the URL serves a spec..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 22,
          "excerpt": "The reference public key is included as a non-signer conta in the transfer instrucao. The merchant polls getSignaturesForAddress(reference) to detect when the payment transacao confirms."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 20,
          "excerpt": "Solana Pay URLs use human-readable decimal amounts. The carteira handles the conversion to raw units based on the token's decimal configuration."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].content",
          "englishWordCount": 473,
          "excerpt": "# URL builder: live preview of Solana Pay URLs Building Solana Pay URLs correctly requires understanding how each parameter contributes to the final encoded string. In this licao, we walk through the construction process..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].content",
          "englishWordCount": 73,
          "excerpt": "# Challenge: Encode a Solana Pay transfer request URL Build a function that encodes a Solana Pay transfer request URL from input parameters: - Validate the recipient address (must be 32-44 characters of valid base58) - V..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Maquinas de estado de rastreamento por reference, UX de confirmacao, tratamento de falhas e geracao deterministica de recibo POS."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].content",
          "englishWordCount": 84,
          "excerpt": "# Challenge: Track payment references through confirmation states Build a reference tracking state machine that processes payment events: - States flow: pending -> found -> confirmed -> finalized (or pending -> expired) ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].content",
          "englishWordCount": 644,
          "excerpt": "# Confirmation UX: pending, confirmed, e expired states The user experience during payment confirmation is the most critical moment in any Solana Pay integration. Between the customer scanning the QR code e the merchant ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "englishWordCount": 13,
          "excerpt": "Confirmed is sufficient para low-value POS transacoes; finalized is needed para irreversible digital fulfillment"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "Para coffee-shop-scale payments, confirmed commitment provides a strong enough guarantee. Finalized adds 6-12 seconds of latency e is only necessary when fulfillment is irreversible."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 22,
          "excerpt": "Expired requests should be clearly communicated. The customer may have been in the middle of approving — they need to know the request expired e can try again."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].content",
          "englishWordCount": 698,
          "excerpt": "# Error handling e edge cases in payment flows Production payment systems encounter a wide range of failure modes that must be handled gracefully. Solana Pay integrations face challenges unique to blockchain payments: ne..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].content",
          "englishWordCount": 78,
          "excerpt": "# Checkpoint: Generate a POS receipt Build the final POS receipt generator that combines all curso concepts: - Reconstruct the Solana Pay URL from payment data (recipient, amount, spl-token, reference, label) - Generate ..."
        },
        {
          "path": "courses.wallet-ux-engineering.description",
          "englishWordCount": 15,
          "excerpt": "Domine engenharia de UX de wallet na Solana em producao: estado de conexao deterministico, seguranca de rede, resiliencia RPC e padroes de confiabilidade mensuraveis."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Design de conexao de wallet, network gating e arquitetura deterministica de maquina de estados para onboarding e reconexao previsiveis."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].content",
          "englishWordCount": 701,
          "excerpt": "# Connection UX that doesn't suck: a design checklist Carteira connection is the first interaction a user has com any Solana dApp. If this experience is slow, confusing, or error-prone, most users will leave before they ..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 18,
          "excerpt": "Skeleton UI reserves the layout space para carteira-dependent content, preventing jarring shifts when the connection resolves e data loads."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].content",
          "englishWordCount": 715,
          "excerpt": "# Network gating e wrong-network recovery Solana has multiple clusters: mainnet-beta, devnet, testnet, e localnet. Unlike EVM chains where the carteira controls the network e emits chain-change events, Solana's network s..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 31,
          "excerpt": "Each Solana cluster has a unique genesis hash. Comparing the RPC's genesis hash against known values is the only reliable detection method, since URL strings can be misleading e carteiras don't always expose network info..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "While conta addresses are identical across clusters, the conta states (balances, data, existence) are completely different. All cached RPC data must be cleared on network switch."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].content",
          "englishWordCount": 605,
          "excerpt": "# Connection state machine: states, events, e transitions Carteira connection logic in most dApps is implemented as a tangle of boolean flags, useEffect hooks, e conditional renders. This approach leads to impossible sta..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].content",
          "englishWordCount": 73,
          "excerpt": "# Challenge: Implement carteira connection state machine Build a deterministic state machine para carteira connection management: - States: disconnected, connecting, connected, error - Process a sequence of events e trac..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Invalidacao de cache, resiliencia e monitoramento de saude RPC, e relatorios mensuraveis de qualidade UX de wallet para operacao em producao."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].content",
          "englishWordCount": 85,
          "excerpt": "# Challenge: Cache invalidation on carteira events Build a cache invalidation engine that processes carteira events e invalidates the correct cache entries: - Cache entries have tags: \"conta\" (carteira-specific data), \"n..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].content",
          "englishWordCount": 686,
          "excerpt": "# RPC reads e caching strategy para carteira apps Every interaction in a Solana carteira application ultimately depends on RPC calls: fetching balances, loading token contas, reading program state, e confirming transacoe..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "englishWordCount": 12,
          "excerpt": "Conta states differ across clusters, so cached devnet data would be wrong para mainnet"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 26,
          "excerpt": "The same conta address can have completely different state on mainnet vs devnet. Without the network in the key, switching clusters would return stale data from the previous cluster."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "SWR prioritizes responsiveness by serving stale data instantly while refreshing in the background. This eliminates loading states para data that has only slightly exceeded its TTL."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].content",
          "englishWordCount": 859,
          "excerpt": "# RPC health monitoring e graceful degradation RPC endpoints are the lifeline of every Solana carteira application. When they go down, become slow, or return stale data, your app becomes unusable. Production carteira app..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].content",
          "englishWordCount": 74,
          "excerpt": "# Checkpoint: Generate a Carteira UX Report Build the final carteira UX quality report that combines all curso concepts: - Count connection attempts (CONNECT events) e successful connections (CONNECTED events) - Calculat..."
        },
        {
          "path": "courses.sign-in-with-solana.description",
          "englishWordCount": 19,
          "excerpt": "Domine autenticacao SIWS em producao na Solana: entradas padronizadas, invariantes estritas de verificacao, ciclo de vida de nonce resistente a replay e relatorios prontos para auditoria."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Racional do SIWS, semantica estrita dos campos de entrada, comportamento de renderizacao da wallet e construcao deterministica de sign-in input."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].content",
          "englishWordCount": 806,
          "excerpt": "# Why SIWS exists: replacing connect-e-signMessage Before Sign-In Com Solana (SIWS) became a standard, dApps authenticated carteira holders using a two-step pattern: connect the carteira, then call `signMessage` com an a..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 25,
          "excerpt": "Without structured format, carteiras treat signMessage payloads as opaque bytes e cannot validate or warn about the content, making it easy para malicious dApps to disguise harmful payloads as sign-in requests."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "The server generates a unique nonce para each sign-in attempt. After successful verification, the nonce is marked as consumed. Any reuse of the same nonce is rejected as a replay attack."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].content",
          "englishWordCount": 826,
          "excerpt": "# SIWS input fields e seguranca rules The Sign-In Com Solana input is a structured object that defines every parameter of an authentication request. Each field has specific validation rules, seguranca implications, e ren..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "If the client generates nonces, an attacker can replay a previously captured nonce-signature pair. Server-generated nonces ensure each authentication attempt is unique e controlled by the server."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "The domain field must be a plain domain name. Protocol prefixes, paths, ports, e query strings must be rejected to ensure consistent domain matching."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[2].content",
          "englishWordCount": 818,
          "excerpt": "# Message preview: how carteiras render SIWS requests When a dApp sends a SIWS sign-in request to a carteira, the carteira transforms the structured input into a human-readable message that the user sees on the approval ..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].content",
          "englishWordCount": 69,
          "excerpt": "# Challenge: Build a validated SIWS sign-in input Implement a function that creates a validated Sign-In Com Solana input: - Validate domain (non-empty, must not include protocol prefix) - Validate nonce (at least 8 chara..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Invariantes de verificacao server-side, defesas de nonce contra replay, gerenciamento de sessao e relatorio deterministico de auditoria de autenticacao."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].content",
          "englishWordCount": 59,
          "excerpt": "# Challenge: Verify a SIWS sign-in response Implement server-side verification of a SIWS sign-in output: - Check domain matches expected domain - Check nonce matches expected nonce - Check issuedAt is not in the future r..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].content",
          "englishWordCount": 791,
          "excerpt": "# Sessions e logout: what to store e what not to store After a successful SIWS sign-in verification, the server must establish a session so the user does not need to re-authenticate on every request. Session management p..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 30,
          "excerpt": "Carteira addresses are publicly known. Using them as session IDs would allow anyone who knows a user's address to impersonate their session. Random tokens ensure only the authenticated client can present a valid session."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 22,
          "excerpt": "Carteira disconnection signals the user's intent to end the interaction. The dApp should respect this by invalidating the session, preventing confusion about authentication state."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].content",
          "englishWordCount": 881,
          "excerpt": "# Replay protection e nonce registry design Replay attacks are the most critical threat to any signature-based authentication system. In a replay attack, an adversary captures a valid signed message e submits it again to..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].content",
          "englishWordCount": 80,
          "excerpt": "# Checkpoint: Generate an auth audit report Build the final auth audit report that combines all curso concepts: - Process an array of authentication attempts com address, nonce, e verified status - Track used nonces to d..."
        },
        {
          "path": "courses.priority-fees-compute-budget.description",
          "englishWordCount": 16,
          "excerpt": "Engenharia defensiva de taxas na Solana com planejamento deterministico de compute, politica adaptativa de prioridade e contratos de confiabilidade UX orientados por confirmacao."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Mecanicas de inclusao, acoplamento compute/fee e design de politica orientado por explorer com framing deterministico de confiabilidade."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].content",
          "englishWordCount": 587,
          "excerpt": "# Fee markets on Solana: what actually moves inclusion Priority fees on Solana are often explained as a simple slider, but production systems need a more precise model. Inclusion is influenced by contention para compute,..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "A large CU request com weak price can lose inclusion, while aggressive price on oversized CU can overpay."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].content",
          "englishWordCount": 542,
          "excerpt": "# Compute budget fundamentos e common failure modes Most transacao failures blamed on \"network issues\" are actually planning errors in compute budget e payload sizing. A defensive client treats compute planning as a dete..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[2].content",
          "englishWordCount": 465,
          "excerpt": "# Explorer: compute budget planner inputs to plan Explorers are useful only when they expose policy tradeoffs clearly. Para a fee e compute planner, that means visualizing how input estimates, percentile targets, e confi..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implementar planners deterministicos, motores de politica de confirmacao e artefatos estaveis de estrategia de fee para revisao de release."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].content",
          "englishWordCount": 12,
          "excerpt": "Implement policy-based priority fee estimation using synthetic sample arrays e deterministic warnings."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[2].content",
          "englishWordCount": 12,
          "excerpt": "Encode confirmation UX policy para processed, confirmed, e finalized states using deterministic risk bands."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].content",
          "englishWordCount": 15,
          "excerpt": "Build stable markdown output para a fee strategy summary that users e support teams can review quickly."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[4].content",
          "englishWordCount": 12,
          "excerpt": "Produce a deterministic checkpoint report JSON para the Fee Optimizer final project artifact."
        },
        {
          "path": "courses.bundles-atomicity.description",
          "englishWordCount": 17,
          "excerpt": "Projete fluxos defensivos multi-transacao na Solana com validacao deterministica de atomicidade, modelagem de compensacao e relatorios de seguranca prontos para auditoria."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Modelo de atomicidade, riscos de fluxos multi-transacao e validacao defensiva de seguranca para proteger expectativas do usuario."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].content",
          "englishWordCount": 525,
          "excerpt": "# Atomicity concepts e why users assume all-or-nothing Users rarely think in transacao graphs. They think in intents: \"swap my token\" or \"close my position.\" When a workflow spans multiple transacoes, user expectation re..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].content",
          "englishWordCount": 503,
          "excerpt": "# Multi-transacao flows: approvals, ATA creation, swaps, refunds A reliable flow simulator must encode where partial execution risk lives. In practice, risk points cluster at boundaries: before value transfer, during val..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[2].content",
          "englishWordCount": 463,
          "excerpt": "# Explorer: flow graph steps e risk points Flow graph explorers are most valuable when they highlight risk semantics, not just sequence order. A defensive explorer should display each step com dependency context, idempot..."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implementar validadores deterministicos de atomicidade, padroes de tratamento de falha e composicao estavel de bundles para revisao de release."
        },
        {
          "path": "courses.mempool-ux-defense.description",
          "englishWordCount": 16,
          "excerpt": "Engenharia defensiva de UX para swaps com graduacao deterministica de risco, politicas de slippage limitadas e comunicacao de seguranca pronta para incidentes."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Riscos entre quote e execucao, guardrails de slippage e decisoes de frescor para swaps mais seguros em producao."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].content",
          "englishWordCount": 530,
          "excerpt": "# What can go wrong between quote e execution A swap quote is a prediction, not a guarantee. Between quote generation e execution, liquidity changes, competing orders land, e network conditions shift. Users often assume ..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[1].content",
          "englishWordCount": 482,
          "excerpt": "# Slippage controls e guardrails Slippage settings are a policy surface, not a cosmetic preference. Defensive swap UX defines explicit bounds, context-aware defaults, e clear consequences when users attempt risky overrid..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[2].content",
          "englishWordCount": 448,
          "excerpt": "# Explorer: quote freshness timer e decision table A quote freshness explorer should make policy behavior obvious under time pressure. Users e engineers need to see when a quote transitions from safe to warning to blocke..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[0].content",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic swap risk grading from quote, slippage, impact, hops, e liquidity inputs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.description",
          "englishWordCount": 16,
          "excerpt": "Construa pipelines deterministicas de indexacao em producao com ingestao segura contra duplicatas, tratamento de reorg e relatorios orientados por integridade."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].content",
          "englishWordCount": 509,
          "excerpt": "# Indexing 101: logs, contas, e transacao parsing Reliable indexers are not just fast parsers. They are consistency systems that decide what to trust, when to trust it, e how to recover from changing chain history. On So..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[1].content",
          "englishWordCount": 457,
          "excerpt": "# Reorgs e fork choice: why confirmed is not finalized Confirmation labels are useful but often misunderstood in indexing pipelines. A confirmed event has stronger confidence than processed, but it is not equivalent to f..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[2].content",
          "englishWordCount": 462,
          "excerpt": "# Explorer: ingest to dedupe to confirm to apply A pipeline explorer should explain transformation stages clearly so engineers can inspect where correctness can break. Para indexing reliability, the core stages are inges..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implementar logica de confirmacao, planejamento de backfill/idempotencia e checagens de integridade para relatorios de pipeline estaveis."
        },
        {
          "path": "courses.rpc-reliability-latency.description",
          "englishWordCount": 14,
          "excerpt": "Projete clientes RPC Solana multi-provedor em producao com politicas deterministicas de retry, roteamento, cache e observabilidade."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Real-world RPC failure behavior, endpoint selection strategy, e deterministic retry policy modeling."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].content",
          "englishWordCount": 520,
          "excerpt": "# RPC failures in real life: timeouts, 429s, stale nodes Reliable client infrastructure begins com realistic failure assumptions. RPC calls fail para many reasons: transient network timeouts, provider rate limits, stale ..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].content",
          "englishWordCount": 430,
          "excerpt": "# Multi-endpoint strategies: hedged requests e fallbacks Multi-endpoint design is more than adding a backup URL. It is a scheduling problem where each request should be sent to the most suitable endpoint given recent hea..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].content",
          "englishWordCount": 460,
          "excerpt": "# Explorer: retry/backoff simulator Retry e backoff policies determine whether clients recover gracefully or amplify outages. A simulator should make schedule behavior explicit so teams can reason about user latency e pr..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Build deterministic policy engines para routing, retries, metrics reduction, e health report exports."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].content",
          "englishWordCount": 12,
          "excerpt": "Export deterministic JSON e markdown health report artifacts para multi-provider reliability review."
        },
        {
          "path": "courses.rust-data-layout-borsh.description",
          "englishWordCount": 17,
          "excerpt": "Engenharia de layout de dados Solana com foco Rust e tooling deterministico em nivel de bytes, com praticas de schema seguras para compatibilidade."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Alignment behavior, Borsh encoding rules, e pratico parsing safety para stable byte-level contracts."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].content",
          "englishWordCount": 555,
          "excerpt": "# Memory layout: alignment, padding, e why Solana contas care Rust layout behavior is deterministic inside one compiled binary but can vary when assumptions are implicit. Para Solana contas, this matters because raw byte..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].content",
          "englishWordCount": 492,
          "excerpt": "# Struct e enum layout pitfalls plus Borsh rules Borsh is widely used because it gives deterministic serialization across languages, but teams still get tripped up by how enums, vectors, e strings map to bytes. Understan..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[2].content",
          "englishWordCount": 443,
          "excerpt": "# Explorer: layout visualizer para field offsets A layout visualizer turns abstract alignment rules into concrete numbers engineers can review. Instead of debating whether a struct is \"probably fine,\" teams can inspect e..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic layout analysis, encoding/decoding, safe parsing, e compatibility-focused reporting helpers."
        },
        {
          "path": "courses.rust-errors-invariants.description",
          "englishWordCount": 18,
          "excerpt": "Construa bibliotecas tipadas de guardas de invariantes com artefatos deterministas de evidencia, contratos de erro seguros para compatibilidade e relatorios prontos para auditoria."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].content",
          "englishWordCount": 536,
          "excerpt": "# Error taxonomy: recoverable vs fatal Rust encourages explicit error modeling, but teams still produce weak error contracts when they rely on ad hoc strings or inconsistent wrappers. In Solana e Anchor-adjacent systems,..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[1].content",
          "englishWordCount": 513,
          "excerpt": "# Result<T, E> patterns, ? operator, e context Result-based control flow is one of Rust's strongest tools para building robust services e on-chain-adjacent clients. The key is not merely using Result, but designing error..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].content",
          "englishWordCount": 452,
          "excerpt": "# Explorer: invariant decision tree An invariant decision tree helps teams reason about guard ordering e failure priority. Not every invariant should be checked in arbitrary order. Early checks should prevent expensive w..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement guard helpers, evidence-chain generation, e stable audit reporting para reliability e incident response."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.description",
          "englishWordCount": 15,
          "excerpt": "Simule e otimize comportamento de custo de compute com tooling deterministico Rust-first e governanca de performance guiada por budget."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Rust desempenho modelo mentals, data-structure tradeoffs, e deterministic cost reasoning para reliable optimization decisions."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].content",
          "englishWordCount": 493,
          "excerpt": "# Desempenho modelo mental: allocations, clones, hashing Rust desempenho work in Solana ecosystems is mostly about data movement discipline. Teams often chase micro-optimizations while ignoring dominant costs such as rep..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].content",
          "englishWordCount": 472,
          "excerpt": "# Data structures: Vec, HashMap, BTreeMap tradeoffs Data structure choice is one of the highest leverage desempenho decisions in Rust systems. Vec offers compact contiguous storage e predictable iteration speed. HashMap ..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].content",
          "englishWordCount": 451,
          "excerpt": "# Explorer: cost model sandbox A cost sandbox lets teams test optimization hypotheses without waiting para full benchmark infrastructure. Provide operation counts, compute weighted costs, e inspect which buckets dominate..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.description",
          "englishWordCount": 16,
          "excerpt": "Engenharia de pipeline async com foco Rust-first e concorrencia limitada, reducers seguros contra replay e relatorios operacionais deterministicos."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].content",
          "englishWordCount": 501,
          "excerpt": "# Async fundamentals: futures, tasks, channels Rust async systems are built on explicit scheduling rather than implicit thread-per-task models. Futures represent pending work, executors poll futures, e channels coordinat..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[1].content",
          "englishWordCount": 446,
          "excerpt": "# Concurrency limits e backpressure Backpressure is not optional in high-volume pipelines. Without it, producer speed can overwhelm reducers, retries, or storage sinks. A resilient design sets explicit concurrency caps e..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[2].content",
          "englishWordCount": 465,
          "excerpt": "# Explorer: pipeline graph e concurrency Pipeline graphs help teams communicate stage boundaries, concurrency budgets, e retry behaviors. A graph that shows ingest, dedupe, retry, e snapshot stages com explicit capacitie..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implement deterministic scheduling, retries, dedupe/reducer stages, e report exports para reorg-safe pipeline operations."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.description",
          "englishWordCount": 16,
          "excerpt": "Seguranca de macros/codegen em Rust ensinada com parser deterministico e tooling de geracao de checagens com saidas amigaveis para auditoria."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].content",
          "englishWordCount": 489,
          "excerpt": "# Macro modelo mental: declarative vs procedural Rust macros come in two broad forms: declarative macros para pattern-based expansion e procedural macros para syntax-aware transformation. Anchor relies heavily on macro-d..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].content",
          "englishWordCount": 455,
          "excerpt": "# Safety through codegen: constraint checks Constraint codegen converts compact declarations into explicit runtime guards. Typical constraints include signer presence, conta ownership, has-one relations, e mutability req..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].content",
          "englishWordCount": 451,
          "excerpt": "# Explorer: constraint builder to generated checks A constraint builder explorer helps engineers see how DSL choices affect generated code e runtime safety outcomes. Input one attribute line, observe parsed AST, generate..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Parse DSL constraints, generate checks, run deterministic evaluations, e publish stable safety reports."
        },
        {
          "path": "courses.anchor-upgrades-migrations.description",
          "englishWordCount": 17,
          "excerpt": "Desenhe fluxos de release seguros em producao para Anchor com planejamento deterministico de migracao, gates de upgrade, playbooks de rollback e evidencia de prontidao."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Authority lifecycle, conta versioning strategy, e deterministic upgrade risk modeling para Anchor releases."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].content",
          "englishWordCount": 552,
          "excerpt": "# Upgrade authority lifecycle in Anchor programs Anchor makes instrucao development easier, but upgrade safety still depends on disciplined control of program authority. In production Solana systems, most upgrade inciden..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[1].content",
          "englishWordCount": 504,
          "excerpt": "# Conta versioning e migration strategy Solana contas are long-lived state containers, so program upgrades must respect historical data. In Anchor, adding or changing conta fields can be safe, risky, or catastrophic depe..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].content",
          "englishWordCount": 453,
          "excerpt": "# Explorer: upgrade risk matrix A useful upgrade explorer should show cause-e-effect between release inputs e safety outcomes. If a flag changes, engineers should immediately see how severity e readiness changes. This li..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Safety validation gates, rollback planning, e deterministic readiness artifacts para controlled migration execution."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].content",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic blocking issue checks para authority, artifact hash, e dry-run status."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].content",
          "englishWordCount": 450,
          "excerpt": "# Rollback strategy e incident playbooks Even strong upgrade plans can encounter surprises: incompatible downstream clients, unexpected conta edge cases, or release pipeline mistakes. Teams that recover quickly are the o..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].content",
          "englishWordCount": 14,
          "excerpt": "Produce the final deterministic checkpoint artifact com release tag, readiness flag, e migration batch count."
        },
        {
          "path": "courses.solana-reliability.description",
          "englishWordCount": 19,
          "excerpt": "Engenharia de confiabilidade focada em producao para sistemas Solana: tolerancia a falhas, retries, deadlines, circuit breakers e degradacao graciosa com resultados operacionais mensuraveis."
        },
        {
          "path": "courses.solana-reliability.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Implement fault-tolerance building blocks com clear failure classification, retry boundaries, e deterministic recovery behavior."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[0].content",
          "englishWordCount": 221,
          "excerpt": "Fault tolerance in Solana systems is not just about catching errors. It is about deciding which failures are safe to retry, which should fail fast, e how to preserve user trust while doing both. A pratico reliability mod..."
        },
        {
          "path": "courses.solana-reliability.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Build resilience mechanisms (circuit breakers, bulkheads, e rate controls) that protect core user flows during provider instability."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[0].content",
          "englishWordCount": 187,
          "excerpt": "Resilience patterns are controls that prevent localized failures from becoming system-wide incidents. On Solana integrations, they are especially important because provider health can change quickly under bursty network ..."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].content",
          "englishWordCount": 13,
          "excerpt": "Implement a circuit breaker pattern that opens after consecutive failures e closes after a recovery period."
        },
        {
          "path": "courses.solana-testing-strategies.description",
          "englishWordCount": 19,
          "excerpt": "Estrategia abrangente de testes para Solana orientada a producao: testes unitarios deterministicos, integracoes realistas, fuzz/property testing e relatorios de confianca para release."
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Build deterministic unit e integration testes layers com clear ownership of invariants, fixtures, e failure diagnostics."
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[0].content",
          "englishWordCount": 160,
          "excerpt": "Testes Solana systems effectively requires layered confidence, not one giant test suite. Unit tests validate pure logic: math, state transitions, e invariant checks. They should be fast, deterministic, e run on every cha..."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Use fuzzing, property-based tests, e mutation-style checks to expose edge-case failures before release."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[0].content",
          "englishWordCount": 156,
          "excerpt": "Avancado testes techniques uncover failures that example-based tests rarely find. Fuzzing explores broad random input space to trigger parser edge cases, boundary overflows, e unexpected state combinations. It is especia..."
        },
        {
          "path": "courses.solana-program-optimization.description",
          "englishWordCount": 16,
          "excerpt": "Projete performance Solana de nivel producao: compute budgeting, eficiencia de layout de contas, tradeoffs de memoria/rent e workflows de otimizacao deterministicos."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Optimize compute-heavy paths com explicit CU budgets, operation-level profiling, e predictable desempenho tradeoffs."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Compute units are the hard resource budget that shapes what your Solana program can do in a single transacao. Desempenho optimization starts by treating CU usage as a contract, not an afterthought. A reliable optimizatio..."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Design memory/storage-efficient conta layouts com rent-aware sizing, serialization discipline, e safe migration planning."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[0].content",
          "englishWordCount": 96,
          "excerpt": "Conta data optimization is both a cost e correctness discipline. Poor layouts increase rent, slow parsing, e make migrations fragile. Design principles: - Keep hot fields compact e easy to parse. - Use fixed-size represe..."
        },
        {
          "path": "courses.solana-tokenomics-design.description",
          "englishWordCount": 16,
          "excerpt": "Desenhe economias de token robustas na Solana com disciplina de distribuicao, seguranca de vesting, incentivos de staking e mecanicas de governanca operacionalmente defensaveis."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Model token allocation e vesting systems com explicit fairness, unlock predictability, e deterministic accounting rules."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[0].content",
          "englishWordCount": 93,
          "excerpt": "Token distribution is a seguranca e credibility decision, not just a spreadsheet exercise. Allocation e vesting rules shape long-term trust in the protocol. A strong distribution model answers: - who receives tokens e wh..."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Design staking e governanca mechanics com clear incentive alignment, anti-manipulation constraints, e measurable participation health."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[0].content",
          "englishWordCount": 93,
          "excerpt": "Staking e governanca systems must balance participation incentives com manipulation resistance. Rewarding lock behavior is useful, but poorly tuned models can over-concentrate influence. Core design questions: 1) How is ..."
        },
        {
          "path": "courses.solana-defi-primitives.description",
          "englishWordCount": 17,
          "excerpt": "Construa fundamentos praticos de DeFi na Solana: mecanicas de AMM, contabilidade de liquidez, primitivas de lending e padroes de composicao seguros contra flash loans."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Implement AMM e liquidity primitives com deterministic math, slippage-aware outputs, e LP accounting correctness."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[0].content",
          "englishWordCount": 96,
          "excerpt": "AMM fundamentals are simple in formula but subtle in implementation quality. The invariant math must be deterministic, fee handling explicit, e rounding behavior consistent across paths. Para constant-product pools, rout..."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Model lending e flash-loan flows com collateral safety, utilization-aware pricing, e strict repayment invariants."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[0].content",
          "englishWordCount": 85,
          "excerpt": "Lending primitives e flash-loan logic are powerful but unforgiving. Safety depends on strict collateral valuation, clear LTV/threshold rules, e deterministic repayment checks. A pratico lending model should define: - col..."
        },
        {
          "path": "courses.solana-nft-standards.description",
          "englishWordCount": 17,
          "excerpt": "Implemente NFTs Solana com padroes prontos para producao: integridade de metadata, disciplina de colecao e comportamentos avancados programaveis/nao transferiveis."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build core NFT functionality com standards-compliant metadata, collection verification, e deterministic asset-state handling."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[0].content",
          "englishWordCount": 78,
          "excerpt": "NFT architecture on Solana combines token mechanics com metadata e collection semantics. A correct implementation requires more than minting a token com supply one. Core components include: - mint/state ownership correct..."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implement avancado NFT behaviors (soulbound e programmable flows) com explicit policy controls e safe update semantics."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[0].content",
          "englishWordCount": 72,
          "excerpt": "Avancado NFT features introduce policy complexity that must be explicit. Soulbound behavior, programmable restrictions, e dynamic metadata updates all expand failure surface. Para soulbound models, non-transferability mu..."
        },
        {
          "path": "courses.solana-cpi-patterns.description",
          "englishWordCount": 16,
          "excerpt": "Domine composicao CPI na Solana com validacao segura de contas, disciplina de assinante PDA e padroes deterministicos de orquestracao multi-programa."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build CPI fundamentals com strict conta/signer checks, ownership validation, e safe PDA signing boundaries."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[0].content",
          "englishWordCount": 86,
          "excerpt": "Invocacao entre Programas (CPI) is where Solana composability becomes pratico e where many seguranca failures appear. The caller controls conta lists, so every CPI boundary must be treated as untrusted input. Safe CPI de..."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Compose avancado multi-program flows com atomicity awareness, consistency checks, e deterministic failure handling."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[0].content",
          "englishWordCount": 88,
          "excerpt": "Multi-program composition introduces sequencing e consistency risk. Even when each CPI call is correct in isolation, combined flows can violate business invariants if ordering or rollback assumptions are weak. Robust com..."
        },
        {
          "path": "courses.solana-mev-strategies.description",
          "englishWordCount": 18,
          "excerpt": "Engenharia de ordenacao de transacoes focada em producao na Solana: roteamento consciente de MEV, estrategia de bundles, modelagem de liquidacao/arbitragem e controles de execucao protetivos ao usuario."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Understand MEV mechanics e transacao ordering realities, then model opportunities e risks com deterministic safety-aware policies."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[0].content",
          "englishWordCount": 162,
          "excerpt": "Maximal Extractable Value (MEV) on Solana is fundamentally about transacao ordering under limited blockspace. Whether you are building trading tools, liquidation infrastructure, or user-facing apps, you need a realistic ..."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Design avancado ordering/bundle strategies com explicit risk controls, failure handling, e user-impact guardrails."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[0].content",
          "englishWordCount": 123,
          "excerpt": "Avancado transacao-ordering strategies require disciplined orchestration, not just faster opportunity scans. Bundle-oriented execution is valuable because it can express dependency sets e all-or-nothing intent, but bundl..."
        },
        {
          "path": "courses.solana-deployment-cicd.description",
          "englishWordCount": 17,
          "excerpt": "Engenharia de deployment em producao para programas Solana: estrategia de ambientes, gates de release, controles de qualidade CI/CD e workflows operacionais seguros para upgrades."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Model environment-specific implantacao behavior com deterministic configs, artifact checks, e release preflight validation."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[0].content",
          "englishWordCount": 132,
          "excerpt": "Solana implantacao is not one command; it is a release system com environment-specific risk. Localnet, devnet, e mainnet each serve different validation goals, e production quality depends on using them intentionally. A ..."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Build CI/CD pipelines that enforce build/test/seguranca gates, compatibility checks, e controlled rollout/rollback evidence."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[0].content",
          "englishWordCount": 116,
          "excerpt": "CI/CD para Solana should enforce release quality, not just automate command execution. A pratico pipeline includes staged gates: 1) static quality gate (lint/type/seguranca checks), 2) deterministic unit/integration test..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.description",
          "englishWordCount": 18,
          "excerpt": "Construa integracoes cross-chain mais seguras para Solana com mensageria estilo Wormhole, verificacao de attestations e controles deterministicos de estado da bridge."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].content",
          "englishWordCount": 133,
          "excerpt": "Cross-chain messaging is a trust-boundary problem before it is a transport problem. In Wormhole-style systems, messages are observed, attested, e consumed across different chain environments, each com independent failure..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement asset-bridging patterns com strict supply/accounting invariants, replay protection, e reconciliation workflows."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Token bridging requires strict supply e state invariants. Lock-e-mint e burn-e-mint models both rely on one central rule: represented supply across chains must remain coherent. Critical controls include: - single-consume..."
        },
        {
          "path": "courses.solana-oracle-pyth.description",
          "englishWordCount": 18,
          "excerpt": "Integre feeds de oracle na Solana com seguranca: validacao de preco, politica de confianca/staleness e agregacao multi-fonte para decisoes de protocolo resilientes."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand oracle data semantics (price, confidence, staleness) e enforce deterministic validation before business logic."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[0].content",
          "englishWordCount": 110,
          "excerpt": "Oracle integration is a risk-control problem, not a data-fetch problem. Price feeds must be evaluated para freshness, confidence, e contextual fitness before they drive protocol decisions. A safe oracle validation pipeli..."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Design multi-oracle aggregation e consensus policies that reduce single-source failure risk while remaining explainable e testable."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Multi-oracle aggregation reduces single-point dependency but adds policy complexity. The goal is not to average blindly; it is to produce a robust decision value com clear confidence in adverse conditions. Common strateg..."
        },
        {
          "path": "courses.solana-dao-tooling.description",
          "englishWordCount": 17,
          "excerpt": "Construa sistemas DAO prontos para producao na Solana: governanca de propostas, integridade de voto, controles de tesouraria e workflows deterministicos de execucao/reporting."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Implement governanca mechanics com explicit proposal lifecycle rules, voting-power logic, e deterministic state transitions."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[0].content",
          "englishWordCount": 106,
          "excerpt": "DAO governanca architecture is a system of enforceable process rules. Proposal creation, voting, e execution must be deterministic, auditable, e resistant to manipulation. A robust governanca model defines: 1) proposal l..."
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Engineer treasury e execution tooling com policy gates, timelock safeguards, e auditable automation outcomes."
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[0].content",
          "englishWordCount": 106,
          "excerpt": "DAO treasury management is where governanca intent becomes real financial action. Treasury tooling must therefore combine flexibility com strict policy constraints. Core controls include: - spending limits e role-based a..."
        },
        {
          "path": "courses.solana-gaming.description",
          "englishWordCount": 19,
          "excerpt": "Construa sistemas de jogos on-chain prontos para producao na Solana: modelos eficientes de estado, integridade de turno, controles de fairness e economia escalavel de progressao de jogadores."
        },
        {
          "path": "courses.solana-gaming.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Design game state e turn logic com deterministic transitions, storage efficiency, e anti-cheat validation boundaries."
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[0].content",
          "englishWordCount": 133,
          "excerpt": "On-chain game design on Solana is a systems-engineering tradeoff between fairness, responsiveness, e cost. The best designs keep critical rules verifiable while minimizing expensive state writes. Core architecture decisi..."
        },
        {
          "path": "courses.solana-gaming.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement fairness-oriented randomness e integrity controls that keep gameplay auditable e dispute-resistant."
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Randomness is one of the hardest fairness problems in blockchain games because execution is deterministic. Robust designs avoid naive pseudo-randomness tied directly to manipulable context. Pratico fairness patterns incl..."
        },
        {
          "path": "courses.solana-permanent-storage.description",
          "englishWordCount": 19,
          "excerpt": "Integre armazenamento descentralizado permanente com Solana usando workflows estilo Arweave: content addressing, integridade de manifest e acesso verificavel a dados de longo prazo."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand permanent-storage architecture e build deterministic linking between Solana state e external immutable content."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[0].content",
          "englishWordCount": 119,
          "excerpt": "Permanent storage integration is a data durability contract. On Solana, storing full content on-chain is often impractical, so systems rely on immutable external storage references anchored by on-chain metadata. A robust..."
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Work com manifests, verification pipelines, e cost/desempenho controls para reliable long-lived data serving."
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[0].content",
          "englishWordCount": 96,
          "excerpt": "Manifests turn many stored assets into one navigable root, but they introduce their own integrity responsibilities. A manifest is only trustworthy if path mapping e referenced content IDs are validated consistently. Key ..."
        },
        {
          "path": "courses.solana-staking-economics.description",
          "englishWordCount": 17,
          "excerpt": "Entenda staking e economia de validadores Solana para decisao no mundo real: estrategia de delegacao, dinamica de recompensas, efeitos de comissao e sustentabilidade operacional."
        },
        {
          "path": "courses.solana-staking-economics.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Aprenda native staking mechanics com deterministic reward modeling, validador selection criteria, e delegation risk framing."
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[0].content",
          "englishWordCount": 108,
          "excerpt": "Solana staking economics is an incentives system connecting delegators, validadores, e network seguranca. Good delegation decisions require more than chasing headline APY. Delegators should evaluate: 1) validador desempe..."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Analyze validador-side economics, operational cost pressure, e incentive alignment para long-term network health."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Validador economics balances revenue opportunities against operational costs e reliability obligations. Sustainable validadores optimize para long-term trust, not short-term extraction. Revenue sources include inflation ..."
        },
        {
          "path": "courses.solana-account-abstraction.description",
          "englishWordCount": 17,
          "excerpt": "Implemente padroes de smart-wallet/abstracao de conta na Solana com autorizacao programavel, controles de recuperacao e validacao de transacao orientada por politica."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build smart-carteira fundamentals including multisig e social-recovery designs com clear trust e failure boundaries."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Conta abstraction on Solana shifts control from a single key to programmable policy. Smart carteiras can enforce richer authorization logic, but policy complexity must be managed carefully. A robust smart-carteira design..."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement programmable validation policies (limits, allowlists, time/risk rules) com deterministic enforcement e auditability."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Programmable validation is where smart carteiras deliver real value, but it is also where subtle policy bugs appear. Typical controls include spending limits, destination allowlists, time windows, e risk-score gates. The..."
        },
        {
          "path": "courses.solana-pda-mastery.description",
          "englishWordCount": 17,
          "excerpt": "Domine engenharia avancada de PDAs na Solana: design de schema de seeds, disciplina de bump e uso seguro de PDAs cross-program em escala de producao."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build strong PDA foundations com deterministic derivation, canonical seed composition, e collision-resistant namespace strategy."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[0].content",
          "englishWordCount": 113,
          "excerpt": "Enderecos Derivados de Programa (PDAs) are deterministic authority e state anchors on Solana. Their power comes from predictable derivation; their risk comes from inconsistent seed discipline. A strong PDA design standar..."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement avancado PDA patterns (nested/counter/stateful) while preserving seguranca invariants e migration safety."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[0].content",
          "englishWordCount": 102,
          "excerpt": "Avancado PDA patterns solve real scaling e composability needs but increase design complexity. Nested PDAs, counter-based PDAs, e multi-tenant PDA namespaces each require explicit invariants around uniqueness, lifecycle,..."
        },
        {
          "path": "courses.solana-economics.description",
          "englishWordCount": 17,
          "excerpt": "Analise dinamicas economicas da Solana em contexto de producao: interacao inflacao/fee-burn, fluxos de staking, movimento de supply e tradeoffs de sustentabilidade de protocolo."
        },
        {
          "path": "courses.solana-economics.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand Solana macro token economics (inflation, burn, rewards, fees) com deterministic scenario modeling."
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[0].content",
          "englishWordCount": 112,
          "excerpt": "Solana economics is the interaction of issuance, burn, staking rewards, e usage demand. Sustainable protocol decisions require understanding these flows as a system, not isolated metrics. Core mechanisms include: 1) infl..."
        },
        {
          "path": "courses.solana-economics.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Model token flow dynamics e sustainability signals using supply categories, unlock events, e behavior-driven liquidity effects."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[0].content",
          "englishWordCount": 115,
          "excerpt": "Token flow analysis turns abstract economics into operational insight. The key is to track where tokens are (staked, circulating, locked, treasury, pending unlock) e how they move over time. Useful flow metrics include: ..."
        }
      ],
      "totals": {
        "exactEnglishCount": 866,
        "englishLikeCount": 459
      }
    },
    {
      "locale": "fr",
      "exactEnglishMatches": [
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Which fields make a transaction valid to execute?"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].options[0]",
          "text": "To calculate NFT metadata size"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].options[1]",
          "text": "To schedule non-conflicting transactions in parallel safely"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "It is the user who paid the creation fee forever"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[0].options[2]",
          "text": "It is always the same as fee payer in the last transaction"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "What does `executable: true` indicate?"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].options[1]",
          "text": "Token balances are program-specific state managed by the token program"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Use devnet while learning to avoid accidental mainnet transactions."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "This is your active signer public key."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].title",
          "text": "Build a SOL transfer transaction"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[0]",
          "text": "Keep transaction construction deterministic: no RPC or random values."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[1]",
          "text": "Convert SOL to lamports using 1_000_000_000 multiplier."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[0]",
          "text": "A client-only simulation mode"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[1]",
          "text": "Calling one on-chain program from another on-chain program"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].prompt",
          "text": "Why are PDAs useful?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].options[0]",
          "text": "They let programs derive deterministic addresses without private keys"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].options[2]",
          "text": "They replace transaction signatures entirely"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].options[1]",
          "text": "The runtime on behalf of the program when invoke_signed seeds match"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].options[2]",
          "text": "Only the fee payer of the outer transaction"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].prompt",
          "text": "What happens if you change a seed?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[0]",
          "text": "The PDA stays the same but bump changes"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[2]",
          "text": "You derive a different PDA address"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].explanation",
          "text": "Seed bytes are part of the hash input, so any change yields a different derived address."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "A compressed NFT ledger entry"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[2].prompt",
          "text": "What authority controls minting?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[0]",
          "text": "Parse flags in pairs: --key value."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[2]",
          "text": "Construct JSON object in fixed key order before JSON.stringify."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does Anchor generate automatically from your program definitions?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Automatic PDA funding from devnet faucets"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A JSON interface used by clients/tests/tooling to call your program correctly"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "A private key format used only by on-chain programs"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is a seeds constraint verifying?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "That a token mint has 9 decimals"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].prompt",
          "text": "Why is a PDA considered off-curve?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].options[0]",
          "text": "It is derived to avoid having a corresponding private key"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].explanation",
          "text": "Off-curve means no user-held private key exists; programs authorize via seed proofs."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].prompt",
          "text": "What breaks if you change one PDA seed value?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[1]",
          "text": "Only the bump changes while address stays fixed"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[2]",
          "text": "Nothing changes unless RPC endpoint changes"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].explanation",
          "text": "PDA derivation is seed-sensitive. Any seed change creates a different address namespace."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].title",
          "text": "Initialize Counter PDA (deterministic)"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[0]",
          "text": "Use a deterministic hash-like reducer over programId + authorityPubkey + static seed."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[1]",
          "text": "The init instruction must include four keys in fixed order: counter PDA, authority, payer, system program."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[2]",
          "text": "Encode instruction data as [73,78,73,84,95,67,84,82,bump] so tests can compare exactly."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].title",
          "text": "Increment instruction builder + state layout"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[0]",
          "text": "Represent state as a pure JS structure so increment can be deterministic in tests."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[1]",
          "text": "Return a new state object from applyIncrement; avoid mutating the input object in-place."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the main role of optional integration tests?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Validate network execution paths after deterministic logic is proven"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Replace all unit tests"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Avoid asserting exact outputs"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Integration tests add runtime confidence but should not replace deterministic core checks."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do simulation failures happen even before final send succeeds?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because fee payer is irrelevant"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What does fee payer mean in client transaction UX?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].content",
          "text": "# Counter project checkpoint Compose the full deterministic flow: 1. Derive counter PDA from authority + program ID. 2. Build init instruction metadata. 3. Build increment instruction metadata. 4. Emulate state transitio..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[0]",
          "text": "Compose the checkpoint from deterministic helper functions to keep output stable."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Where do SPL token balances actually live?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Inside the transaction signature"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why keep raw amounts as integer strings in model code?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because decimals are always 9"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "Show pending overlays first, mutate durable balances only after stronger confirmation"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[2]",
          "text": "Disable activity feed until finalized"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "Optimistic overlays are useful, but confirmed state must remain authoritative."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Why track transaction phases separately in telemetry?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].options[2]",
          "text": "Because commitment levels require it by protocol"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Phase-specific metrics enable actionable incident diagnosis."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is ordering by (ts, id) preferred over timestamp-only replay?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Stable ordering prevents environment-dependent state divergence."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should happen when the same event id arrives twice?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Idempotency guarantees deterministic behavior under retries."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[0]",
          "text": "Sort by (ts, id) before applying events."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[1]",
          "text": "Deduplicate by event id before snapshot interval checks."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[2]",
          "text": "Build checksum from stable snapshot metadata, not random values."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[0]",
          "text": "Use fixed-scale integers (micro USD) instead of floating point."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[1]",
          "text": "Apply filter -> search -> sort in a deterministic order."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "To reduce CSS size only"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because rate limits require it"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the main risk of generic one-size-fits-all error banners?"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Users cannot distinguish recovery actions across failure classes"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "They always break hydration"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Which metric should drive route selection at execution size?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Deterministic outAmount from full route simulation"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Displayed ticker price only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Lowest hop count only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Route quality is output-at-size, not headline spot labels."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does slippage tolerance directly determine?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "The minOut acceptance bound"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the deterministic minOut formula?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "minOut is a bounded percentage reduction from outAmount."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Why keep per-hop fee breakdowns?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Per-hop fee attribution makes route behavior auditable."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Minimize hop count always"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Choose first enumerated route"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "Why simulate virtual reserves per candidate route?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Virtual simulation avoids shared-state contamination."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].content",
          "text": "# Implement token/pool model + constant-product quote calc Implement deterministic CPMM quoting: - out = (reserveOut * inAfterFee) / (reserveIn + inAfterFee) - fee = floor(inAmount * feeBps / 10000) - impactBps from spot..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].hints[0]",
          "text": "Use inAfterFee = inAmount - floor(inAmount * feeBps / 10000)."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].hints[2]",
          "text": "Keep sorting deterministic to avoid route flicker."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[0]",
          "text": "Use virtual pool copies so fixture reserves are not mutated."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[2]",
          "text": "Return structured errors when pools or route links are invalid."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].prompt",
          "text": "What should happen when quote freshness expires?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].options[2]",
          "text": "Increase slippage automatically without notifying user"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Freshness boundaries should trigger deterministic recomputation."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which failures are not solved by blind retries?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].explanation",
          "text": "Planner errors require input/route changes, not repetition."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[0]",
          "text": "Keep output key order stable: swapPlan first, swapSummary second."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[1]",
          "text": "Path should be deterministic symbols along route hops."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[2]",
          "text": "Include fixtureHash + modelVersion under determinism metadata."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because owner checks improve rendering speed"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Because owner checks replace signer checks"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Only that an amount field exists"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the purpose of trace hashing in an audit workflow?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].options[1]",
          "text": "To replace structured test assertions"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Which sequence represents a valid evidence chain?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "Reproduce -> trace -> impact -> fix -> verify"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[1]",
          "text": "Fix -> reproduce -> trace -> release"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Accepting any PDA-like prefix"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Trusting client-provided bump values"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Deterministic re-derivation closes spoofable PDA substitution paths."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Because most exploitable bugs only appear under malformed or adversarial input"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Because traces are optional without them"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[0]",
          "text": "Compute drained lamports from recipient before/after."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[1]",
          "text": "Include deterministic field ordering in the JSON output."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[2]",
          "text": "The explanation should mention missing signer/owner validation."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].hints[2]",
          "text": "Keep output key order stable."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[1]",
          "text": "Use fixedBlockedExploit to set blocked status."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[2]",
          "text": "Return error code only when blocked is true."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].options[1]",
          "text": "They are interchangeable labels"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Good reports separate damage potential from exploit feasibility."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which recommendation is most actionable?"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[0]",
          "text": "Return stable, minimal checkpoint metadata."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[2]",
          "text": "Preserve scenarioIds order as provided."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why generate an offline deterministic launch pack before devnet/mainnet actions?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should supply checks use integer math instead of floating-point UI values?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "To avoid rounding drift in launch invariants"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Because decimals are always zero"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the primary role of freeze authority?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[0]",
          "text": "It can materially change effective fee behavior across transfer sizes"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "It is ignored once mint is initialized"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is a core risk of permanent delegate configuration?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].hints[2]",
          "text": "Keep output key order stable so checkpoint tests are reproducible."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].hints[1]",
          "text": "Append extension steps in deterministic order so plan labels are stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[0]",
          "text": "Transfer fee formula: fee = min(maxFee, floor(amount * feeBps / 10000))."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[2]",
          "text": "Fail when distributed amount exceeds initial supply."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is parameter closure required before execution?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Single-source configuration prevents mismatched launch behavior."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the purpose of hard stop launch criteria?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "To halt execution when invariants or authority assumptions fail"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Hard stop rules prevent progressing through unsafe operational states."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[0]",
          "text": "Keep checkpoint JSON key ordering fixed so output is stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[2]",
          "text": "Include determinism metadata (fixtures hash + encoding version) in the final object."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[0]",
          "text": "Add validation before returning the formatted string."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[1]",
          "text": "instructionCount should be treated as a number but returned as text."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].content",
          "text": "# Write a Counter Program Bankrun Test Implement a helper that returns the expected counter value after a sequence of increment operations. This mirrors a deterministic assertion you would use in a Bankrun test. Return t..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[0]",
          "text": "Use Array.reduce to sum increments."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[2]",
          "text": "Convert final number to string before returning."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the primary source of event data on Solana?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Explicit event topics like EVM"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is idempotency important in indexing?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "To prevent duplicate events during replays or forks"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "To improve RPC response times"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Idempotent ingestion ensures the same transaction processed twice creates only one event."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "As little-endian u64, then divided by 10^decimals"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[0].note",
          "text": "Top-level instruction at depth 1"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[1].note",
          "text": "Inner CPI call at depth 2"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Success bubbles up from inner to outer"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[0]",
          "text": "Parse log entries to identify event types"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[1]",
          "text": "Extract fields using regex patterns"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It provides stable ordering during concurrent writes"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Cursor-based pagination handles concurrent writes without missing or duplicating entries."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What enables indexer recovery after crashes?"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Periodic checkpointing of last processed position"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Re-indexing from genesis on every start"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Caching all data in memory"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Checkpoints allow indexers to resume from the last known good position."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].hints[3]",
          "text": "Include metadata like timestamps"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the purpose of SPL Memo in payments?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Attach metadata like order IDs to transactions"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What should never be included in a memo?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Memos are public on-chain; sensitive data should be hashed or kept off-chain."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Confirm triggers transaction building"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[0]",
          "text": "Use base58 alphabet to validate the recipient address format."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[2]",
          "text": "Generate an idempotency key if not provided in the input."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].hints[2]",
          "text": "Key order matters: SOL transfer needs [from, to], SPL transfer needs [source, mint, dest, owner]."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Different key orders produce different signatures"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Canonicalization ensures consistent serialization so signatures match regardless of object construction order."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Initial state after intent creation"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Transaction submitted, awaiting confirmation"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Payment complete, generate receipt"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[0]",
          "text": "HMAC-SHA256: H(key, message) = SHA256((key XOR outer_pad) || SHA256((key XOR inner_pad) || message))"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[1]",
          "text": "Use constant-time comparison to prevent timing attacks on signature verification."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[2]",
          "text": "Verify the timestamp is recent (within 5 minutes) to prevent replay attacks."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a Merkle root commit to?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The tree depth only"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[0]",
          "text": "Start by validating the leaf index is within bounds."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[1]",
          "text": "At each level, find the sibling node (left or right of current)."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[3]",
          "text": "Traverse up to the root, collecting all updated node hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[4]",
          "text": "Use deterministic ordering: left hash comes before right hash."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].prompt",
          "text": "What determines concatenation order during verification?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[0]",
          "text": "The leaf index bits at each level"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[1]",
          "text": "The size of the sibling hashes"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[2]",
          "text": "The tree root hash"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].explanation",
          "text": "Each bit of the leaf index determines if the current hash goes left or right in the concatenation."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[1].explanation",
          "text": "log2(1024) = 10, so proofs contain 10 sibling hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[0]",
          "text": "To generate a proof, collect the sibling hash at each level from leaf to root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[1]",
          "text": "The sibling is at index+1 if current is left, index-1 if current is right."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[3]",
          "text": "Use the same ordering (left || right) when combining hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[4]",
          "text": "The proof is valid if the recomputed root matches the stored root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do old proofs fail after tree updates?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "The root changes when leaves are added/modified"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "The proof format changes"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "The leaf hashes are encrypted"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Adding leaves changes parent hashes up to the root, invalidating previous proofs."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "How can metadata attacks be prevented?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Hash verification against leaf commitments"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Using shorter metadata URIs"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Verifying metadata hashes ensures the off-chain data matches the on-chain commitment."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[0]",
          "text": "Validate the mint request has all required fields (leafIndex, nftId, owner)."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[2]",
          "text": "Insert the leaf by computing hashes up to the root, collecting sibling hashes as proof."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What determines voting power in most DAOs?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Token balance at snapshot block"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Voting power is typically proportional to token holdings at a specific snapshot time."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Anyone can trigger execution"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].content",
          "text": "# Challenge: Implement quorum/voting state machine Build a deterministic voting system: - Calculate vote weights from token balances - Check quorum requirements - Determine pass/fail based on thresholds - Handle abstenti..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[1]",
          "text": "Check if totalVoteWeight >= quorumThreshold to determine quorumMet."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[2]",
          "text": "Calculate support percentage as forWeight / (forWeight + againstWeight) when there are non-abstain votes."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does 2-of-3 multisig mean?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].options[0]",
          "text": "2 signatures required from 3 possible signers"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].explanation",
          "text": "2-of-3 means any 2 of the 3 authorized signers must approve a transaction."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why track approvals on-chain?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[1]",
          "text": "Process actions in order - each action updates the signer's status."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[2]",
          "text": "Track the cumulative approved weight to compare against threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[3]",
          "text": "A proposal is 'approved' when approvedWeight >= threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[4]",
          "text": "A proposal is 'rejected' when no pending signers remain but threshold is not met."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "What is a replay attack in multisig systems?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "Re-executing an already-executed transaction"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Sending duplicate approval requests"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Replay attacks re-submit previously executed transactions to drain funds."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].hints[0]",
          "text": "First validate the proposal status is 'approved'."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the default compute unit limit per transaction?"
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What happens when a transaction exceeds its compute budget?"
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The network automatically extends the limit"
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Exceeding the compute budget causes immediate transaction failure."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].hints[0]",
          "text": "Use 5000 as the base compute unit cost per transaction."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].hints[2]",
          "text": "Each byte of data adds 10 compute units."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Lower fees, higher throughput"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[0]",
          "text": "Sort fields by size (largest first) to minimize padding gaps."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[1]",
          "text": "Consider if u64 fields can be reduced to u32 based on maxValue."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[2]",
          "text": "Boolean flags can be packed into a single byte as bit flags."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[3]",
          "text": "Calculate bytes saved as originalSize - optimizedSize."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of setComputeUnitPrice?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Set the maximum transaction size"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Enable additional program features"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Priority fees increase the likelihood of transaction inclusion during network congestion."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why request specific compute unit limits?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "Optimizing without profiling or evidence of need"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Premature optimization wastes effort on theoretical rather than measured bottlenecks."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[0]",
          "text": "Compute savings by subtracting 'after' from 'before' metrics."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[1]",
          "text": "Use approximate conversion: 1 SOL = $20, 1 SOL = 1,000,000,000 lamports."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why must native SOL be wrapped before swapping?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Native SOL cannot be transferred on Solana"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "The swap transaction fails unless the ATA is created in the same transaction"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Solana automatically creates the ATA"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The tokens are sent to the system program"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "ATAs must be explicitly created. Including createAssociatedTokenAccountIdempotent in the transaction handles this safely."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is 50 basis points of slippage on a 1,000,000 output?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why should minOutAmount use BigInt instead of floating point?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Floating point introduces rounding errors in token amounts"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "BigInt is faster than floating point"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Solana only accepts BigInt in transactions"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "text": "Token amounts are integers. Floating-point math can produce off-by-one errors that cause transaction failures or incorrect minimum amounts."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Single-hop direct route"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Total execution cost includes fees + impact"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[0]",
          "text": "Use BigInt arithmetic to avoid floating point errors when computing minOutAmount."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[1]",
          "text": "Slippage in basis points: minOut = outAmount - (outAmount * slippageBps / 10000)."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[3]",
          "text": "The priceImpactPct comes directly from the quote response."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].hints[0]",
          "text": "Define a TRANSITIONS map: each key is a state, each value maps event names to next states."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why are compute budget instructions placed first in a swap transaction?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "The runtime reads them before executing other instructions to set limits"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Other instructions depend on their output"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "They make transactions faster to execute"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "They reduce the number of required signatures"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Retryable — get fresh blockhash"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Transaction confirmed after retry"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[0]",
          "text": "Use BigInt to sum fee amounts across all route legs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[1]",
          "text": "Effective price = outAmount / inAmount, formatted to 9 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the main advantage of CLMMs over constant product AMMs?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Capital efficiency — LPs concentrate liquidity where trades happen"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "CLMMs allow LPs to allocate capital to specific price ranges, dramatically improving capital efficiency compared to spreading liquidity across all prices."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs use ticks to discretize the price space?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "To reduce the number of tokens in the pool"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs store sqrtPrice instead of price directly?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "It simplifies the AMM math — token amounts become linear in sqrtPrice"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "It uses less storage space on-chain"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Price within range, position is active"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "All SOL was sold as price rose through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Position reactivates when price returns to range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "All USDC was sold as price fell through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[0]",
          "text": "Price at a tick index = 1.0001^tickIndex. Use Math.pow(1.0001, tick)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[1]",
          "text": "Reverse conversion: tick = round(ln(price) / ln(1.0001))."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[2]",
          "text": "sqrtPriceX64 = BigInt(round(sqrt(price) * 2^64)) — Solana CLMM uses Q64.64 fixed-point."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[3]",
          "text": "Tick spacing alignment: floor(tick / spacing) * spacing."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[0]",
          "text": "Convert ticks to prices: lowerPrice = 1.0001^lowerTick, upperPrice = 1.0001^upperTick."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[2]",
          "text": "Fees only accrue when the position is in range. fee = floor(volumePerPeriod * feeRate)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[3]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[4]",
          "text": "Current status is based on the last price in the path relative to the range."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the main tradeoff of using a tight price range?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Lower fees but less impermanent loss"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "More tokens required to open the position"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When should an LP consider a full-range (all ticks) position?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "JavaScript Number cannot safely represent 128-bit integers"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Solana requires BigInt in transaction instructions"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "sqrtPriceX64 is a u128 value that can exceed JavaScript's Number.MAX_SAFE_INTEGER (2^53 - 1). BigInt provides arbitrary precision integer arithmetic."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "They are rejected by the program"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Floor division rounds toward negative infinity: floor(-100/64) = -2, so -100 aligns to -2 * 64 = -128. This is correct CLMM behavior."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[1]",
          "text": "Status is 'in-range' if lowerPrice <= currentPrice <= upperPrice."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[3]",
          "text": "IL formula: lpValue = sqrt(priceRatio) + sqrt(1/priceRatio); compare to holdValue = 2*sqrt(priceRatio)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[4]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimals."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a utilization ratio of 80% mean?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "80% of supplied assets are currently borrowed"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "80% of borrowers have been liquidated"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The pool has 80% of its maximum capacity"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Utilization = totalBorrowed / totalSupply. At 80%, four-fifths of all deposited assets are currently lent out to borrowers."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does the reserve factor affect supplier yield?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "It reduces supplier yield by skimming a percentage of borrow interest"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It increases supplier yield by adding protocol subsidies"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "It has no effect on supplier yield"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "The reserve factor takes a cut of borrow interest before distributing the rest to suppliers, reducing their effective APY."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What happens to borrow rates when utilization exceeds the kink?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "They increase steeply according to slope2"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "They remain constant at the kink rate"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "They decrease to attract more borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is the supply rate always lower than the borrow rate?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The protocol subsidizes borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Only 20% buffer remaining — consider adding collateral"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[0]",
          "text": "Utilization = totalBorrowed / totalSupply. Handle the zero-supply edge case."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[1]",
          "text": "Below kink: borrowRate = baseRate + (utilization/kink) * slope1."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[2]",
          "text": "Above kink: borrowRate = baseRate + slope1 + ((util - kink)/(1 - kink)) * slope2."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[3]",
          "text": "Supply rate = borrowRate * utilization * (1 - reserveFactor)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[1]",
          "text": "Effective threshold = weighted average of liquidationThreshold by collateral value."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[2]",
          "text": "Health factor = (collateralValue * effectiveThreshold) / borrowValue."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[3]",
          "text": "Max additional borrow = max(0, collateralValue * threshold - currentBorrow)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of the liquidation bonus?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It incentivizes liquidators to repay debt by offering collateral at a discount"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When does bad debt occur in a lending protocol?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "When collateral value is insufficient to cover outstanding debt after liquidation"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "When the reserve factor is set too high"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "When utilization drops below the kink"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "To be conservative — using (price - confidence) prevents over-valuing collateral during uncertainty"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Confidence intervals make prices more accurate"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should a protocol do when all oracle feeds are stale?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "Use the last known price regardless of age"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Estimate the price from on-chain DEX data"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[2]",
          "text": "Track the worst health factor across all scenarios."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[3]",
          "text": "Count how many scenarios result in isLiquidatable: true."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do perpetual futures protocols use a mark price instead of the last-traded price?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Mark price smooths out manipulation by incorporating oracle data, preventing artificial liquidations"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Mark price is cheaper to compute on-chain"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Last-traded price is not available on Solana"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Mark price incorporates the oracle price as a stability anchor. Using last-traded price alone would allow a single large trade to trigger cascading liquidations through price manipulation."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Weighted average: (8 * 20 + 2 * 30) / 10 = (160 + 60) / 10 = $22.00. The entry price shifts toward the new fill price proportional to the additional size."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "When the perpetual mark price is above the oracle (spot) price, who pays funding?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Longs pay shorts — the positive premium makes long positions expensive to hold"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Both sides pay the protocol a fee"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "A 10 SOL-PERP position at $25 entry faces a 0.01% funding rate. What is the per-period payment?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "text": "Funding payment = size * entryPrice * rate = 10 * 25 * 0.0001 = $0.025 per funding interval."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Position snapshot at current mark price"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Long PnL = size * (mark - entry)"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Positive rate: longs pay funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "True return includes funding drag"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[0]",
          "text": "Long PnL = size * (markPrice - entryPrice). Short PnL = size * (entryPrice - markPrice)."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[1]",
          "text": "Notional value = size * markPrice — represents the total position value."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[2]",
          "text": "ROE (return on equity) = unrealizedPnL / margin * 100."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[0]",
          "text": "Funding payment per period = size * entryPrice * fundingRate."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[1]",
          "text": "Longs pay when rate is positive (totalFunding -= payment). Shorts receive."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[2]",
          "text": "Average funding rate = sum(rates) / count."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[3]",
          "text": "Net margin impact = (totalFunding / margin) * 100, as a percentage."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is the maintenance margin rate set above zero?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "What causes a cascading liquidation spiral?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Forced position closes push the price further, triggering more liquidations in a feedback loop"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Too many traders opening positions at the same time"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Oracle prices updating too slowly"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "text": "When liquidation engines close positions by selling into the market, the selling pressure moves the price further against remaining positions, triggering their liquidations too — a self-reinforcing feedback loop."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should position size always be stored as a positive number?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Positive numbers use less storage space"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "A long position has a positive funding rate of 0.01%. What happens to the trader's balance?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The balance decreases — longs pay when the funding rate is positive"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The balance increases — longs receive positive funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Nothing — funding only affects shorts"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Positive funding rate means the perp is trading above spot. Longs pay shorts to discourage the long-heavy imbalance. The long trader's effective margin decreases by the funding payment amount."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[0]",
          "text": "Effective margin = initial margin + unrealized PnL + funding payments."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[1]",
          "text": "Margin ratio = effectiveMargin / notionalValue."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[3]",
          "text": "Generate alerts based on margin ratio vs maintenance margin rate thresholds."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[4]",
          "text": "Sort alerts by severity: CRITICAL > WARNING > INFO."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Solana allocates 200,000 CUs by default. DeFi transactions almost always need more, requiring an explicit SetComputeUnitLimit instruction."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What happens when a transaction's blockhash expires before it is confirmed?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How is the priority fee calculated in lamports?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "The CU price is denominated in micro-lamports per CU. Dividing by 1,000,000 converts micro-lamports to lamports. The ceiling function ensures rounding up to the nearest lamport."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is setting the CU limit to exactly the simulated value risky?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The runtime does not accept exact values"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Simulation always underreports CU usage by 50%"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Low compute = minimal priority fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Higher compute increases priority cost proportionally"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "High CU + high priority = significant fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[0]",
          "text": "Sum estimatedCU from all instructions, then add 10% margin: ceil(total * 1.1)."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[1]",
          "text": "Cap compute unit limit at 1,400,000 (Solana max)."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[2]",
          "text": "Priority fee = ceil(computeUnitLimit * computeUnitPrice / 1_000_000) in lamports."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[3]",
          "text": "Total fee = base fee (5000 lamports) + priority fee."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].hints[2]",
          "text": "Base transaction overhead is ~200 bytes. Max legacy tx size is 1232 bytes."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].hints[3]",
          "text": "Recommend 'legacy' if fits without LUT, 'use-existing-lut' if LUT helps enough, 'create-new-lut' if still too large."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "When should you rebuild a transaction instead of resending it?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "When the blockhash has expired or pool state has changed"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Whenever any error occurs"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Only when the user manually clicks retry"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Rebuilding is necessary when the transaction's blockhash is stale or when on-chain state has changed (e.g., slippage exceeded). Simple network issues only require resending the same bytes."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add random jitter to retry delays?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To make the delay shorter on average"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Jitter is required by the Solana protocol"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Without jitter, all clients using the same backoff formula would retry simultaneously, creating thundering herd problems on the RPC infrastructure."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Slippage exceeded -> actionable message"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Balance error -> show exact shortfall"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[1]",
          "text": "Fee estimates: low = 100 microlamports/CU, medium = 1000, high = 10000."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[2]",
          "text": "Retry policy: 3 retries, 500ms base delay, 2x backoff, always refresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[3]",
          "text": "Use the same CU calculation: ceil(totalCU * 1.1) capped at 1,400,000."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Foreground services maintaining a session channel"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Deep links passed between applications"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Shared local storage between apps"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "iOS suspends app execution on background transitions, preventing persistent channels"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "iOS uses a different blockchain protocol"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "iOS does not allow arbitrary background processes or persistent inter-app communication. When the user switches apps, the dApp's execution context is suspended."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Detect available connection methods (MWA, deep links, QR)"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "Capability detection ensures you only present connection methods that are actually available on the user's device."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Silently retry the transaction on a different cluster"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Request sent via MWA session or deep link"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "User decision - timing is unpredictable"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[4].note",
          "text": "Signed transaction returned to dApp"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[0]",
          "text": "Validate type is either 'transaction' or 'message' before checking payload format."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[1]",
          "text": "Transaction payloads must be valid base64 (A-Z, a-z, 0-9, +, /, optional = padding, length divisible by 4)."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[3]",
          "text": "Generate a requestId from type + payload prefix if not provided."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[0]",
          "text": "Process actions sequentially: each action modifies the session state."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[3]",
          "text": "Expire check clears session if current time >= expiresAt."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "How should token amounts be displayed on a mobile transaction review screen?"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "As raw lamports or smallest unit values"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the most intuitive way to present transaction simulation results?"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Raw simulation logs from the RPC response"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Balance change summaries (e.g., -1.5 SOL, +150 USDC) are the most user-friendly way to communicate what a transaction will do."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].title",
          "text": "Retry State Machine Flow"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "User action triggers request construction"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].steps[5].note",
          "text": "Signed transaction submitted to network"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[0]",
          "text": "Count requests by status: 'signed' = success, 'rejected'/'timeout'/'error' = failure."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[2]",
          "text": "Session duration = sessionEnd - sessionStart in seconds."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[3]",
          "text": "Request breakdown counts how many were 'transaction' vs 'message' type."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "solana:<recipient> (single colon, no slashes)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "solana://<recipient> (double slashes like HTTP)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "pay:<recipient> (custom pay scheme)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "When should you use a transaction request instead of a transfer request?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "When the payment requires multiple instructions or program interactions beyond a simple transfer"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "When the amount exceeds 100 SOL"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Transaction requests allow the server to build arbitrarily complex transactions. Transfer requests only support simple single-token transfers."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How does the reference parameter enable payment tracking?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "It creates a webhook that notifies the merchant"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "It stores the payment ID in the transaction memo"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What amount value represents 2.5 USDC in a Solana Pay URL?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "amount=2.5 (human-readable decimal)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Native SOL transfer — no spl-token parameter"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[0]",
          "text": "Solana Pay URL format: solana:<recipient>?amount=<amount>&spl-token=<mint>&reference=<ref>&label=<label>&message=<msg>"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[1]",
          "text": "Validate recipient: must be 32-44 characters of valid base58."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[2]",
          "text": "Amount must be a positive finite number."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[0]",
          "text": "Track state transitions: pending -> found -> confirmed -> finalized."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[1]",
          "text": "The 'found' event sets the signature. 'confirmation' increments the counter."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[2]",
          "text": "Timeout check expires the reference if still pending after expiryTimeout seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[3]",
          "text": "Record each state change in the history array."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Confirmed is never sufficient — always use finalized"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What should happen when the payment request expires?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Silently restart the polling loop"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Redirect the customer to a different payment method"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Exponential backoff recovers from transient failures"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Never auto-complete mismatched payments"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Track processed references to prevent double fulfillment"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[0]",
          "text": "Generate receiptId from the last 8 chars of reference + timestamp."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[1]",
          "text": "Reconstruct the Solana Pay URL from payment data."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[2]",
          "text": "Currency is 'SPL' if splToken is present, otherwise 'SOL'."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What should happen when auto-connect fails silently on page load?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Show the connect button without an error message"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Display an error toast telling the user to reconnect"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Auto-connect is a background optimization. If it fails, the user never initiated the action, so showing an error would be confusing. Simply display the default connect button."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why should you show skeleton UI during the connecting phase?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It makes the page load faster"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How do you reliably detect which Solana cluster an RPC endpoint is connected to?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What must happen to cached data when the network changes?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Only token balances need to be refreshed"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Cached data can be retained since addresses are the same across clusters"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "User clicks Connect, show loading state"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[0]",
          "text": "Define a TRANSITIONS map: each state maps event types to next states."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[2]",
          "text": "Error state stores the error message. Disconnected clears all session data."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[2]",
          "text": "DISCONNECT invalidates all non-'global' entries."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[3]",
          "text": "Track invalidation counts per event in the event log."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must cache keys include the network cluster?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "The Solana RPC protocol requires cluster identification"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What does the stale-while-revalidate pattern do when a cache entry is past its TTL?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Blocks until fresh data is fetched from the RPC"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Primary endpoint responding normally"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Latency spike detected, slot behind tip"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Automatic failover to healthy secondary"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Primary recovered, restoring as default"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[1]",
          "text": "Average connect time = total durationMs from CONNECTED events / count."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[2]",
          "text": "Cache hit rate = hits / (hits + misses) * 100."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[3]",
          "text": "RPC health = healthy checks / total checks * 100."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "signMessage does not produce valid Ed25519 signatures"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does SIWS prevent replay attacks?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "By requiring a unique, server-generated nonce that is consumed after verification"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must nonces be generated server-side rather than client-side?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Client-generated nonces allow attackers to reuse previously valid nonce-signature pairs"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Client-side random number generators are too slow"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What format must the domain field use?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Plain domain name without protocol prefix (e.g., example.com)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[0]",
          "text": "Domain should not include protocol (https://). Strip or reject it."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[2]",
          "text": "Address must be 32-44 characters (Solana base58 public key)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[3]",
          "text": "If no statement is provided, default to 'Sign in to <domain>'."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[1]",
          "text": "issuedAt must be <= currentTime (not in the future)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[2]",
          "text": "expirationTime (if present) must be > currentTime."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The dApp should invalidate the server-side session (treat it as logout)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Atomic SET NX ensures only one request can consume the nonce"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Replay blocked: nonce was already consumed"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[0]",
          "text": "Track used nonces in a map. If a nonce was already used, it's a replay attempt."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[2]",
          "text": "Use an address set to count unique addresses."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Because priority fee is fixed per transaction"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does a wide p90 vs p50 spread usually indicate?"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A volatile fee regime where a guard premium may be needed"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "Floor protects small estimates."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Large payload triggers heap recommendation."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[0].content",
          "text": "Implement a deterministic compute budget planner. No RPC calls; operate only on provided input data."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[0]",
          "text": "Use percentile targeting from sorted synthetic fee samples."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[1]",
          "text": "Apply volatility guard if p90 vs p50 spread exceeds policy threshold."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[2].hints[0]",
          "text": "Map risk score bands to processed/confirmed/finalized UX levels."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].hints[1]",
          "text": "Avoid timestamps or random IDs in output."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[4].hints[1]",
          "text": "Checkpoint report should avoid nondeterministic fields."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do users still expect atomic behavior in multi-tx flows?"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because protocols always guarantee it"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Users think in outcomes, not internal transaction decomposition."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].title",
          "text": "Flow Graph Risk Walkthrough"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "No compensation path after swap failure."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Still verify idempotency on each step."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[0].hints[1]",
          "text": "Emit explicit edges from dependency relationships."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[1].hints[1]",
          "text": "Flag non-idempotent steps because retries can break all-or-nothing guarantees."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].content",
          "text": "Encode deterministic failure handling metadata, including compensation state."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].hints[0]",
          "text": "Generate deterministic idempotency keys from stable inputs."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[3].hints[0]",
          "text": "No real Jito calls. Build deterministic data structures only."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].content",
          "text": "Generate a stable markdown flow safety report checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[0]",
          "text": "Render a stable markdown report as the final checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[1]",
          "text": "Keep the PASS/FAIL status deterministic from issue count."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Slippage is user tolerance; impact is market footprint"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They are identical metrics"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Slippage is a user-configured bound, while impact reflects route liquidity response to trade size."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[1].hints[0]",
          "text": "Clamp recommended BPS to policy bounds."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[2].hints[0]",
          "text": "Teach difference: impact is market footprint, slippage is user tolerance."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[3].hints[0]",
          "text": "Map risk grades to deterministic banner copy."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[4].hints[1]",
          "text": "Do not include timestamps or random IDs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is instruction index important in event keys?"
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "It helps prevent collisions when one transaction emits similar events"
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "It reduces RPC cost directly"
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Instruction index distinguishes same-signature events that would otherwise collide in dedupe."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[0].hints[1]",
          "text": "Sort by key so output is deterministic across runs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[1].hints[0]",
          "text": "Apply only confirmed-depth events to state."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[0]",
          "text": "Integrity checks must fail on negative balances."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[1]",
          "text": "Finalized keys must always be a subset of applied keys."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].title",
          "text": "RPC failures in real life: timeouts, 429s, stale nodes"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is slot lag important in endpoint scoring?"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Fast responses can still be wrong if the node is stale"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Slot lag is equivalent to timeout"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Latency alone cannot guarantee freshness of chain state."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Fast but less reliable under pressure."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].title",
          "text": "Explorer: retry/backoff simulator"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].title",
          "text": "RPC Multi-Provider Client Project Journey"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[0].hints[0]",
          "text": "Build a deterministic retry schedule including the first attempt."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[1].hints[1]",
          "text": "Tie-break deterministically by endpoint ID."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[2].hints[1]",
          "text": "Use tighter TTL when node lag grows."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].title",
          "text": "Checkpoint: RPC health report export"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].hints[1]",
          "text": "Ensure field order is stable in JSON output."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Alignment inserts padding bytes"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "RPC forces 8-byte packets"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "u64 alignment usually forces padding after smaller fields."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "u32 length + UTF-8 bytes + u8 field"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[0].hints[1]",
          "text": "Struct total size should be aligned to max field alignment."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].title",
          "text": "Challenge: implement borshEncode/borshDecode helpers"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].hints[0]",
          "text": "Borsh strings are length-prefixed little-endian u32 + UTF-8 bytes."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].title",
          "text": "Challenge: zero-copy vs Borsh tradeoff model"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[0]",
          "text": "Model tradeoffs deterministically: read speed vs schema flexibility."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[1]",
          "text": "Recommendation should be pure function of inputs."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[3].hints[0]",
          "text": "Validate byte length before field parsing."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].title",
          "text": "Checkpoint: stable layout report"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should export stable JSON + markdown."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].title",
          "text": "Error taxonomy: recoverable vs fatal"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why are typed error codes preferred over free-form strings?"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable machine-readable semantics"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "They reduce compile time"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].title",
          "text": "Explorer: invariant decision tree"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].title",
          "text": "Invariant Guard Library Project Journey"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].title",
          "text": "Challenge: implement InvariantError + ensure helpers"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].hints[0]",
          "text": "Return typed error payloads, not raw strings."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[1].title",
          "text": "Challenge: implement deterministic EvidenceChain"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].title",
          "text": "Challenge: deterministic invariant case runner"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].hints[0]",
          "text": "Property-ish deterministic tests can still run as fixed case sets."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].title",
          "text": "Challenge: implement formatReport() stable markdown"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].content",
          "text": "Format a deterministic markdown evidence report."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].title",
          "text": "Checkpoint: invariant audit report"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].content",
          "text": "Export deterministic invariant audit checkpoint artifacts."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should capture deterministic summary fields only."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[1]",
          "text": "No wall-clock timestamps in exported artifact."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why use deterministic cost models before microbenchmarks?"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable regression signals in CI"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They replace all profiling"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Deterministic models make relative regressions easy to catch early."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].title",
          "text": "Data structures: Vec, HashMap, BTreeMap tradeoffs"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].title",
          "text": "Explorer: cost model sandbox"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].title",
          "text": "Compute Budget Profiler (Sim)"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].title",
          "text": "Challenge: implement CostModel::estimate()"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].content",
          "text": "Estimate deterministic operation costs from fixed weighting rules."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].title",
          "text": "Challenge: optimize function metrics"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[0]",
          "text": "Treat optimization as deterministic metric diffs, not runtime benchmarking."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[1]",
          "text": "Clamp reduced metrics at zero."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].title",
          "text": "Challenge: model serialization overhead"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[0]",
          "text": "Show why repeated encode/decode loops are expensive."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[1]",
          "text": "Keep the model deterministic by counting bytes instead of timing."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].content",
          "text": "Generate stable optimization suggestions from deterministic metrics."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[0]",
          "text": "Output suggestions as a stable, sorted list."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[1]",
          "text": "Use threshold-based recommendations to avoid noisy advice."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].title",
          "text": "Checkpoint: stable perf report"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].hints[1]",
          "text": "Use deterministic percentage rounding."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].title",
          "text": "Async fundamentals: futures, tasks, channels"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].title",
          "text": "Reorg-safe Async Pipeline Project Journey"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].title",
          "text": "Challenge: implement Pipeline::run()"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].hints[1]",
          "text": "No real timers; simulate progression by decrementing remaining ticks."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[1].title",
          "text": "Challenge: implement RetryPolicy schedule"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].title",
          "text": "Challenge: idempotency key dedupe"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].content",
          "text": "Deduplicate replay events by deterministic idempotency keys."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].hints[0]",
          "text": "Use idempotency keys to collapse duplicate replay events."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[3].content",
          "text": "Build deterministic snapshot state from simulated event streams."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].title",
          "text": "Checkpoint: pipeline run report"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint output should mirror deterministic pipeline run artifacts."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "It verifies expansion matches policy intent"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].title",
          "text": "Safety through codegen: constraint checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].title",
          "text": "Explorer: constraint builder to generated checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].content",
          "text": "Parse mini-DSL constraints into deterministic AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].hints[0]",
          "text": "Parse mini DSL lines into typed AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].content",
          "text": "Generate stable pseudo-code from parsed constraint AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[0]",
          "text": "Generate stable pseudo-code output from AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[1]",
          "text": "One deterministic line per constraint node."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].title",
          "text": "Challenge: deterministic golden-file checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].content",
          "text": "Compare generated check output against deterministic golden strings."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[0]",
          "text": "Golden tests compare generated output strings exactly."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[1]",
          "text": "Keep check output deterministic to make golden tests meaningful."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].content",
          "text": "Execute generated constraints on deterministic sample input."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].hints[1]",
          "text": "Return deterministic failure reasons."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].title",
          "text": "Checkpoint: generated safety report"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].content",
          "text": "Export deterministic markdown safety report from generated checks."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].hints[0]",
          "text": "Render a deterministic markdown report from generated check results."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].title",
          "text": "Upgrade authority lifecycle in Anchor programs"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Compare approved build hash to expected programdata hash policy input"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Rely on signer memory without written report"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is release communication part of upgrade safety?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Because Anchor automatically writes support tickets"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because all upgrades are backward compatible"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].title",
          "text": "Explorer: upgrade risk matrix"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].title",
          "text": "Challenge: implement migration step planner"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].hints[1]",
          "text": "requiresMigration should be true only when toVersion > fromVersion."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].title",
          "text": "Challenge: implement upgrade safety gate checks"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[1]",
          "text": "Return issueCount plus ordered issue code array."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[2]",
          "text": "Keep order stable to make report diffs deterministic."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What should happen first when rollback trigger thresholds are hit?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Continue migration batches to avoid confusion"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Delete all historical reports"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Trigger conditions should map to immediate deterministic response actions."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add deterministic fixtures after an incident?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "To prove policy changes prevent the same failure path"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To increase deploy complexity without benefit"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "To replace all code reviews"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].title",
          "text": "Challenge: build stable upgrade markdown summary"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].hints[2]",
          "text": "Return plain markdown string without trailing spaces."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].title",
          "text": "Checkpoint: upgrade readiness artifact"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[0]",
          "text": "ready is true only when issueCount equals 0."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[1]",
          "text": "Return stable keys in releaseTag, ready, migrationBatches order."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[2]",
          "text": "Checkpoint output should be machine-readable deterministic JSON."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[0]",
          "text": "Use match on the BackoffStrategy enum to handle each case"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[2]",
          "text": "should_retry simply checks if attempt is less than max_attempts"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].content",
          "text": "Implement a deadline management system to enforce time limits on operations."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].hints[0]",
          "text": "Store the absolute expiration timestamp in the Deadline struct"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].content",
          "text": "Implement a fallback mechanism that provides alternative execution paths when primary operations fail."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].hints[1]",
          "text": "Only call fallback if primary returns None"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].hints[1]",
          "text": "record_success should reset everything to Closed state"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[0]",
          "text": "Always refill before checking if consumption is possible"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[2]",
          "text": "Use min() to ensure tokens don't exceed capacity"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].content",
          "text": "Implement an error classification system to determine if errors are retryable."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[1]",
          "text": "should_retry can use matches! macro or match on classify result"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[2]",
          "text": "batch_classify can use iter().map().collect() pattern"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].title",
          "text": "Test Assertion Framework Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].hints[1]",
          "text": "Use format! to create descriptive error messages"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[2].hints[0]",
          "text": "Use vec![0; size] to create zero-filled data of specified size"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].title",
          "text": "Test Scenario Builder Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].hints[1]",
          "text": "Push strings into vectors (use to_string() to convert &str)"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].title",
          "text": "Fuzz Input Generator Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].hints[1]",
          "text": "Generate bytes by taking random % 256"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[2].content",
          "text": "Implement a property verifier that checks invariants hold across operations."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].title",
          "text": "Boundary Value Analyzer Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[1]",
          "text": "Typical value is the midpoint of the range"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[2]",
          "text": "Return all 7 boundary values as test cases"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].content",
          "text": "Implement a compute unit counter to estimate operation costs."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[0]",
          "text": "Loop cost is overhead plus iterations times per-iteration cost"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[2]",
          "text": "Apply safety margin by multiplying budget by the percentage"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].title",
          "text": "Data Structure Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[0]",
          "text": "Use copy_from_slice to write data efficiently"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[1]",
          "text": "Track the highest written position as 'used'"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[2]",
          "text": "Always check bounds before read/write operations"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].title",
          "text": "Batch Operation Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].content",
          "text": "Optimize batch operations to minimize compute units."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[0]",
          "text": "Use to_le_bytes() to convert integers to bytes"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[1]",
          "text": "Use from_le_bytes() to convert bytes back to integers"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[2]",
          "text": "Alignment formula: if remainder, add (alignment - remainder)"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[0]",
          "text": "Annual rent is data size times lamports per byte per year"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[1]",
          "text": "Exemption threshold is annual rent times threshold years"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[2]",
          "text": "Check if balance is greater than or equal to minimum"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].title",
          "text": "Zero-Copy Deserializer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[0]",
          "text": "Use copy_from_slice to read fixed-size data into stack arrays"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[2]",
          "text": "Always advance offset after reading"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].title",
          "text": "Vesting Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[0]",
          "text": "Use saturating_sub to avoid underflow when calculating elapsed time"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[2]",
          "text": "Releasable is simply vested minus already released"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].title",
          "text": "Token Allocation Distributor Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[0]",
          "text": "Use iter().map().sum() to calculate total percentage"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[2]",
          "text": "Use find() to locate allocation by recipient"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].title",
          "text": "Release Schedule Generator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].hints[0]",
          "text": "Divide duration by intervals to get interval duration"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[0]",
          "text": "Use compound interest formula: A = P(1 + r/n)^(nt)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[1]",
          "text": "Convert basis points to decimal by dividing by 10000"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[0]",
          "text": "If delegated_to is Some, voting power is 0 (they gave it away)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[1]",
          "text": "Use filter to find voters who delegated to a specific address"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[2]",
          "text": "Sum staked amounts to calculate delegated power"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].title",
          "text": "Proposal Threshold Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].hints[0]",
          "text": "Convert basis points to amount: (supply * bps) / 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[1].title",
          "text": "Constant Product AMM Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].title",
          "text": "Liquidity Provider Calculator Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].hints[2]",
          "text": "Rewards are proportional to LP token holdings"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].content",
          "text": "Implement a time-weighted average price oracle."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[0]",
          "text": "Use retain() to filter out old observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[1]",
          "text": "Calculate duration between consecutive observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[2]",
          "text": "TWAP is weighted sum divided by total duration"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[0]",
          "text": "Max borrow is collateral value times LTV ratio"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[1]",
          "text": "Position is liquidatable when borrowed exceeds threshold * value"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[2]",
          "text": "Health factor shows how close to liquidation (higher is safer)"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].title",
          "text": "Interest Rate Model Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].content",
          "text": "Implement a utilization-based interest rate model."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].hints[0]",
          "text": "Utilization is borrowed divided by supplied"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].content",
          "text": "Implement flash loan validation logic."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[0]",
          "text": "Fee is amount times fee_bps divided by 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[1]",
          "text": "Total repay is principal plus fee"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[1].title",
          "text": "NFT Metadata Parser Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[2].hints[2]",
          "text": "Only verify if collection is complete"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].title",
          "text": "Attribute Rarity Calculator Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].content",
          "text": "Calculate NFT attribute rarity scores."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[0]",
          "text": "Rarity percentage is (count / total) * 100"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[1]",
          "text": "Rarity score is inverse of rarity (1 / rarity)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[1].hints[2]",
          "text": "Use any() to check if address is in restrictions list"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].title",
          "text": "Dynamic NFT Updater Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].content",
          "text": "Implement dynamic NFT attributes that can evolve over time."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[1]",
          "text": "Update last_updated timestamp after successful update"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[2]",
          "text": "Time until update is max(0, next_update - current_time)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[3].hints[2]",
          "text": "Filter equipped items by matching type in items list"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[1].hints[2]",
          "text": "Privilege extension: if caller is signer, child can sign too"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[0]",
          "text": "Convert string seeds to bytes using as_bytes()"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[1]",
          "text": "Simulate PDA finding by trying different bump values"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[0]",
          "text": "Use HashMap insert to register handlers"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[1]",
          "text": "Route by looking up instruction_type in handlers map"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].title",
          "text": "Atomic Swap Orchestrator Challenge"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].content",
          "text": "Implement an atomic swap across multiple programs."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].hints[1]",
          "text": "Atomicity requires output_token of step N equals input_token of step N+1"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[2].content",
          "text": "Validate state consistency across multiple CPI calls."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[0]",
          "text": "Push permission into vector to register"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[2]",
          "text": "Use retain() to remove caller from allowed list"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].title",
          "text": "Arbitrage Opportunity Detector Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].content",
          "text": "Detect arbitrage opportunities across DEXes."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[1]",
          "text": "Profit percent is (sell - buy) / buy * 100"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[2]",
          "text": "Use max_by to find best opportunity"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].title",
          "text": "Liquidation Opportunity Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[0]",
          "text": "Position is liquidatable when borrowed > threshold * collateral_value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[2]",
          "text": "Liquidation profit is bonus percentage of collateral value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].title",
          "text": "Priority Fee Calculator Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[0]",
          "text": "Urgency factor scales the base fee"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[1]",
          "text": "Execution probability decreases as more fees are higher"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[0]",
          "text": "Tip is percentage of total profit"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[1]",
          "text": "Bundle is profitable if profit exceeds tip"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].title",
          "text": "Multi-Hop Arbitrage Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].content",
          "text": "Find multi-hop arbitrage paths across token pairs."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[1]",
          "text": "Two-hop arbitrage goes A -> B -> A through different pools"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[2]",
          "text": "Profit is final output minus initial input"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].title",
          "text": "MEV Simulation Engine Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].content",
          "text": "Simulate MEV extraction to estimate profitability."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].hints[2]",
          "text": "Expected value weights profit by success probability"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[0]",
          "text": "Push config into vector to add"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[1]",
          "text": "Use find() to locate config by environment name"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[0]",
          "text": "Compare binary length against MAX_PROGRAM_SIZE"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[2]",
          "text": "Compression ratio shows percentage size reduction"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].title",
          "text": "Upgrade Authority Manager Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[0]",
          "text": "Push metadata into vector to register"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[1]",
          "text": "can_upgrade checks if authority matches stored authority"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[0]",
          "text": "Track seen stages to enforce ordering constraints"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[2]",
          "text": "Can skip build/test if only documentation files changed"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].title",
          "text": "Version Compatibility Checker Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[1]",
          "text": "Compatibility requires same major, actual >= required"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[2]",
          "text": "Use min_by to find smallest compatible version"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].title",
          "text": "Cross-Chain Messaging Architecture"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].content",
          "text": "Implement VAA (Verified Action Approval) signature verification."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[0]",
          "text": "Check signatures length against MIN_SIGNERS first"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[2]",
          "text": "Quorum is 2/3 of total guardians rounded up"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[0]",
          "text": "Increment sequence before creating message"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[2]",
          "text": "Verify message sequence is within emitted range"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[0]",
          "text": "Use contains() to check if sequence was processed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[1]",
          "text": "Return error if trying to mark already-processed sequence"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[2]",
          "text": "Use retain() to filter out old sequences"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[1].hints[1]",
          "text": "Verify requester matches owner before unlocking"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].title",
          "text": "Wrapped Token Mint Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].hints[1]",
          "text": "Check bounds before minting/burning"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].title",
          "text": "Bridge Rate Limiter Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[0]",
          "text": "Reset window before checking if duration passed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[1]",
          "text": "Only consume if total won't exceed max"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[1].hints[1]",
          "text": "Confidence ratio: conf / |price| < threshold"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[0]",
          "text": "Multiplier formula: smoothing / (period + 1)"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[1]",
          "text": "First EMA equals first price"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[2]",
          "text": "Subsequent EMAs use weighted average formula"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].title",
          "text": "Median Price Calculator Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].content",
          "text": "Calculate median price from multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].hints[2]",
          "text": "Use retain() to filter out outliers"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].content",
          "text": "Implement consensus checking across multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[0]",
          "text": "Check minimum sources first"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[2]",
          "text": "Agreement percent is (agreeing / total) * 100"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].title",
          "text": "Fallback Oracle Manager Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[0]",
          "text": "Store sources in priority order"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[1]",
          "text": "current_source index tracks which is active"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[2]",
          "text": "Fallback if index > 0 (not primary)"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].title",
          "text": "Proposal Lifecycle Manager Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].hints[1]",
          "text": "Voting active only during time window in Active state"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[0]",
          "text": "Delegated voters have 0 voting power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[1]",
          "text": "Quadratic voting uses square root of balance"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[2]",
          "text": "Apply cap after calculating base power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].content",
          "text": "Manage vote delegation between DAO members."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].hints[0]",
          "text": "Remove existing delegation before creating new one"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].title",
          "text": "Treasury Spending Limit Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].hints[1]",
          "text": "Reset period if duration has passed"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[2].hints[2]",
          "text": "Remove operation from list to cancel"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].title",
          "text": "Automated Action Trigger Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[1]",
          "text": "Match on condition type to evaluate"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[2]",
          "text": "Only return non-triggered actions that meet conditions"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[1].hints[1]",
          "text": "Turn complete when all players submitted"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].title",
          "text": "Game State Compressor Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[0]",
          "text": "Use bit shifting to pack x in high 4 bits, y in low 4 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[2]",
          "text": "Health stored as percentage (0-100) fits in 7 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].title",
          "text": "Player Progression Tracker Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[0]",
          "text": "XP formula: base * multiplier^(level-1)"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[1]",
          "text": "Keep leveling up while XP exceeds requirement"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[2]",
          "text": "Check contains() before adding achievement"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[1].hints[1]",
          "text": "Verify by recomputing hash from reveal"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[2].hints[2]",
          "text": "4d6 drop lowest: roll 4, sum all, subtract minimum"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[1]",
          "text": "Generate random number in range [0, total)"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[2]",
          "text": "Find item where cumulative weight exceeds roll"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].title",
          "text": "Storage Cost Estimator Challenge"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].content",
          "text": "Estimate Arweave storage costs based on data size."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].hints[0]",
          "text": "Calculate winston cost then convert to USD"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[3].hints[0]",
          "text": "Sort items by priority before bundling"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[0]",
          "text": "Validate tx_id length before adding"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[1]",
          "text": "Resolve in order: exact, index, fallback"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[0]",
          "text": "Push item to vector to add"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[1]",
          "text": "Filter items where any tag matches"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].title",
          "text": "Staking Rewards Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].hints[0]",
          "text": "Apply commission as (1 - commission) multiplier"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[2].hints[0]",
          "text": "Weight factors: commission 40%, uptime 40%, skip rate 20%"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[0]",
          "text": "Target is total divided by count, clamped to min/max"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[2]",
          "text": "Check all allocations within tolerance percentage"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[1].hints[0]",
          "text": "Sum all cost components"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[2].title",
          "text": "Epoch Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[0]",
          "text": "Only inactive stakes can be activated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[1]",
          "text": "Only active stakes can be deactivated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[2]",
          "text": "Fully active after warmup_epochs from activation"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[1].hints[0]",
          "text": "Use contains() to check ownership"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[2].hints[1]",
          "text": "Check guardian status before approving"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].title",
          "text": "Session Key Manager Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[0]",
          "text": "Valid if current time before expiration"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[2]",
          "text": "Remaining is max minus used"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].title",
          "text": "Spending Limit Enforcer Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[0]",
          "text": "Reset counters before checking"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[1]",
          "text": "Check all three limits: per-tx, daily, weekly"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[2]",
          "text": "Reset daily if new day, weekly if 7+ days passed"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[2].hints[1]",
          "text": "Check contains() before adding"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[2].hints[2]",
          "text": "Validate all destinations in transaction"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[3].title",
          "text": "Time Lock Enforcer Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[3].content",
          "text": "Enforce time-based restrictions on transactions."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[0]",
          "text": "Try bumps from 255 down to 0"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[2]",
          "text": "Check if derived address matches expected"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[2].hints[2]",
          "text": "Collect into Vec<Vec<u8>>"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[3].hints[1]",
          "text": "Signer seeds include all seeds plus bump"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].title",
          "text": "Nested PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].content",
          "text": "Generate PDAs derived from other PDA addresses."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].hints[0]",
          "text": "Include parent address in child seeds"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].title",
          "text": "Counter PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].content",
          "text": "Generate unique PDAs using incrementing counters."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[0]",
          "text": "Increment counter after each generation"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[2]",
          "text": "Batch generation calls generate_next multiple times"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].title",
          "text": "PDA Collision Detector Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[0]",
          "text": "Check if seeds match any existing entry"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[1]",
          "text": "Return error if collision detected"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[1]",
          "text": "Compound inflation year over year"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[2]",
          "text": "APY is inflation divided by staked percentage"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].title",
          "text": "Fee Burn Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].hints[1]",
          "text": "Burn is percentage of total fee"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].title",
          "text": "Rent Economics Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[0]",
          "text": "Annual rent is bytes times rate"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[1]",
          "text": "Exemption is annual times threshold years"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[2]",
          "text": "Rent due is annual times period"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].title",
          "text": "Supply Flow Tracker Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[0]",
          "text": "Total excludes burned tokens"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[1]",
          "text": "Apply flow by subtracting from source, adding to destination"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[2]",
          "text": "Net flow is inflow minus outflow"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].title",
          "text": "Vesting Schedule Impact Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].content",
          "text": "Calculate token unlock impact on supply."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[0]",
          "text": "0 before cliff, linear after, full at end"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[1]",
          "text": "Monthly unlock is difference between consecutive months"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[2]",
          "text": "Check multiple months to find peak"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].title",
          "text": "Protocol Sustainability Score Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[0]",
          "text": "Net issuance is inflation minus burn"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[1]",
          "text": "Burn ratio is burn divided by inflation"
        }
      ],
      "englishLikeMatches": [
        {
          "path": "courses.solana-fundamentals.description",
          "englishWordCount": 22,
          "excerpt": "Introduction orientee production pour les debutants qui veulent des modeles mentaux Solana clairs, un debugging de transactions plus solide et des workflows wallet-manager deterministes."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Core execution model, compte semantics, et transaction construction patterns you need before writing programs or complex clients."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].content",
          "englishWordCount": 269,
          "excerpt": "# Solana modele mental Solana development gets much easier once you stop thinking in terms of \"contracts that own state\" et start thinking in terms of \"programs that operate on comptes.\" On Solana, the durable state of y..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 17,
          "excerpt": "On Solana, mutable app state is compte data. Programs validate et mutate those comptes but do not hold mutable state internally."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "The runtime checks the message envelope et authorization: fee payer, freshness via blockhash, required signatures, et instruction payloads."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].explanation",
          "englishWordCount": 12,
          "excerpt": "Read/write sets let the runtime detect conflicts et parallelize independent work deterministically."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].content",
          "englishWordCount": 243,
          "excerpt": "# Comptes model analyse approfondie Every on-chain object on Solana is an compte avec a standard envelope. You can reason about any compte using a small set of fields: address, lamports, owner, executable flag, et data b..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Executable comptes are code containers; they are not ordinary mutable data comptes."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].explanation",
          "englishWordCount": 13,
          "excerpt": "SPL token state uses dedicated compte layouts et authorization rules enforced by the token program."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].content",
          "englishWordCount": 303,
          "excerpt": "# Transactions & instructions An instruction is the smallest executable unit on Solana: `programId + account metas + opaque data bytes`. A transaction wraps one or more instructions plus signatures et message metadata. T..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].content",
          "englishWordCount": 61,
          "excerpt": "# Build a SOL transfer transaction Implement a deterministic `buildTransferTx(params)` helper in the project file: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` - Use `@solana/web3.js` - Return a trans..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[2]",
          "englishWordCount": 14,
          "excerpt": "Mirror this logic in the real project helper in src/lib/cours/solana-fundamentals/project/walletManager.ts."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Program behavior, deterministic PDA conception, et SPL token modele mentals avec pratique safety checks."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].content",
          "englishWordCount": 240,
          "excerpt": "# Programs: what they are (et aren’t) A Solana program is executable compte code, not an object that secretly owns mutable storage. Your program receives comptes from the transaction, verifies constraints, et writes only..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Compte lists are part of the instruction contract; hidden discovery would break determinism et scheduling assumptions."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].content",
          "englishWordCount": 235,
          "excerpt": "# Adresses Derivees de Programme (PDAs) A Adresse Derivee de Programme (PDA) is a deterministic compte address derived from seeds plus a program ID, avec one key property: it is intentionally off-curve, so no private key..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "invoke_signed proves seed derivation to runtime, which grants PDA signer semantics pour that invocation."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].content",
          "englishWordCount": 230,
          "excerpt": "# SPL Tokens bases SPL Token is Solana’s standard token program family pour fungible assets. A token mint compte defines token-level configuration: decimals, total supply accounting, et authorities such as mint authority..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "Associated Token Comptes standardize where fungible token balances are stored pour each owner/mint."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "englishWordCount": 13,
          "excerpt": "Portefeuilles can only hold SOL while token balances are separate program-owned comptes"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "SPL balances are state in token comptes, not direct fields on portefeuille system comptes."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].content",
          "englishWordCount": 53,
          "excerpt": "# Portefeuille Manager CLI-sim Implement a deterministic CLI parser + command executor in: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` Required behavior: - `address` prints the active pubkey - `build..."
        },
        {
          "path": "courses.anchor-development.description",
          "englishWordCount": 22,
          "excerpt": "Cours oriente projet pour passer des bases a une ingenierie Anchor reelle: modelisation deterministe des comptes, construction des instructions, discipline de test et UX client fiable."
        },
        {
          "path": "courses.anchor-development.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Anchor architecture, compte constraints, et PDA foundations avec explicit ownership of securite-critical decisions."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].content",
          "englishWordCount": 350,
          "excerpt": "# Anchor modele mental Anchor is best understood as a contract between three layers that must agree on shape: your Rust handlers, generated interface metadata (IDL), et client-side instruction builders. In raw Solana pro..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].content",
          "englishWordCount": 264,
          "excerpt": "# Comptes, constraints, et safety Most serious Solana vulnerabilities come from compte validation mistakes, not from arithmetic. Anchor’s constraint system exists to turn those checks into declarative, auditable rules. Y..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].content",
          "englishWordCount": 242,
          "excerpt": "# PDAs in Anchor Adresses Derivees de Programme are the backbone of predictable compte topology in Anchor applications. A PDA is derived from seed bytes plus program ID et intentionally lives off the ed25519 curve, so no..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].content",
          "englishWordCount": 67,
          "excerpt": "# Initialize Counter PDA (deterministic) Implement deterministic helper functions pour a Counter project: - `deriveCounterPda(programId, authorityPubkey)` - `buildInitCounterIx(params)` This lecon validates client-side r..."
        },
        {
          "path": "courses.anchor-development.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Deterministic instruction builders, stable state emulation, et tests strategy that separates pure logic from network integration."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].content",
          "englishWordCount": 40,
          "excerpt": "# Increment instruction builder + state layout Implement deterministic increment behavior in pure TypeScript: - Build a reusable state representation pour counter data. - Implement `applyIncrement` as a pure transition f..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].content",
          "englishWordCount": 245,
          "excerpt": "# Tests strategy without flakiness A reliable Solana curriculum should teach deterministic engineering first, then optional network integration. Flaky tests are usually caused by external dependencies: RPC latency, fauce..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].content",
          "englishWordCount": 253,
          "excerpt": "# Client composition & UX Once instruction layouts et PDA logic are deterministic, client integration becomes a composition exercise: portefeuille adapter pour signing, provider/connection pour transport, transaction bui..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[1]",
          "englishWordCount": 13,
          "excerpt": "Use fixed key order et fixed JSON key order to satisfy strict expected output matching."
        },
        {
          "path": "courses.solana-frontend.description",
          "englishWordCount": 18,
          "excerpt": "Cours oriente projet pour construire des dashboards Solana prets pour la production: reducers deterministes, pipelines d evenements rejouables et UX de transaction fiable."
        },
        {
          "path": "courses.solana-frontend.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Modelez correctement l etat wallet/comptes, concevez l UX du cycle de vie transactionnel et imposez des regles deterministes pour un debugging rejouable."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].content",
          "englishWordCount": 468,
          "excerpt": "# Portefeuille state + comptes modele mental pour UI devs Most Solana frontend bugs are not visual bugs. They are model bugs. A dashboard can look polished while silently computing balances from the wrong compte class, m..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].content",
          "englishWordCount": 355,
          "excerpt": "# Transaction lifecycle pour UI: pending/confirmed/finalized, optimistic UI Frontend transaction UX is a state machine problem. Users press one button, but your app traverses multiple phases: intent creation, transaction..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].content",
          "englishWordCount": 354,
          "excerpt": "# Data correctness: dedupe, ordering, idempotency, correction events Frontend teams frequently assume event streams are perfectly ordered et unique. Production systems rarely behave that way. You can receive duplicate ev..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].content",
          "englishWordCount": 34,
          "excerpt": "# Build core state model + reducer from events Implement a deterministic reducer pour dashboard state: - apply event stream transitions pour balances et mint metadata - enforce idempotency by event id - support correctio..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Corrections should mark replaced event ids et remove their effects from state transitions."
        },
        {
          "path": "courses.solana-frontend.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Construisez reducer, snapshots de replay, metriques de requete et sorties dashboard deterministes stables sous donnees partielles ou retardees."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].content",
          "englishWordCount": 28,
          "excerpt": "# Implement event stream simulator + replay timeline + snapshots Build deterministic replay tooling: - replay sorted events by (ts, id) - snapshot every N applied events - compute stable checksum pour replay output - ret..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].content",
          "englishWordCount": 30,
          "excerpt": "# Implement query layer + computed metrics Implement dashboard query/view logic: - search/filter/sort rows deterministically - compute total et row valueUsd avec fixed-scale integer math - expose stable view model pour U..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].content",
          "englishWordCount": 386,
          "excerpt": "# Production UX: caching, pagination, error banners, skeletons, rate limits After model correctness, frontend quality is mostly about user trust under imperfect conditions. Users do not evaluate your dashboard by clean d..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[3].content",
          "englishWordCount": 27,
          "excerpt": "# Emit stable DashboardSummary from fixtures Compose deterministic checkpoint output: - owner, token count, totalValueUsd - top tokens sorted deterministically - recent activity rows - invariants et determinism metadata ..."
        },
        {
          "path": "courses.defi-solana.description",
          "englishWordCount": 24,
          "excerpt": "Cours avance oriente projet pour les ingenieurs qui construisent des systemes de swap: planification offline deterministe style Jupiter, classement des routes, securite minOut et diagnostics reproductibles."
        },
        {
          "path": "courses.defi-solana.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Comprendre la math CPMM, l anatomie du quote et les tradeoffs du routing deterministe avec des protections utilisateur orientees securite."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].content",
          "englishWordCount": 525,
          "excerpt": "# AMM bases on Solana: pools, fees, slippage, et impact sur le prix When users click “Swap,” they usually assume there is one objective truth: the current price. In practice, frontend swap systems compute an estimate fro..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].content",
          "englishWordCount": 390,
          "excerpt": "# Quote anatomy: in/out, fees, minOut, et worst-case execution A production quote is not one number. It is a structured object that must tell users what they send, what they likely receive, how much they pay in fees, et ..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].content",
          "englishWordCount": 407,
          "excerpt": "# Routing: why two-hop can beat one-hop Users often assume direct pair routes are always best because they are simpler. In fragmented liquidity systems, that assumption fails frequently. A direct SOL -> JUP pool might ha..."
        },
        {
          "path": "courses.defi-solana.modules[1].description",
          "englishWordCount": 17,
          "excerpt": "Construire quoting deterministe, selection de route et checks minOut, puis produire des artefacts de checkpoint stables pour des revues reproductibles."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].content",
          "englishWordCount": 29,
          "excerpt": "# Implement route enumeration et best-route selection Implement deterministic route planner: - enumerate one-hop et two-hop candidates - quote each candidate at exact input size - select best route using stable tie-break..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].content",
          "englishWordCount": 35,
          "excerpt": "# Implement slippage/minOut, fee breakdown, et safety invariants Implement deterministic safety layer: - apply slippage to compute minOut - simulate route avec virtual reserve updates - return structured errors pour inva..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].content",
          "englishWordCount": 404,
          "excerpt": "# Production swap UX: stale quotes, protection, et simulation A deterministic route engine is necessary but not sufficient pour production. Users experience DeFi through timing, messaging, et safety affordances. A mathem..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].content",
          "englishWordCount": 29,
          "excerpt": "# Produce stable SwapPlan + SwapSummary checkpoint Compose deterministic checkpoint artifacts: - build swap plan from selected route quote - include fixtureHash et modelVersion - emit stable summary avec path, minOut, fe..."
        },
        {
          "path": "courses.solana-security.description",
          "englishWordCount": 18,
          "excerpt": "Laboratoire deterministe de vulnerabilites pour auditeurs Solana qui ont besoin de preuves d exploit repetables, de remediation precise et d artefacts d audit a fort signal."
        },
        {
          "path": "courses.solana-security.modules[0].description",
          "englishWordCount": 17,
          "excerpt": "Modelisation des menaces centree sur les comptes, reproduction deterministe d exploits et discipline de preuve pour des findings d audit credibles."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].content",
          "englishWordCount": 562,
          "excerpt": "# Solana threat model pour auditors: comptes, owners, signers, writable, PDAs Securite work on Solana starts avec one non-negotiable fact: instruction callers choose the compte list. Programs do not receive trusted impli..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Without owner checks, compte substitution allows attacker-controlled bytes to be parsed as trusted state."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].content",
          "englishWordCount": 445,
          "excerpt": "# Evidence chain: reproduce, trace, impact, fix, verify Strong securite reports are built on evidence chains, not opinions. In the Solana context, that means moving from a claim such as “missing signer check exists” to a..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].content",
          "englishWordCount": 475,
          "excerpt": "# Common Solana bug classes et mitigations Auditors on Solana repeatedly encounter the same core bug families. The implementation details differ across protocols, but exploit mechanics are surprisingly consistent: identi..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "Securite failures are usually adversarial edge cases, so tests must target those edges directly."
        },
        {
          "path": "courses.solana-security.modules[1].description",
          "englishWordCount": 17,
          "excerpt": "Exploiter, corriger, verifier et produire des artefacts prets pour audit avec traces deterministes et conclusions basees sur des invariants."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].content",
          "englishWordCount": 43,
          "excerpt": "# Break it: exploit missing signer + owner checks Implement a deterministic exploit-proof formatter pour signer/owner vulnerabilities. Expected output fields: - scenario - before/after vault balance - before/after recipi..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].content",
          "englishWordCount": 30,
          "excerpt": "# Break it: exploit PDA spoof mismatch Implement a deterministic PDA spoof proof output. You must show: - expected PDA - accepted PDA - mismatch boolean - trace hash This lecon validates evidence generation pour derivati..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].content",
          "englishWordCount": 30,
          "excerpt": "# Fix it: validations + invariant suite Implement patch validation output that confirms: - signer check - owner check - PDA check - safe u64 arithmetic - exploit blocked state avec error code Keep output deterministic po..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].content",
          "englishWordCount": 455,
          "excerpt": "# Writing audit reports: severity, likelihood, blast radius, remediation A strong audit report is an engineering document, not a narrative essay. It should allow a reader to answer four questions quickly: what failed, ho..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].content",
          "englishWordCount": 29,
          "excerpt": "# Checkpoint: deterministic AuditReport JSON + markdown Create the final deterministic checkpoint payload: - cours + version - scenario IDs - finding count This checkpoint mirrors the final cours artifact produced by the..."
        },
        {
          "path": "courses.token-engineering.description",
          "englishWordCount": 23,
          "excerpt": "Cours oriente projet pour les equipes qui lancent des tokens Solana reels: planification deterministe Token-2022, design des autorites, simulation de supply et discipline operationnelle de lancement."
        },
        {
          "path": "courses.token-engineering.modules[0].description",
          "englishWordCount": 18,
          "excerpt": "Comprendre les primitives token, l anatomie des politiques de mint et les controles d extension Token-2022 avec un cadrage explicite gouvernance et threat model."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].content",
          "englishWordCount": 392,
          "excerpt": "# SPL tokens vs Token-2022: what extensions change Token engineering starts avec a clean boundary between base token semantics et configurable policy. Legacy SPL Token gives you a stable fungible primitive: mint metadata..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].content",
          "englishWordCount": 365,
          "excerpt": "# Mint anatomy: authorities, decimals, supply, freeze, mint A production token launch succeeds or fails on parameter discipline. The mint compte is a compact policy object: it defines decimal precision, minting authority..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].title",
          "englishWordCount": 12,
          "excerpt": "Pieges de securite des extensions: fee configs, abus de delegate, etat de compte par defaut"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].content",
          "englishWordCount": 360,
          "excerpt": "# Extension safety pitfalls: fee configs, delegate abuse, default compte state Token-2022 extensions let teams express policy in a standard token framework, but policy power is exactly where operational failures happen. ..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].content",
          "englishWordCount": 35,
          "excerpt": "# Validate token config + derive deterministic addresses offline Implement strict config validation et deterministic pseudo-derivation: - validate decimals, u64 strings, recipient totals, extension fields - derive stable..."
        },
        {
          "path": "courses.token-engineering.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Construire des workflows deterministes de validation, planification et simulation qui produisent des artefacts de lancement revisables et des criteres go/no-go clairs."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].content",
          "englishWordCount": 32,
          "excerpt": "# Build Token-2022 initialization instruction plan Create a deterministic offline initialization plan: - create mint compte step - init mint step avec decimals - append selected extension steps in stable order - base64 e..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].hints[0]",
          "englishWordCount": 12,
          "excerpt": "Add base steps first: create mint compte, then initialize mint avec decimals."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].content",
          "englishWordCount": 28,
          "excerpt": "# Build mint-to + transfer-fee math + simulation Implement pure simulation pour transfer fees et launch distribution: - fee = min(maxFee, floor(amount * feeBps / 10000)) - aggregate distribution totals deterministically ..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].content",
          "englishWordCount": 359,
          "excerpt": "# Launch checklist: params, upgrade/authority strategy, airdrop/tests plan A successful token launch is an operations exercise as much as a programming task. By the time users see your token in portefeuilles, dozens of c..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].content",
          "englishWordCount": 27,
          "excerpt": "# Emit stable LaunchPackSummary Compose full project output as stable JSON: - normalized authorities et extensions - supply totals et optional fee model examples - deterministic plan metadata et invariants - fixtures has..."
        },
        {
          "path": "courses.solana-mobile.description",
          "englishWordCount": 19,
          "excerpt": "Construisez des dApps Solana mobiles pretes pour la production avec MWA, architecture robuste de session wallet, UX de signature explicite et operations de distribution disciplinees."
        },
        {
          "path": "courses.solana-mobile.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Protocole MWA central, controle du cycle de vie de session et patterns resilients de handoff wallet pour applications mobiles en production."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[0].content",
          "englishWordCount": 344,
          "excerpt": "# Mobile Portefeuille Vue d'ensemble Solana Mobile development is built around the Solana Mobile Stack (SMS), a set of standards et tooling designed pour secure, high-quality crypto-native mobile experiences. SMS is more..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[1].content",
          "englishWordCount": 237,
          "excerpt": "# MWA Integration Integrating Mobile Portefeuille Adapter typically starts avec `@solana-mobile/mobile-wallet-adapter` APIs et an interaction pattern built around `transact()`. Within a transaction session, the app can a..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].content",
          "englishWordCount": 25,
          "excerpt": "# Build a Mobile Transaction Function Implement a helper that formats a deterministic MWA transaction request summary string. Expected output format: `<cluster>|<payer>|<instructionCount>` Use this exact order et delimit..."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[0].content",
          "englishWordCount": 261,
          "excerpt": "# dApp Store Submission Publishing to the Solana dApp Store requires more than packaging binaries. Teams should treat submission as a product, compliance, et securite review process. A strong submission demonstrates safe..."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[1].content",
          "englishWordCount": 284,
          "excerpt": "# Mobile Bonnes pratiques Mobile crypto UX requires balancing speed, safety, et trust. Users make high-stakes decisions on small screens, often on unstable networks. Solana mobile apps should therefore optimize pour expl..."
        },
        {
          "path": "courses.solana-testing.description",
          "englishWordCount": 22,
          "excerpt": "Construisez des systemes de test Solana robustes sur environnements local, simule et reseau avec des invariants de securite explicites et des garde-fous de confiance de niveau release."
        },
        {
          "path": "courses.solana-testing.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Strategie de tests centrale sur couches unit/integration avec workflows deterministes et couverture de cas adversariaux."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[0].content",
          "englishWordCount": 313,
          "excerpt": "# Tests Approaches Tests Solana programs requires multiple layers because failures can occur in logic, compte validation, transaction composition, or network behavior. A production tests strategy usually combines unit te..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[1].content",
          "englishWordCount": 244,
          "excerpt": "# Bankrun Tests Solana Bankrun provides deterministic, high-speed test execution pour Solana programs from TypeScript environments. It emulates a local bank-like runtime where transactions can be processed predictably, c..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[0].content",
          "englishWordCount": 249,
          "excerpt": "# Fuzzing avec Trident Fuzzing explores large input spaces automatically to find bugs that handcrafted tests miss. Pour Solana et Anchor programs, Trident-style fuzzing workflows generate randomized instruction sequences..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[1].content",
          "englishWordCount": 220,
          "excerpt": "# Devnet Tests Devnet tests bridges the gap between deterministic local tests et real-world network conditions. While local validateurs et Bankrun are ideal pour speed et reproducibility, devnet reveals behavior under re..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[2].content",
          "englishWordCount": 216,
          "excerpt": "# CI/CD Pipeline pour Solana A mature Solana CI/CD pipeline enforces quality gates across code, tests, securite checks, et deploiement workflows. Pour program teams, CI is not just linting Rust et TypeScript; it is about..."
        },
        {
          "path": "courses.solana-indexing.description",
          "englishWordCount": 18,
          "excerpt": "Construisez un indexeur d evenements Solana de niveau production avec decodage deterministe, contrats d ingestion resilients, reprise par checkpoints et sorties analytiques fiables."
        },
        {
          "path": "courses.solana-indexing.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Modele d evenements, decodage des comptes token et parsing de metadonnees de transaction pour des pipelines d indexation fiables."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].content",
          "englishWordCount": 318,
          "excerpt": "# Events model: transactions, logs, et program instructions Indexing Solana starts avec understanding where data lives et how to extract structured events from raw chain data. Unlike EVM chains where events are explicit ..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Solana programs emit events via logs et state changes, not explicit event topics."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].content",
          "englishWordCount": 219,
          "excerpt": "# Token compte decoding et SPL layout SPL Token comptes follow a standardized binary layout that indexers must parse to track balances et mint operations. Understanding this layout enables you to extract meaningful data ..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Standard SPL Token comptes are 165 bytes, containing mint, owner, amount, et optional fields."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Amounts are stored as little-endian u64 et must be converted using the mint's decimal places."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[2].content",
          "englishWordCount": 52,
          "excerpt": "# Challenge: Decode token compte + diff token balances Implement deterministic token compte decoding et balance diffing: - Parse a 165-byte SPL Token compte layout - Extract mint, owner, et amount fields - Compute balanc..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].content",
          "englishWordCount": 240,
          "excerpt": "# Transaction meta parsing: logs, errors, et inner instructions Transaction metadata provides the context needed to index complex operations. Understanding how to parse logs, handle errors, et traverse inner instructions..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].content",
          "englishWordCount": 44,
          "excerpt": "# Challenge: Index transactions to normalized events Implement a transaction indexer that produces normalized Event objects: - Parse instruction logs et identify event types - Extract transfer events avec from/to/amount/..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].content",
          "englishWordCount": 228,
          "excerpt": "# Pagination, checkpointing, et caching semantics Production indexers must handle large datasets efficiently while maintaining consistency. Pagination, checkpointing, et caching form the backbone of scalable indexing inf..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[2].content",
          "englishWordCount": 213,
          "excerpt": "# Analytics aggregation: per portefeuille, per token metrics Raw event data becomes valuable through aggregation. Building analytics pipelines enables insights into user behavior, token flows, et protocol usage patterns...."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].content",
          "englishWordCount": 50,
          "excerpt": "# Checkpoint: Produce stable JSON analytics summary Implement the final analytics checkpoint that produces a deterministic summary: - Aggregate events into per-portefeuille et per-token metrics - Generate sorted, stable ..."
        },
        {
          "path": "courses.solana-payments.description",
          "englishWordCount": 21,
          "excerpt": "Construisez des flux de paiement Solana de niveau production avec validations robustes, idempotence sure face aux retries, webhooks securises et recus deterministes pour la reconciliation."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].content",
          "englishWordCount": 264,
          "excerpt": "# Address validation et memo strategies Payment flows on Solana require robust address validation et thoughtful memo strategies. Unlike traditional payment systems avec compte numbers, Solana uses base58-encoded public k..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[1].content",
          "englishWordCount": 221,
          "excerpt": "# Idempotency keys et replay protection Payment systems must handle network failures gracefully. Idempotency ensures that retrying a failed request produces the same outcome as the original, preventing duplicate charges ..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].content",
          "englishWordCount": 48,
          "excerpt": "# Challenge: Create payment intent avec validation Implement a payment intent creator avec full validation: - Validate recipient address format (base58, 32 bytes) - Validate amount (positive, within limits) - Generate de..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[3].content",
          "englishWordCount": 216,
          "excerpt": "# Transaction building et key metadata Building payment transactions requires careful attention to instruction construction, compte metadata, et program interactions. The goal is creating valid, efficient transactions th..."
        },
        {
          "path": "courses.solana-payments.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Construction de transaction, verification d authenticite webhook et generation deterministe de recu avec gestion claire des etats d erreur."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].content",
          "englishWordCount": 36,
          "excerpt": "# Challenge: Build transfer transaction Implement a transfer transaction builder: - Build SystemProgram.transfer pour SOL transfers - Build TokenProgram.transfer pour SPL transfers - Return instruction bundle avec correc..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].content",
          "englishWordCount": 187,
          "excerpt": "# Webhook signing et verification Webhooks enable asynchronous payment notifications. Securite requires cryptographic signing so recipients can verify webhook authenticity et detect tampering. Webhook signing uses HMAC-S..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].content",
          "englishWordCount": 195,
          "excerpt": "# Error state machine et receipt format Payment flows require well-defined state machines to handle the complexity of asynchronous confirmations, failures, et retries. Clear state transitions et receipt formats ensure re..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].content",
          "englishWordCount": 43,
          "excerpt": "# Challenge: Verify webhook et produce receipt Implement the final payment flow checkpoint: - Verify signed webhook signature (HMAC-SHA256) - Extract payment details from payload - Generate standardized receipt JSON - In..."
        },
        {
          "path": "courses.solana-nft-compression.description",
          "englishWordCount": 17,
          "excerpt": "Maitrisez l ingenierie des NFTs compresses sur Solana: engagements Merkle, systemes de preuve, modelisation de collection et controles de securite de niveau production."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Construction d arbre, hashing des feuilles, mecanique d insertion et modele de commitment on-chain/off-chain derriere les actifs compresses."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].content",
          "englishWordCount": 278,
          "excerpt": "# Merkle trees pour state compression Compressed NFTs (cNFTs) on Solana use Merkle trees to dramatically reduce storage costs. Understanding Merkle trees is essential pour working avec compressed NFTs et building compres..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[1].content",
          "englishWordCount": 214,
          "excerpt": "# Leaf hashing conventions et metadata Leaf hashing determines how NFT metadata is committed to the Merkle tree. Understanding these conventions ensures compatibility avec compression standards et proper proof generation..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].content",
          "englishWordCount": 42,
          "excerpt": "# Challenge: Implement Merkle tree insert + root updates Build a Merkle tree implementation avec insertions: - Insert leaves et compute new root - Update parent hashes up the tree - Handle tree growth et depth limits - R..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].content",
          "englishWordCount": 227,
          "excerpt": "# Proof generation et path computation Merkle proofs enable verification of leaf inclusion without accessing the entire tree. Understanding proof generation is essential pour working avec compressed NFTs et building veri..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement proof generation + verifier Build a complete proof system: - Generate proofs from a Merkle tree et leaf index - Verify proofs against a root hash - Handle invalid proofs (wrong siblings, wrong inde..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[1].content",
          "englishWordCount": 216,
          "excerpt": "# Collection mints et metadata simulation Compressed NFT collections use a collection mint as the parent NFT, enabling grouping et verification of related assets. Understanding this hierarchy is essential pour building c..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].content",
          "englishWordCount": 254,
          "excerpt": "# Attack surface: invalid proofs et replay Compressed NFTs introduce unique securite considerations. Understanding attack vectors et mitigations is critical pour building secure compression-aware applications. Invalid pr..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].content",
          "englishWordCount": 53,
          "excerpt": "# Checkpoint: Simulate mint + verify ownership proof Complete the compression lab checkpoint: - Simulate minting a cNFT (insert leaf, update root) - Generate ownership proof pour the minted NFT - Verify the proof against..."
        },
        {
          "path": "courses.solana-governance-multisig.description",
          "englishWordCount": 18,
          "excerpt": "Construisez des systemes DAO et de tresorerie multisig prets pour la production avec comptabilisation de vote deterministe, securite timelock et controles d execution securises."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Cycle de vie des propositions, mecaniques de vote deterministes, politique de quorum et securite timelock pour une gouvernance DAO credible."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].content",
          "englishWordCount": 247,
          "excerpt": "# DAO model: proposals, voting, et execution Decentralized gouvernance on Solana follows a proposal-based model where token holders vote on changes et the DAO treasury executes approved decisions. Understanding this flow..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[1].content",
          "englishWordCount": 185,
          "excerpt": "# Quorum math et vote weight calculation Accurate vote counting is critical pour legitimate gouvernance outcomes. Understanding quorum requirements, vote weight calculation, et edge cases ensures fair decision-making. Qu..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].content",
          "englishWordCount": 169,
          "excerpt": "# Timelock states et execution scheduling Timelocks provide a critical safety layer between gouvernance approval et execution. Understanding timelock states et transitions ensures reliable proposal execution. Timelock st..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Construction de transaction multisig, controles d approbation, defenses anti-replay et patterns d execution securisee de tresorerie."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].content",
          "englishWordCount": 176,
          "excerpt": "# Multisig transaction building et approvals Multisig portefeuilles provide collective control over treasury funds. Understanding multisig construction, approval flows, et securite patterns is essential pour treasury ope..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].content",
          "englishWordCount": 34,
          "excerpt": "# Challenge: Implement multisig tx builder + approval rules Build a multisig transaction system: - Create transactions avec instructions - Record signer approvals - Enforce threshold requirements - Handle approval revoca..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].content",
          "englishWordCount": 191,
          "excerpt": "# Safe defaults: owner checks et replay guards Gouvernance et multisig systems require robust securite defaults. Understanding common vulnerabilities et their mitigations protects treasury funds. Owner checks validate th..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].content",
          "englishWordCount": 48,
          "excerpt": "# Challenge: Execute proposal et produce treasury diff Complete the gouvernance simulator checkpoint: - Execute approved proposals avec timelock validation - Apply treasury state changes atomically - Generate execution t..."
        },
        {
          "path": "courses.solana-performance.description",
          "englishWordCount": 19,
          "excerpt": "Maitrisez l ingenierie de performance Solana avec des workflows d optimisation mesurables: budgets compute, layouts de donnees, efficacite d encodage et modelisation deterministe des couts."
        },
        {
          "path": "courses.solana-performance.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Modele compute, decisions de layout compte/donnees et estimation de cout deterministe pour raisonner la performance au niveau transaction."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].content",
          "englishWordCount": 234,
          "excerpt": "# Compute model: budgets, costs, et limits Solana's compute model enforces deterministic execution limits through compute budgets. Understanding this model is essential pour building efficient programs that stay within l..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[1].content",
          "englishWordCount": 198,
          "excerpt": "# Compte layout conception et serialization cost Compte data layout significantly impacts compute costs. Well-designed layouts minimize serialization overhead et reduce compte access costs. Serialization formats affect c..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement estimateCost(op) model Build a compute cost estimation system: - Model costs pour different operation types - Compte pour instruction complexity - Include memory access costs - Return baseline meas..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].content",
          "englishWordCount": 172,
          "excerpt": "# Instruction data size et encoding optimization Instruction data size directly impacts transaction cost et throughput. Optimizing encoding reduces fees et increases the operations possible within compute limits. Compact..."
        },
        {
          "path": "courses.solana-performance.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Optimisation de layout, tuning du compute budget et analyse before/after de performance avec garde-fous de correction."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].content",
          "englishWordCount": 42,
          "excerpt": "# Challenge: Implement optimized layout/codec Optimize an compte data layout while preserving semantics: - Reduce data size through compact encoding - Maintain all original functionality - Preserve backward compatibility..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].content",
          "englishWordCount": 176,
          "excerpt": "# Compute budget instruction bases Compute budget instructions give developers control over resource allocation et transaction prioritization. Understanding these tools enables precise optimization. setComputeUnitLimit r..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "Specific limits optimize costs - you pay pour the limit requested, not actual usage."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].content",
          "englishWordCount": 172,
          "excerpt": "# Micro-optimizations et tradeoffs Performance optimization involves balancing competing concerns. Understanding tradeoffs helps make informed decisions about when et what to optimize. Readability vs performance is a con..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].content",
          "englishWordCount": 40,
          "excerpt": "# Checkpoint: Compare before/after + output perf report Complete the optimization lab checkpoint: - Measure baseline performance metrics - Apply optimization techniques - Verify correctness is preserved - Generate perfor..."
        },
        {
          "path": "courses.defi-swap-aggregator.description",
          "englishWordCount": 18,
          "excerpt": "Maitrisez l aggregation de swaps en production sur Solana: parsing deterministe des quotes, compromis d optimisation de route, securite slippage et execution orientee fiabilite."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Mecanique de swap token, protection slippage, composition de routes et construction deterministe de SwapPlan avec compromis transparents."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].content",
          "englishWordCount": 404,
          "excerpt": "# Swap modele mental: mints, ATAs, decimals, et routes Token swaps on Solana follow a fundamentally different model than centralized exchanges. Understanding the building blocks — mints, associated token comptes (ATAs), ..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "AMM programs interact avec SPL token comptes. Native SOL must be wrapped into the SPL token format so it can be processed by swap programs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].content",
          "englishWordCount": 383,
          "excerpt": "# Slippage et impact sur le prix: protecting swap outcomes Slippage is the difference between the expected output amount at quote time et the actual amount received at execution time. In volatile markets avec active trad..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].content",
          "englishWordCount": 406,
          "excerpt": "# Route visualization: understanding swap legs et fees Swap routes reveal the path your tokens take through DeFi liquidity. Visualizing routes helps users understand why a multi-hop path might yield more output than a di..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].content",
          "englishWordCount": 65,
          "excerpt": "# Challenge: Build a normalized SwapPlan from a quote Parse a raw aggregator quote response et produce a normalized SwapPlan: - Extract input/output mints et amounts from the quote - Calculate minOutAmount using BigInt s..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Execution par machine d etat, anatomie transaction, patterns de fiabilite retry/staleness et reporting d execution a fort signal."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].content",
          "englishWordCount": 68,
          "excerpt": "# Challenge: Implement swap UI state machine Build a deterministic state machine pour the swap UI flow: - States: idle → quoting → ready → sending → confirming → success | error - Process a sequence of events et track al..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].hints[1]",
          "englishWordCount": 12,
          "excerpt": "If an event is not valid pour the current state, transition to 'error' avec a descriptive message."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].content",
          "englishWordCount": 418,
          "excerpt": "# Swap transaction anatomy: instructions, comptes, et compute A swap transaction on Solana is a carefully ordered sequence of instructions that together achieve an atomic token exchange. Understanding each instruction's ..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 13,
          "excerpt": "Compute budget instructions configure the transaction's CU limit et price before any program execution begins."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "ALTs allow transactions to reference many comptes without exceeding the 1232-byte transaction size limit."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].content",
          "englishWordCount": 382,
          "excerpt": "# Reliability patterns: retries, stale quotes, et latency Production swap flows must handle the reality of network latency, expired quotes, et transaction failures. Reliability engineering separates toy swap implementati..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].content",
          "englishWordCount": 68,
          "excerpt": "# Checkpoint: Generate a SwapRunReport Build the final swap run report that combines all cours concepts: - Summarize the route avec leg details et total fees (using BigInt summation) - Compute the effective price as outA..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Collect errors from both the state machine result et any additional errors array."
        },
        {
          "path": "courses.defi-clmm-liquidity.description",
          "englishWordCount": 18,
          "excerpt": "Maitrisez l ingenierie de liquidite concentree sur les DEX Solana: mathematiques de tick, strategie de range, dynamique fees/IL et reporting deterministe des positions LP."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Concepts de liquidite concentree, maths tick/prix et comportement des positions de range pour raisonner sur l execution CLMM."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].content",
          "englishWordCount": 645,
          "excerpt": "# CLMM vs constant product: why ticks exist Concentrated Liquidity Market Makers (CLMMs) represent a fundamental evolution in automated market maker conception. To understand why they exist, we must first understand the ..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Ticks provide discrete price points pour position boundaries, liquidity transitions, et efficient fee tracking at tick crossings."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].content",
          "englishWordCount": 553,
          "excerpt": "# Price, tick, et sqrtPrice: core conversions The mathematical foundation of every CLMM rests on three interrelated representations of price: the human-readable price, the tick index, et the sqrtPriceX64. Understanding h..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Token amounts in a CLMM position are linear functions of sqrtPrice, making on-chain computation simpler et more gas-efficient."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].content",
          "englishWordCount": 627,
          "excerpt": "# Range positions: in-range et out-of-range dynamics A CLMM position is defined by its lower tick et upper tick. These two boundaries determine the price range in which the position is active, earns fees, et holds a mix ..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].content",
          "englishWordCount": 61,
          "excerpt": "# Challenge: Implement tick/price conversion helpers Implement the core tick math functions used in every CLMM integration: - Convert a tick index to a human-readable price using price = 1.0001^tick - Convert the price t..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Simulation d accumulation des fees, compromis des strategies de range, risques de precision et reporting deterministe du risque de position."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].content",
          "englishWordCount": 66,
          "excerpt": "# Challenge: Simulate position fee accrual Implement a fee accrual simulator pour a CLMM position over a price path: - Convert lower et upper tick boundaries to prices - Walk through each price in the path et determine i..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].content",
          "englishWordCount": 628,
          "excerpt": "# Range strategies: tight, wide, et rebalancing rules Choosing the right price range is the most important decision a CLMM liquidity provider makes. The range determines capital efficiency, fee income, impermanent loss e..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "Tight ranges concentrate capital pour higher efficiency et fee share, but the position goes out-of-range more often, requiring active management."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 18,
          "excerpt": "Full-range positions replicate constant product behavior et never go out-of-range, making them suitable pour highly volatile or unpredictable pairs."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].content",
          "englishWordCount": 666,
          "excerpt": "# CLMM risks: rounding, overflow, et tick spacing errors Building reliable CLMM integrations requires awareness of precision risks that can cause incorrect calculations, failed transactions, or lost funds. This lecon cat..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].content",
          "englishWordCount": 64,
          "excerpt": "# Checkpoint: Generate a Position Report Implement a comprehensive LP position report generator that combines all CLMM concepts: - Convert tick boundaries to human-readable prices - Determine in-range or out-of-range sta..."
        },
        {
          "path": "courses.defi-lending-risk.description",
          "englishWordCount": 17,
          "excerpt": "Maitrisez l ingenierie du risque lending Solana: mecaniques de taux/utilisation, analyse des chemins de liquidation, securite oracle et reporting deterministe de scenarios."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].description",
          "englishWordCount": 17,
          "excerpt": "Mecanique des pools de lending, modeles de taux pilotes par l utilisation et bases de health factor necessaires a une analyse de risque defendable."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].content",
          "englishWordCount": 530,
          "excerpt": "# Lending pool model: supply, borrow, et utilization Lending protocols are the backbone of decentralized finance. They enable users to earn yield on idle assets by supplying them to a shared pool, while borrowers draw fr..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].content",
          "englishWordCount": 435,
          "excerpt": "# Interest rate curves et the kink model Interest rates in lending protocols are not fixed. They adjust dynamically based on pool utilization to balance supply et demand pour liquidity. The piecewise-linear \"kink\" model ..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "Above the kink, slope2 (the jump multiplier) applies, causing borrow rates to spike sharply et discourage further borrowing."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Supply rate = borrowRate * utilization * (1 - reserveFactor). Since utilization < 1 et reserveFactor > 0, the supply rate is always less than the borrow rate."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].content",
          "englishWordCount": 440,
          "excerpt": "# Health factor monitoring et liquidation preview The health factor is the single number that determines whether a lending position is safe or subject to liquidation. Monitoring health factors in real time is essential p..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].content",
          "englishWordCount": 85,
          "excerpt": "# Challenge: Compute utilization-based interest rates Implement the kink-based interest rate model used by lending protocols: - Calculate the utilization ratio from total supply et total borrowed - Apply the piecewise-li..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].description",
          "englishWordCount": 18,
          "excerpt": "Calcul du health factor, mecanique de liquidation, gestion des pannes oracle et reporting de risque multi-scenarios pour des marches sous stress."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].content",
          "englishWordCount": 74,
          "excerpt": "# Challenge: Compute health factor et liquidation status Implement the health factor computation pour a multi-asset lending position: - Sum collateral et borrow values from an array of position objects - Compute weighted..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].content",
          "englishWordCount": 530,
          "excerpt": "# Liquidation mechanics: bonus, close factor, et bad debt Liquidation is the enforcement mechanism that keeps lending protocols solvent. When a borrower's health factor falls below 1.0, external actors called liquidators..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 17,
          "excerpt": "The liquidation bonus compensates liquidators pour gas costs et risk, ensuring positions are liquidated promptly to protect the protocol."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 20,
          "excerpt": "Bad debt materializes when rapid price drops make collateral worth less than the debt, leaving the protocol avec unrecoverable losses."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].content",
          "englishWordCount": 573,
          "excerpt": "# Oracle risk et stale pricing in lending Lending protocols depend entirely on accurate, timely price feeds to compute collateral values, health factors, et liquidation eligibility. Oracles — the services that bring off-..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "Using price minus confidence pour collateral gives a conservative valuation, protecting the protocol when oracle publishers disagree or markets are volatile."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Operating on stale prices is dangerous. Pausing operations prevents incorrect liquidations et under-collateralized borrows during oracle outages."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].content",
          "englishWordCount": 78,
          "excerpt": "# Checkpoint: Generate a multi-scenario risk report Build the final risk report that combines all cours concepts: - Evaluate a base case using current position prices - Apply price overrides from multiple named scenarios..."
        },
        {
          "path": "courses.defi-perps-risk-console.description",
          "englishWordCount": 18,
          "excerpt": "Maitrisez l ingenierie du risque perps sur Solana: comptabilite precise PnL/funding, surveillance de marge, simulation de liquidation et reporting deterministe sur console."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Mecanique des contrats perpetuels, logique d accumulation du funding et bases de modelisation PnL pour des diagnostics de position precis."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].content",
          "englishWordCount": 608,
          "excerpt": "# Perpetual futures: base positions, entry price, et mark vs oracle Perpetual futures (perps) are synthetic derivatives that let traders gain exposure to an asset's price movement without holding the underlying token. Un..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].content",
          "englishWordCount": 601,
          "excerpt": "# Funding rates: why they exist et how they accrue Funding rates are the mechanism that tethers a perpetual contract's price to the underlying spot price. Without funding, the perp price could drift arbitrarily far from ..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "A positive premium (mark > oracle) produces a positive funding rate. Longs pay shorts, which discourages excessive long demand et pushes the perp price back toward spot."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].content",
          "englishWordCount": 561,
          "excerpt": "# PnL visualization: tracking profit over time Profit et loss (PnL) tracking in perpetual futures requires careful accounting across multiple dimensions: unrealized PnL from price movement, realized PnL from closed porti..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].content",
          "englishWordCount": 56,
          "excerpt": "# Challenge: Calculate perpetual futures PnL Implement a PnL calculator pour perpetual futures positions: - Compute unrealized PnL based on entry price vs mark price - Handle both long et short positions correctly - Calc..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].content",
          "englishWordCount": 71,
          "excerpt": "# Challenge: Simulate funding rate accrual Build a funding accrual simulator that processes discrete funding intervals: - Iterate through an array of funding rates et compute the payment pour each period - Longs pay (sub..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Suivi de marge et liquidation, pieges classiques d implementation et sorties deterministes de console de risque pour l observabilite en production."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].content",
          "englishWordCount": 600,
          "excerpt": "# Margin ratio et liquidation thresholds Margin is the collateral that backs a leveraged position. When the margin falls below a critical threshold relative to the position's notional value, the protocol forcibly closes ..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 27,
          "excerpt": "The maintenance buffer ensures that when a position is liquidated, there is still margin left to pay liquidation fees et absorb slippage during the close. Without it, positions could go underwater, creating bad debt."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].content",
          "englishWordCount": 752,
          "excerpt": "# Common bugs: sign errors, units, et funding direction Perpetual futures implementations are mathematically straightforward — the formulas are basic arithmetic. Yet sign errors, unit mismatches, et funding direction bug..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 37,
          "excerpt": "When size carries the direction sign, every formula that uses size must compte pour the sign — not just PnL, but also notional value, funding payments, et liquidation price. Keeping size positive et branching on a separa..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].content",
          "englishWordCount": 75,
          "excerpt": "# Checkpoint: Generate a Risk Console Report Build the comprehensive risk console report that integrates all cours concepts: - Calculate unrealized PnL et ROE pour the position - Accumulate funding payments across all pr..."
        },
        {
          "path": "courses.defi-tx-optimizer.description",
          "englishWordCount": 17,
          "excerpt": "Maitrisez l optimisation de transactions DeFi sur Solana: tuning compute/frais, strategie ALT, patterns de fiabilite et planification deterministe de strategie d envoi."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Diagnostic des echecs de transaction, mecanique compute budget, strategie de priority fee et bases d estimation des frais."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].content",
          "englishWordCount": 564,
          "excerpt": "# Why DeFi transactions fail: CU limits, size, et blockhash expiry DeFi transactions on Solana fail pour three primary reasons: compute budget exhaustion, transaction size overflow, et blockhash expiry. Understanding eac..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Expired blockhash transactions are never processed et produce no on-chain record. The client must detect the timeout et resubmit avec a fresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].content",
          "englishWordCount": 463,
          "excerpt": "# Compute budget instructions et priority fee strategy The Compute Budget Program provides two critical instructions that every serious DeFi transaction should include: `SetComputeUnitLimit` et `SetComputeUnitPrice`. Tog..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Compte state may change between simulation et execution, causing minor CU variations. A 10% margin absorbs these differences."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].content",
          "englishWordCount": 462,
          "excerpt": "# Transaction cost estimation et fee planning Accurate fee estimation is the foundation of a good DeFi user experience. Users need to know what a transaction will cost before they sign it. Validateurs need sufficient fee..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].content",
          "englishWordCount": 79,
          "excerpt": "# Challenge: Build a transaction plan avec compute budgeting Build a transaction planning function that analyzes a set of instructions et produces a complete transaction plan: - Sum estimatedCU from all instructions et a..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Planification Address Lookup Table, patterns de fiabilite/retry, UX d erreurs actionnables et reporting complet de strategie d envoi."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].content",
          "englishWordCount": 97,
          "excerpt": "# Challenge: Plan Address Lookup Table usage Build a function that determines the optimal Address Lookup Table strategy pour a transaction: - Collect all unique compte keys across instructions - Check which keys exist in..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].content",
          "englishWordCount": 550,
          "excerpt": "# Reliability patterns: retry, re-quote, resend vs rebuild Production DeFi applications must handle transaction failures gracefully. The difference between a frustrating et a reliable experience comes down to retry strat..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "englishWordCount": 12,
          "excerpt": "To prevent many clients from retrying at the exact same moment et overwhelming the network"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].content",
          "englishWordCount": 586,
          "excerpt": "# UX: actionable error messages pour transaction failures Raw Solana error messages are cryptic. \"Transaction simulation failed: Error processing Instruction 2: custom program error: 0x1771\" tells a developer something b..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].content",
          "englishWordCount": 89,
          "excerpt": "# Checkpoint: Generate a send strategy report Build the final send strategy report that combines all cours concepts into a comprehensive transaction optimization plan: - Build a tx plan: sum CU estimates avec 10% margin ..."
        },
        {
          "path": "courses.solana-mobile-signing.description",
          "englishWordCount": 19,
          "excerpt": "Maitrisez la signature wallet mobile en production sur Solana: sessions Android MWA, contraintes deep-link iOS, retries resilients et telemetrie de session deterministe."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Contraintes plateforme, patterns UX de connexion, comportement de timeline de signature et construction typee des requests sur Android/iOS."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].content",
          "englishWordCount": 709,
          "excerpt": "# Mobile signing reality check: Android vs iOS constraints Mobile portefeuille signing on Solana is fundamentally different from browser-based portefeuille interactions. The constraints imposed by Android et iOS operatin..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "Android MWA uses foreground services to maintain a persistent communication channel between the dApp et portefeuille, enabling multi-request sessions without app switching."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].content",
          "englishWordCount": 715,
          "excerpt": "# Portefeuille connection UX patterns: connect, reconnect, et recovery Portefeuille connection on mobile is the first interaction users have avec your dApp. A smooth connection flow builds trust; a broken one drives user..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "Network mismatches should be communicated clearly to the user avec instructions on how to resolve them, avoiding confusing silent failures."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].content",
          "englishWordCount": 667,
          "excerpt": "# Signing session timeline: request, portefeuille, et response flow Understanding the complete lifecycle of a mobile signing request is essential pour building reliable dApps. Every sign request passes through multiple s..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].content",
          "englishWordCount": 70,
          "excerpt": "# Challenge: Build a typed sign request Implement a sign request builder pour Mobile Portefeuille Adapter: - Validate the payload type (transaction or message) - Validate payload data (base64 pour transactions, non-empty..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[2]",
          "englishWordCount": 13,
          "excerpt": "App identity requires at least name et URI. Icon is optional but should default to empty string."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].description",
          "englishWordCount": 17,
          "excerpt": "Persistance de session, securite des ecrans de revue de transaction, machines d etat de retry et reporting deterministe de session pour apps mobiles en production."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].content",
          "englishWordCount": 59,
          "excerpt": "# Challenge: Session persistence et restoration Implement a session persistence manager pour mobile portefeuille sessions: - Process a sequence of actions: save, restore, clear, et expire_check - Track portefeuille addre..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].content",
          "englishWordCount": 633,
          "excerpt": "# Mobile transaction review: what users need to see Transaction review screens are the last line of defense between a user et a potentially harmful transaction. On mobile, screen real estate is limited et user attention ..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 17,
          "excerpt": "Token amounts must be converted to human-readable format using the token's decimal configuration et include the symbol pour clarity."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].content",
          "englishWordCount": 710,
          "excerpt": "# One-tap retry: handling offline, rejected, et timeout states Mobile environments are inherently unreliable. Users move between WiFi et cellular, enter tunnels, close apps mid-transaction, et portefeuilles crash. A robu..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].content",
          "englishWordCount": 59,
          "excerpt": "# Checkpoint: Generate a session report Implement a session report generator that summarizes a complete mobile signing session: - Count total requests, successful signs, et failed signs - Sum retry attempts across all re..."
        },
        {
          "path": "courses.solana-pay-commerce.description",
          "englishWordCount": 16,
          "excerpt": "Maitrisez l integration commerce Solana Pay: encodage URL robuste, workflows de suivi QR/paiement, UX de confirmation et artefacts deterministes de reconciliation POS."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Specification Solana Pay, rigueur d encodage URL, anatomie des transfer requests et patterns deterministes de builder/encoder."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].content",
          "englishWordCount": 589,
          "excerpt": "# Solana Pay modele mental et URL encoding rules Solana Pay is an open specification pour encoding payment requests into URLs that portefeuilles can parse et execute. Unlike traditional payment processors that rely on ce..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "The Solana Pay specification uses the 'solana:' scheme followed immediately by the recipient address avec no slashes."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].content",
          "englishWordCount": 631,
          "excerpt": "# Transfer request anatomy: recipient, amount, reference, et labels A Solana Pay transfer request URL contains everything a portefeuille needs to construct et submit a payment transaction. Each component of the URL serve..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 22,
          "excerpt": "The reference public key is included as a non-signer compte in the transfer instruction. The merchant polls getSignaturesForAddress(reference) to detect when the payment transaction confirms."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 20,
          "excerpt": "Solana Pay URLs use human-readable decimal amounts. The portefeuille handles the conversion to raw units based on the token's decimal configuration."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].content",
          "englishWordCount": 473,
          "excerpt": "# URL builder: live preview of Solana Pay URLs Building Solana Pay URLs correctly requires understanding how each parameter contributes to the final encoded string. In this lecon, we walk through the construction process..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].content",
          "englishWordCount": 73,
          "excerpt": "# Challenge: Encode a Solana Pay transfer request URL Build a function that encodes a Solana Pay transfer request URL from input parameters: - Validate the recipient address (must be 32-44 characters of valid base58) - V..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Machines d etat de tracking par reference, UX de confirmation, gestion des echecs et generation deterministe de recu POS."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].content",
          "englishWordCount": 84,
          "excerpt": "# Challenge: Track payment references through confirmation states Build a reference tracking state machine that processes payment events: - States flow: pending -> found -> confirmed -> finalized (or pending -> expired) ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].content",
          "englishWordCount": 644,
          "excerpt": "# Confirmation UX: pending, confirmed, et expired states The user experience during payment confirmation is the most critical moment in any Solana Pay integration. Between the customer scanning the QR code et the merchan..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "englishWordCount": 13,
          "excerpt": "Confirmed is sufficient pour low-value POS transactions; finalized is needed pour irreversible digital fulfillment"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "Pour coffee-shop-scale payments, confirmed commitment provides a strong enough guarantee. Finalized adds 6-12 seconds of latency et is only necessary when fulfillment is irreversible."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 22,
          "excerpt": "Expired requests should be clearly communicated. The customer may have been in the middle of approving — they need to know the request expired et can try again."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].content",
          "englishWordCount": 698,
          "excerpt": "# Error handling et edge cases in payment flows Production payment systems encounter a wide range of failure modes that must be handled gracefully. Solana Pay integrations face challenges unique to blockchain payments: n..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].content",
          "englishWordCount": 78,
          "excerpt": "# Checkpoint: Generate a POS receipt Build the final POS receipt generator that combines all cours concepts: - Reconstruct the Solana Pay URL from payment data (recipient, amount, spl-token, reference, label) - Generate ..."
        },
        {
          "path": "courses.wallet-ux-engineering.description",
          "englishWordCount": 16,
          "excerpt": "Maitrisez l ingenierie UX wallet en production sur Solana: etat de connexion deterministe, securite reseau, resilience RPC et patterns de fiabilite mesurables."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Design de connexion wallet, network gating et architecture deterministe de machine d etat pour onboarding et reconnexion previsibles."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].content",
          "englishWordCount": 701,
          "excerpt": "# Connection UX that doesn't suck: a conception checklist Portefeuille connection is the first interaction a user has avec any Solana dApp. If this experience is slow, confusing, or error-prone, most users will leave bef..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 18,
          "excerpt": "Skeleton UI reserves the layout space pour portefeuille-dependent content, preventing jarring shifts when the connection resolves et data loads."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].content",
          "englishWordCount": 715,
          "excerpt": "# Network gating et wrong-network recovery Solana has multiple clusters: mainnet-beta, devnet, testnet, et localnet. Unlike EVM chains where the portefeuille controls the network et emits chain-change events, Solana's ne..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 31,
          "excerpt": "Each Solana cluster has a unique genesis hash. Comparing the RPC's genesis hash against known values is the only reliable detection method, since URL strings can be misleading et portefeuilles don't always expose network..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "While compte addresses are identical across clusters, the compte states (balances, data, existence) are completely different. All cached RPC data must be cleared on network switch."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].content",
          "englishWordCount": 605,
          "excerpt": "# Connection state machine: states, events, et transitions Portefeuille connection logic in most dApps is implemented as a tangle of boolean flags, useEffect hooks, et conditional renders. This approach leads to impossib..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].content",
          "englishWordCount": 73,
          "excerpt": "# Challenge: Implement portefeuille connection state machine Build a deterministic state machine pour portefeuille connection management: - States: disconnected, connecting, connected, error - Process a sequence of event..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Invalidation de cache, resilience et monitoring de sante RPC, et reporting mesurable de qualite UX wallet pour les operations production."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].content",
          "englishWordCount": 85,
          "excerpt": "# Challenge: Cache invalidation on portefeuille events Build a cache invalidation engine that processes portefeuille events et invalidates the correct cache entries: - Cache entries have tags: \"compte\" (portefeuille-spec..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].content",
          "englishWordCount": 686,
          "excerpt": "# RPC reads et caching strategy pour portefeuille apps Every interaction in a Solana portefeuille application ultimately depends on RPC calls: fetching balances, loading token comptes, reading program state, et confirmin..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "englishWordCount": 12,
          "excerpt": "Compte states differ across clusters, so cached devnet data would be wrong pour mainnet"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 26,
          "excerpt": "The same compte address can have completely different state on mainnet vs devnet. Without the network in the key, switching clusters would return stale data from the previous cluster."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "SWR prioritizes responsiveness by serving stale data instantly while refreshing in the background. This eliminates loading states pour data that has only slightly exceeded its TTL."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].content",
          "englishWordCount": 859,
          "excerpt": "# RPC health monitoring et graceful degradation RPC endpoints are the lifeline of every Solana portefeuille application. When they go down, become slow, or return stale data, your app becomes unusable. Production portefe..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].content",
          "englishWordCount": 74,
          "excerpt": "# Checkpoint: Generate a Portefeuille UX Report Build the final portefeuille UX quality report that combines all cours concepts: - Count connection attempts (CONNECT events) et successful connections (CONNECTED events) -..."
        },
        {
          "path": "courses.sign-in-with-solana.description",
          "englishWordCount": 20,
          "excerpt": "Maitrisez l authentification SIWS en production sur Solana: entrees standardisees, invariants stricts de verification, cycle de vie nonce resistant au replay et reporting pret pour audit."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Raison d etre de SIWS, semantique stricte des champs d entree, comportement de rendu wallet et construction deterministe d un sign-in input."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].content",
          "englishWordCount": 806,
          "excerpt": "# Why SIWS exists: replacing connect-et-signMessage Before Sign-In Avec Solana (SIWS) became a standard, dApps authenticated portefeuille holders using a two-step pattern: connect the portefeuille, then call `signMessage..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 25,
          "excerpt": "Without structured format, portefeuilles treat signMessage payloads as opaque bytes et cannot validate or warn about the content, making it easy pour malicious dApps to disguise harmful payloads as sign-in requests."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "The server generates a unique nonce pour each sign-in attempt. After successful verification, the nonce is marked as consumed. Any reuse of the same nonce is rejected as a replay attack."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].content",
          "englishWordCount": 826,
          "excerpt": "# SIWS input fields et securite rules The Sign-In Avec Solana input is a structured object that defines every parameter of an authentication request. Each field has specific validation rules, securite implications, et re..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "If the client generates nonces, an attacker can replay a previously captured nonce-signature pair. Server-generated nonces ensure each authentication attempt is unique et controlled by the server."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "The domain field must be a plain domain name. Protocol prefixes, paths, ports, et query strings must be rejected to ensure consistent domain matching."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[2].content",
          "englishWordCount": 818,
          "excerpt": "# Message preview: how portefeuilles render SIWS requests When a dApp sends a SIWS sign-in request to a portefeuille, the portefeuille transforms the structured input into a human-readable message that the user sees on t..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].content",
          "englishWordCount": 69,
          "excerpt": "# Challenge: Build a validated SIWS sign-in input Implement a function that creates a validated Sign-In Avec Solana input: - Validate domain (non-empty, must not include protocol prefix) - Validate nonce (at least 8 char..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Invariants de verification server-side, defenses nonce anti-replay, gestion de session et reporting deterministe d audit d authentification."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].content",
          "englishWordCount": 59,
          "excerpt": "# Challenge: Verify a SIWS sign-in response Implement server-side verification of a SIWS sign-in output: - Check domain matches expected domain - Check nonce matches expected nonce - Check issuedAt is not in the future r..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].content",
          "englishWordCount": 791,
          "excerpt": "# Sessions et logout: what to store et what not to store After a successful SIWS sign-in verification, the server must establish a session so the user does not need to re-authenticate on every request. Session management..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 30,
          "excerpt": "Portefeuille addresses are publicly known. Using them as session IDs would allow anyone who knows a user's address to impersonate their session. Random tokens ensure only the authenticated client can present a valid sess..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 22,
          "excerpt": "Portefeuille disconnection signals the user's intent to end the interaction. The dApp should respect this by invalidating the session, preventing confusion about authentication state."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].content",
          "englishWordCount": 881,
          "excerpt": "# Replay protection et nonce registry conception Replay attacks are the most critical threat to any signature-based authentication system. In a replay attack, an adversary captures a valid signed message et submits it ag..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].content",
          "englishWordCount": 80,
          "excerpt": "# Checkpoint: Generate an auth audit report Build the final auth audit report that combines all cours concepts: - Process an array of authentication attempts avec address, nonce, et verified status - Track used nonces to..."
        },
        {
          "path": "courses.priority-fees-compute-budget.description",
          "englishWordCount": 16,
          "excerpt": "Ingenierie defensive des frais Solana avec planification compute deterministe, politique de priorite adaptative et contrats UX de fiabilite axes confirmation."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Mecaniques d inclusion, couplage compute/frais et design de politique guide par explorer avec cadrage deterministe de fiabilite."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].content",
          "englishWordCount": 587,
          "excerpt": "# Fee markets on Solana: what actually moves inclusion Priority fees on Solana are often explained as a simple slider, but production systems need a more precise model. Inclusion is influenced by contention pour compute,..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "A large CU request avec weak price can lose inclusion, while aggressive price on oversized CU can overpay."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].content",
          "englishWordCount": 542,
          "excerpt": "# Compute budget bases et common failure modes Most transaction failures blamed on \"network issues\" are actually planning errors in compute budget et payload sizing. A defensive client treats compute planning as a determ..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[2].content",
          "englishWordCount": 465,
          "excerpt": "# Explorer: compute budget planner inputs to plan Explorers are useful only when they expose policy tradeoffs clearly. Pour a fee et compute planner, that means visualizing how input estimates, percentile targets, et con..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Implementer des planners deterministes, des moteurs de politique de confirmation et des artefacts stables de strategie de frais pour revue release."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].content",
          "englishWordCount": 12,
          "excerpt": "Implement policy-based priority fee estimation using synthetic sample arrays et deterministic warnings."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[2].content",
          "englishWordCount": 12,
          "excerpt": "Encode confirmation UX policy pour processed, confirmed, et finalized states using deterministic risk bands."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].content",
          "englishWordCount": 15,
          "excerpt": "Build stable markdown output pour a fee strategy summary that users et support teams can review quickly."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[4].content",
          "englishWordCount": 12,
          "excerpt": "Produce a deterministic checkpoint report JSON pour the Fee Optimizer final project artifact."
        },
        {
          "path": "courses.bundles-atomicity.description",
          "englishWordCount": 18,
          "excerpt": "Concevez des flux Solana defensifs multi-transactions avec validation deterministe de l atomicite, modelisation de compensation et reporting securite pret pour audit."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Modele d atomicite, risques des flux multi-transactions et validation defensive de securite pour proteger les attentes utilisateur."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].content",
          "englishWordCount": 525,
          "excerpt": "# Atomicity concepts et why users assume all-or-nothing Users rarely think in transaction graphs. They think in intents: \"swap my token\" or \"close my position.\" When a workflow spans multiple transactions, user expectati..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].content",
          "englishWordCount": 503,
          "excerpt": "# Multi-transaction flows: approvals, ATA creation, swaps, refunds A reliable flow simulator must encode where partial execution risk lives. In practice, risk points cluster at boundaries: before value transfer, during v..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[2].content",
          "englishWordCount": 463,
          "excerpt": "# Explorer: flow graph steps et risk points Flow graph explorers are most valuable when they highlight risk semantics, not just sequence order. A defensive explorer should display each step avec dependency context, idemp..."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Implementer des validateurs d atomicite deterministes, des patterns de gestion d echec et une composition stable de bundles pour revue de release."
        },
        {
          "path": "courses.mempool-ux-defense.description",
          "englishWordCount": 15,
          "excerpt": "Ingenierie defensive UX de swap avec notation de risque deterministe, politiques de slippage bornees et communication securite prete pour incident."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Risques entre quote et execution, guardrails de slippage et decisions de fraicheur pour des swaps plus surs en production."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].content",
          "englishWordCount": 533,
          "excerpt": "# What can go wrong between quote et execution A swap quote is a prediction, not a guarantee. Between quote generation et execution, liquidity changes, competing orders land, et network conditions shift. Users often assu..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[1].content",
          "englishWordCount": 482,
          "excerpt": "# Slippage controls et guardrails Slippage settings are a policy surface, not a cosmetic preference. Defensive swap UX defines explicit bounds, context-aware defaults, et clear consequences when users attempt risky overr..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[2].content",
          "englishWordCount": 448,
          "excerpt": "# Explorer: quote freshness timer et decision table A quote freshness explorer should make policy behavior obvious under time pressure. Users et engineers need to see when a quote transitions from safe to warning to bloc..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implementer des gardes de slippage, des modeles d impact et des configurations de protection exportables avec sortie deterministe."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[0].content",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic swap risk grading from quote, slippage, impact, hops, et liquidity inputs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.description",
          "englishWordCount": 17,
          "excerpt": "Construisez des pipelines d indexation deterministes de niveau production pour ingestion sure contre doublons, gestion de reorg et reporting centre integrite."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Bases d indexation, realite reorg/confirmation et etapes de pipeline pour des ingestions tracables et sures."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].content",
          "englishWordCount": 509,
          "excerpt": "# Indexing 101: logs, comptes, et transaction parsing Reliable indexers are not just fast parsers. They are consistency systems that decide what to trust, when to trust it, et how to recover from changing chain history. ..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[1].content",
          "englishWordCount": 457,
          "excerpt": "# Reorgs et fork choice: why confirmed is not finalized Confirmation labels are useful but often misunderstood in indexing pipelines. A confirmed event has stronger confidence than processed, but it is not equivalent to ..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[2].content",
          "englishWordCount": 462,
          "excerpt": "# Explorer: ingest to dedupe to confirm to apply A pipeline explorer should explain transformation stages clearly so engineers can inspect where correctness can break. Pour indexing reliability, the core stages are inges..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implementer la logique de confirmations, la planification backfill/idempotence et les checks d integrite pour des rapports pipeline stables."
        },
        {
          "path": "courses.rpc-reliability-latency.description",
          "englishWordCount": 16,
          "excerpt": "Concevez des clients RPC Solana multi-fournisseurs de niveau production avec politiques deterministes de retry, routage, cache et observabilite."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Real-world RPC failure behavior, endpoint selection strategy, et deterministic retry policy modeling."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].content",
          "englishWordCount": 520,
          "excerpt": "# RPC failures in real life: timeouts, 429s, stale nodes Reliable client infrastructure begins avec realistic failure assumptions. RPC calls fail pour many reasons: transient network timeouts, provider rate limits, stale..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].content",
          "englishWordCount": 430,
          "excerpt": "# Multi-endpoint strategies: hedged requests et fallbacks Multi-endpoint conception is more than adding a backup URL. It is a scheduling problem where each request should be sent to the most suitable endpoint given recen..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].content",
          "englishWordCount": 460,
          "excerpt": "# Explorer: retry/backoff simulator Retry et backoff policies determine whether clients recover gracefully or amplify outages. A simulator should make schedule behavior explicit so teams can reason about user latency et ..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Build deterministic policy engines pour routing, retries, metrics reduction, et health report exports."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].content",
          "englishWordCount": 12,
          "excerpt": "Export deterministic JSON et markdown health report artifacts pour multi-provider reliability review."
        },
        {
          "path": "courses.rust-data-layout-borsh.description",
          "englishWordCount": 16,
          "excerpt": "Ingenierie de layout de donnees Solana orientee Rust avec outillage deterministe au niveau octet et pratiques de schema sures pour la compatibilite."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Alignment behavior, Borsh encoding rules, et pratique parsing safety pour stable byte-level contracts."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].content",
          "englishWordCount": 555,
          "excerpt": "# Memory layout: alignment, padding, et why Solana comptes care Rust layout behavior is deterministic inside one compiled binary but can vary when assumptions are implicit. Pour Solana comptes, this matters because raw b..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].content",
          "englishWordCount": 492,
          "excerpt": "# Struct et enum layout pitfalls plus Borsh rules Borsh is widely used because it gives deterministic serialization across languages, but teams still get tripped up by how enums, vectors, et strings map to bytes. Underst..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[2].content",
          "englishWordCount": 443,
          "excerpt": "# Explorer: layout visualizer pour field offsets A layout visualizer turns abstract alignment rules into concrete numbers engineers can review. Instead of debating whether a struct is \"probably fine,\" teams can inspect e..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic layout analysis, encoding/decoding, safe parsing, et compatibility-focused reporting helpers."
        },
        {
          "path": "courses.rust-errors-invariants.description",
          "englishWordCount": 17,
          "excerpt": "Construisez des bibliotheques typees de garde d invariants avec artefacts de preuve deterministes, contrats d erreur compatibles et reporting pret pour audit."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].content",
          "englishWordCount": 536,
          "excerpt": "# Error taxonomy: recoverable vs fatal Rust encourages explicit error modeling, but teams still produce weak error contracts when they rely on ad hoc strings or inconsistent wrappers. In Solana et Anchor-adjacent systems..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[1].content",
          "englishWordCount": 513,
          "excerpt": "# Result<T, E> patterns, ? operator, et context Result-based control flow is one of Rust's strongest tools pour building robust services et on-chain-adjacent clients. The key is not merely using Result, but designing err..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].content",
          "englishWordCount": 452,
          "excerpt": "# Explorer: invariant decision tree An invariant decision tree helps teams reason about guard ordering et failure priority. Not every invariant should be checked in arbitrary order. Early checks should prevent expensive ..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement guard helpers, evidence-chain generation, et stable audit reporting pour reliability et incident response."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.description",
          "englishWordCount": 15,
          "excerpt": "Simulez et optimisez le cout compute avec un outillage deterministe Rust-first et une gouvernance performance pilotee par budget."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Rust performance modele mentals, data-structure tradeoffs, et deterministic cost reasoning pour reliable optimization decisions."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].content",
          "englishWordCount": 493,
          "excerpt": "# Performance modele mental: allocations, clones, hashing Rust performance work in Solana ecosystems is mostly about data movement discipline. Teams often chase micro-optimizations while ignoring dominant costs such as r..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].content",
          "englishWordCount": 472,
          "excerpt": "# Data structures: Vec, HashMap, BTreeMap tradeoffs Data structure choice is one of the highest leverage performance decisions in Rust systems. Vec offers compact contiguous storage et predictable iteration speed. HashMa..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].content",
          "englishWordCount": 451,
          "excerpt": "# Explorer: cost model sandbox A cost sandbox lets teams test optimization hypotheses without waiting pour full benchmark infrastructure. Provide operation counts, compute weighted costs, et inspect which buckets dominat..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.description",
          "englishWordCount": 14,
          "excerpt": "Ingenierie de pipeline async Rust-first avec concurrence bornee, reducers replay-safe et reporting operationnel deterministe."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].content",
          "englishWordCount": 501,
          "excerpt": "# Async fundamentals: futures, tasks, channels Rust async systems are built on explicit scheduling rather than implicit thread-per-task models. Futures represent pending work, executors poll futures, et channels coordina..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[1].content",
          "englishWordCount": 446,
          "excerpt": "# Concurrency limits et backpressure Backpressure is not optional in high-volume pipelines. Without it, producer speed can overwhelm reducers, retries, or storage sinks. A resilient conception sets explicit concurrency c..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[2].content",
          "englishWordCount": 465,
          "excerpt": "# Explorer: pipeline graph et concurrency Pipeline graphs help teams communicate stage boundaries, concurrency budgets, et retry behaviors. A graph that shows ingest, dedupe, retry, et snapshot stages avec explicit capac..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implement deterministic scheduling, retries, dedupe/reducer stages, et report exports pour reorg-safe pipeline operations."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.description",
          "englishWordCount": 15,
          "excerpt": "Securite macro/codegen en Rust enseignee via parser deterministe et outillage de generation de checks avec sorties audit-friendly."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].content",
          "englishWordCount": 489,
          "excerpt": "# Macro modele mental: declarative vs procedural Rust macros come in two broad forms: declarative macros pour pattern-based expansion et procedural macros pour syntax-aware transformation. Anchor relies heavily on macro-..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].content",
          "englishWordCount": 455,
          "excerpt": "# Safety through codegen: constraint checks Constraint codegen converts compact declarations into explicit runtime guards. Typical constraints include signer presence, compte ownership, has-one relations, et mutability r..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].content",
          "englishWordCount": 451,
          "excerpt": "# Explorer: constraint builder to generated checks A constraint builder explorer helps engineers see how DSL choices affect generated code et runtime safety outcomes. Input one attribute line, observe parsed AST, generat..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Parse DSL constraints, generate checks, run deterministic evaluations, et publish stable safety reports."
        },
        {
          "path": "courses.anchor-upgrades-migrations.description",
          "englishWordCount": 18,
          "excerpt": "Concevez des workflows de release Anchor surs pour la production avec planification de migration deterministe, gates d upgrade, playbooks de rollback et preuves de readiness."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Authority lifecycle, compte versioning strategy, et deterministic upgrade risk modeling pour Anchor releases."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].content",
          "englishWordCount": 552,
          "excerpt": "# Upgrade authority lifecycle in Anchor programs Anchor makes instruction development easier, but upgrade safety still depends on disciplined control of program authority. In production Solana systems, most upgrade incid..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[1].content",
          "englishWordCount": 504,
          "excerpt": "# Compte versioning et migration strategy Solana comptes are long-lived state containers, so program upgrades must respect historical data. In Anchor, adding or changing compte fields can be safe, risky, or catastrophic ..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].content",
          "englishWordCount": 453,
          "excerpt": "# Explorer: upgrade risk matrix A useful upgrade explorer should show cause-et-effect between release inputs et safety outcomes. If a flag changes, engineers should immediately see how severity et readiness changes. This..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Safety validation gates, rollback planning, et deterministic readiness artifacts pour controlled migration execution."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].content",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic blocking issue checks pour authority, artifact hash, et dry-run status."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].content",
          "englishWordCount": 450,
          "excerpt": "# Rollback strategy et incident playbooks Even strong upgrade plans can encounter surprises: incompatible downstream clients, unexpected compte edge cases, or release pipeline mistakes. Teams that recover quickly are the..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].content",
          "englishWordCount": 14,
          "excerpt": "Produce the final deterministic checkpoint artifact avec release tag, readiness flag, et migration batch count."
        },
        {
          "path": "courses.solana-reliability.description",
          "englishWordCount": 19,
          "excerpt": "Ingenierie de fiabilite orientee production pour systemes Solana: tolerance aux pannes, retries, deadlines, circuit breakers et degradation progressive avec resultats mesurables."
        },
        {
          "path": "courses.solana-reliability.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Implement fault-tolerance building blocks avec clear failure classification, retry boundaries, et deterministic recovery behavior."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[0].content",
          "englishWordCount": 221,
          "excerpt": "Fault tolerance in Solana systems is not just about catching errors. It is about deciding which failures are safe to retry, which should fail fast, et how to preserve user trust while doing both. A pratique reliability m..."
        },
        {
          "path": "courses.solana-reliability.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Build resilience mechanisms (circuit breakers, bulkheads, et rate controls) that protect core user flows during provider instability."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[0].content",
          "englishWordCount": 187,
          "excerpt": "Resilience patterns are controls that prevent localized failures from becoming system-wide incidents. On Solana integrations, they are especially important because provider health can change quickly under bursty network ..."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].content",
          "englishWordCount": 13,
          "excerpt": "Implement a circuit breaker pattern that opens after consecutive failures et closes after a recovery period."
        },
        {
          "path": "courses.solana-testing-strategies.description",
          "englishWordCount": 19,
          "excerpt": "Strategie de test complete et orientee production pour Solana: tests unitaires deterministes, tests d integration realistes, fuzz/property testing et reporting de confiance release."
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Build deterministic unit et integration tests layers avec clear ownership of invariants, fixtures, et failure diagnostics."
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[0].content",
          "englishWordCount": 160,
          "excerpt": "Tests Solana systems effectively requires layered confidence, not one giant test suite. Unit tests validate pure logic: math, state transitions, et invariant checks. They should be fast, deterministic, et run on every ch..."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Use fuzzing, property-based tests, et mutation-style checks to expose edge-case failures before release."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[0].content",
          "englishWordCount": 156,
          "excerpt": "Avance tests techniques uncover failures that example-based tests rarely find. Fuzzing explores broad random input space to trigger parser edge cases, boundary overflows, et unexpected state combinations. It is especiall..."
        },
        {
          "path": "courses.solana-program-optimization.description",
          "englishWordCount": 18,
          "excerpt": "Concevez des performances Solana de niveau production: compute budgeting, efficacite des layouts de comptes, compromis memoire/rent et workflows d optimisation deterministes."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Optimize compute-heavy paths avec explicit CU budgets, operation-level profiling, et predictable performance tradeoffs."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Compute units are the hard resource budget that shapes what your Solana program can do in a single transaction. Performance optimization starts by treating CU usage as a contract, not an afterthought. A reliable optimiza..."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Conception memory/storage-efficient compte layouts avec rent-aware sizing, serialization discipline, et safe migration planning."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[0].content",
          "englishWordCount": 96,
          "excerpt": "Compte data optimization is both a cost et correctness discipline. Poor layouts increase rent, slow parsing, et make migrations fragile. Conception principles: - Keep hot fields compact et easy to parse. - Use fixed-size..."
        },
        {
          "path": "courses.solana-tokenomics-design.description",
          "englishWordCount": 17,
          "excerpt": "Concevez des economies de token Solana robustes avec discipline de distribution, securite de vesting, incentives de staking et mecaniques de gouvernance defendables operationnellement."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Model token allocation et vesting systems avec explicit fairness, unlock predictability, et deterministic accounting rules."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[0].content",
          "englishWordCount": 93,
          "excerpt": "Token distribution is a securite et credibility decision, not just a spreadsheet exercise. Allocation et vesting rules shape long-term trust in the protocol. A strong distribution model answers: - who receives tokens et ..."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Conception staking et gouvernance mechanics avec clear incentive alignment, anti-manipulation constraints, et measurable participation health."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[0].content",
          "englishWordCount": 93,
          "excerpt": "Staking et gouvernance systems must balance participation incentives avec manipulation resistance. Rewarding lock behavior is useful, but poorly tuned models can over-concentrate influence. Core conception questions: 1) ..."
        },
        {
          "path": "courses.solana-defi-primitives.description",
          "englishWordCount": 20,
          "excerpt": "Construisez des fondations DeFi pratiques sur Solana: mecaniques AMM, comptabilite de liquidite, primitives de lending et patterns de composition surs face aux flash loans."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Implement AMM et liquidity primitives avec deterministic math, slippage-aware outputs, et LP accounting correctness."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[0].content",
          "englishWordCount": 96,
          "excerpt": "AMM fundamentals are simple in formula but subtle in implementation quality. The invariant math must be deterministic, fee handling explicit, et rounding behavior consistent across paths. Pour constant-product pools, rou..."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Model lending et flash-loan flows avec collateral safety, utilization-aware pricing, et strict repayment invariants."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[0].content",
          "englishWordCount": 85,
          "excerpt": "Lending primitives et flash-loan logic are powerful but unforgiving. Safety depends on strict collateral valuation, clear LTV/threshold rules, et deterministic repayment checks. A pratique lending model should define: - ..."
        },
        {
          "path": "courses.solana-nft-standards.description",
          "englishWordCount": 17,
          "excerpt": "Implementez des NFTs Solana avec standards prets production: integrite metadata, discipline de collection et comportements avances programmables/non transferables."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build core NFT functionality avec standards-compliant metadata, collection verification, et deterministic asset-state handling."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[0].content",
          "englishWordCount": 78,
          "excerpt": "NFT architecture on Solana combines token mechanics avec metadata et collection semantics. A correct implementation requires more than minting a token avec supply one. Core components include: - mint/state ownership corr..."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implement avance NFT behaviors (soulbound et programmable flows) avec explicit policy controls et safe update semantics."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[0].content",
          "englishWordCount": 72,
          "excerpt": "Avance NFT features introduce policy complexity that must be explicit. Soulbound behavior, programmable restrictions, et dynamic metadata updates all expand failure surface. Pour soulbound models, non-transferability mus..."
        },
        {
          "path": "courses.solana-cpi-patterns.description",
          "englishWordCount": 18,
          "excerpt": "Maitrisez la composition CPI sur Solana avec validation de comptes sure, discipline des signers PDA et patterns deterministes d orchestration multi-programmes."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build CPI fundamentals avec strict compte/signer checks, ownership validation, et safe PDA signing boundaries."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[0].content",
          "englishWordCount": 86,
          "excerpt": "Invocation Inter-Programme (CPI) is where Solana composability becomes pratique et where many securite failures appear. The caller controls compte lists, so every CPI boundary must be treated as untrusted input. Safe CPI..."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Compose avance multi-program flows avec atomicity awareness, consistency checks, et deterministic failure handling."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[0].content",
          "englishWordCount": 88,
          "excerpt": "Multi-program composition introduces sequencing et consistency risk. Even when each CPI call is correct in isolation, combined flows can violate business invariants if ordering or rollback assumptions are weak. Robust co..."
        },
        {
          "path": "courses.solana-mev-strategies.description",
          "englishWordCount": 20,
          "excerpt": "Ingenierie d ordonnancement de transactions orientee production sur Solana: routage conscient du MEV, strategie de bundles, modelisation liquidation/arbitrage et controles d execution protecteurs pour l utilisateur."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Understand MEV mechanics et transaction ordering realities, then model opportunities et risks avec deterministic safety-aware policies."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[0].content",
          "englishWordCount": 162,
          "excerpt": "Maximal Extractable Value (MEV) on Solana is fundamentally about transaction ordering under limited blockspace. Whether you are building trading tools, liquidation infrastructure, or user-facing apps, you need a realisti..."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Conception avance ordering/bundle strategies avec explicit risk controls, failure handling, et user-impact guardrails."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[0].content",
          "englishWordCount": 123,
          "excerpt": "Avance transaction-ordering strategies require disciplined orchestration, not just faster opportunity scans. Bundle-oriented execution is valuable because it can express dependency sets et all-or-nothing intent, but bund..."
        },
        {
          "path": "courses.solana-deployment-cicd.description",
          "englishWordCount": 18,
          "excerpt": "Ingenierie de deploiement production pour programmes Solana: strategie d environnements, release gating, controles qualite CI/CD et workflows operationnels safe pour les upgrades."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Model environment-specific deploiement behavior avec deterministic configs, artifact checks, et release preflight validation."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[0].content",
          "englishWordCount": 132,
          "excerpt": "Solana deploiement is not one command; it is a release system avec environment-specific risk. Localnet, devnet, et mainnet each serve different validation goals, et production quality depends on using them intentionally...."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Build CI/CD pipelines that enforce build/test/securite gates, compatibility checks, et controlled rollout/rollback evidence."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[0].content",
          "englishWordCount": 116,
          "excerpt": "CI/CD pour Solana should enforce release quality, not just automate command execution. A pratique pipeline includes staged gates: 1) static quality gate (lint/type/securite checks), 2) deterministic unit/integration test..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.description",
          "englishWordCount": 19,
          "excerpt": "Construisez des integrations cross-chain plus sures pour Solana avec messagerie style Wormhole, verification d attestations et controles deterministes de l etat bridge."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].content",
          "englishWordCount": 133,
          "excerpt": "Cross-chain messaging is a trust-boundary problem before it is a transport problem. In Wormhole-style systems, messages are observed, attested, et consumed across different chain environments, each avec independent failu..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement asset-bridging patterns avec strict supply/accounting invariants, replay protection, et reconciliation workflows."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Token bridging requires strict supply et state invariants. Lock-et-mint et burn-et-mint models both rely on one central rule: represented supply across chains must remain coherent. Critical controls include: - single-con..."
        },
        {
          "path": "courses.solana-oracle-pyth.description",
          "englishWordCount": 19,
          "excerpt": "Integrez les feeds oracle Solana en securite: validation de prix, politique confiance/staleness et aggregation multi-source pour des decisions de protocole resilientes."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand oracle data semantics (price, confidence, staleness) et enforce deterministic validation before business logic."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[0].content",
          "englishWordCount": 110,
          "excerpt": "Oracle integration is a risk-control problem, not a data-fetch problem. Price feeds must be evaluated pour freshness, confidence, et contextual fitness before they drive protocol decisions. A safe oracle validation pipel..."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Conception multi-oracle aggregation et consensus policies that reduce single-source failure risk while remaining explainable et testable."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Multi-oracle aggregation reduces single-point dependency but adds policy complexity. The goal is not to average blindly; it is to produce a robust decision value avec clear confidence in adverse conditions. Common strate..."
        },
        {
          "path": "courses.solana-dao-tooling.description",
          "englishWordCount": 18,
          "excerpt": "Construisez des systemes DAO prets production sur Solana: gouvernance de propositions, integrite du vote, controles de tresorerie et workflows deterministes d execution/reporting."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Implement gouvernance mechanics avec explicit proposal lifecycle rules, voting-power logic, et deterministic state transitions."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[0].content",
          "englishWordCount": 106,
          "excerpt": "DAO gouvernance architecture is a system of enforceable process rules. Proposal creation, voting, et execution must be deterministic, auditable, et resistant to manipulation. A robust gouvernance model defines: 1) propos..."
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Engineer treasury et execution tooling avec policy gates, timelock safeguards, et auditable automation outcomes."
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[0].content",
          "englishWordCount": 106,
          "excerpt": "DAO treasury management is where gouvernance intent becomes real financial action. Treasury tooling must therefore combine flexibility avec strict policy constraints. Core controls include: - spending limits et role-base..."
        },
        {
          "path": "courses.solana-gaming.description",
          "englishWordCount": 21,
          "excerpt": "Construisez des systemes de jeu on-chain prets production sur Solana: modeles d etat efficaces, integrite des tours, controles d equite et economie de progression joueurs scalable."
        },
        {
          "path": "courses.solana-gaming.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Conception game state et turn logic avec deterministic transitions, storage efficiency, et anti-cheat validation boundaries."
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[0].content",
          "englishWordCount": 133,
          "excerpt": "On-chain game conception on Solana is a systems-engineering tradeoff between fairness, responsiveness, et cost. The best designs keep critical rules verifiable while minimizing expensive state writes. Core architecture d..."
        },
        {
          "path": "courses.solana-gaming.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement fairness-oriented randomness et integrity controls that keep gameplay auditable et dispute-resistant."
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Randomness is one of the hardest fairness problems in blockchain games because execution is deterministic. Robust designs avoid naive pseudo-randomness tied directly to manipulable context. Pratique fairness patterns inc..."
        },
        {
          "path": "courses.solana-permanent-storage.description",
          "englishWordCount": 22,
          "excerpt": "Integrez un stockage decentralise permanent avec Solana via des workflows style Arweave: content addressing, integrite des manifests et acces long terme verifiable aux donnees."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand permanent-storage architecture et build deterministic linking between Solana state et external immutable content."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[0].content",
          "englishWordCount": 119,
          "excerpt": "Permanent storage integration is a data durability contract. On Solana, storing full content on-chain is often impractical, so systems rely on immutable external storage references anchored by on-chain metadata. A robust..."
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Work avec manifests, verification pipelines, et cost/performance controls pour reliable long-lived data serving."
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[0].content",
          "englishWordCount": 96,
          "excerpt": "Manifests turn many stored assets into one navigable root, but they introduce their own integrity responsibilities. A manifest is only trustworthy if path mapping et referenced content IDs are validated consistently. Key..."
        },
        {
          "path": "courses.solana-staking-economics.description",
          "englishWordCount": 18,
          "excerpt": "Comprenez l economie du staking et des validateurs Solana pour la decision reelle: strategie de delegation, dynamique des rewards, effets de commission et soutenabilite operationnelle."
        },
        {
          "path": "courses.solana-staking-economics.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Apprenez native staking mechanics avec deterministic reward modeling, validateur selection criteria, et delegation risk framing."
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[0].content",
          "englishWordCount": 108,
          "excerpt": "Solana staking economics is an incentives system connecting delegators, validateurs, et network securite. Good delegation decisions require more than chasing headline APY. Delegators should evaluate: 1) validateur perfor..."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Analyze validateur-side economics, operational cost pressure, et incentive alignment pour long-term network health."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Validateur economics balances revenue opportunities against operational costs et reliability obligations. Sustainable validateurs optimize pour long-term trust, not short-term extraction. Revenue sources include inflatio..."
        },
        {
          "path": "courses.solana-account-abstraction.description",
          "englishWordCount": 18,
          "excerpt": "Implementez des patterns de smart-wallet/abstraction de compte sur Solana avec autorisation programmable, controles de recuperation et validation de transaction orientee policy."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build smart-portefeuille fundamentals including multisig et social-recovery designs avec clear trust et failure boundaries."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Compte abstraction on Solana shifts control from a single key to programmable policy. Smart portefeuilles can enforce richer authorization logic, but policy complexity must be managed carefully. A robust smart-portefeuil..."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement programmable validation policies (limits, allowlists, time/risk rules) avec deterministic enforcement et auditability."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Programmable validation is where smart portefeuilles deliver real value, but it is also where subtle policy bugs appear. Typical controls include spending limits, destination allowlists, time windows, et risk-score gates..."
        },
        {
          "path": "courses.solana-pda-mastery.description",
          "englishWordCount": 21,
          "excerpt": "Maitrisez l ingenierie avancee des PDAs sur Solana: design des schemas de seeds, discipline bump et usage securise des PDAs cross-program a l echelle production."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build strong PDA foundations avec deterministic derivation, canonical seed composition, et collision-resistant namespace strategy."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[0].content",
          "englishWordCount": 113,
          "excerpt": "Adresses Derivees de Programme (PDAs) are deterministic authority et state anchors on Solana. Their power comes from predictable derivation; their risk comes from inconsistent seed discipline. A strong PDA conception sta..."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement avance PDA patterns (nested/counter/stateful) while preserving securite invariants et migration safety."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[0].content",
          "englishWordCount": 102,
          "excerpt": "Avance PDA patterns solve real scaling et composability needs but increase conception complexity. Nested PDAs, counter-based PDAs, et multi-tenant PDA namespaces each require explicit invariants around uniqueness, lifecy..."
        },
        {
          "path": "courses.solana-economics.description",
          "englishWordCount": 18,
          "excerpt": "Analysez les dynamiques economiques Solana en contexte production: interaction inflation/fee-burn, flux de staking, mouvements de supply et compromis de soutenabilite protocole."
        },
        {
          "path": "courses.solana-economics.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand Solana macro token economics (inflation, burn, rewards, fees) avec deterministic scenario modeling."
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[0].content",
          "englishWordCount": 112,
          "excerpt": "Solana economics is the interaction of issuance, burn, staking rewards, et usage demand. Sustainable protocol decisions require understanding these flows as a system, not isolated metrics. Core mechanisms include: 1) inf..."
        },
        {
          "path": "courses.solana-economics.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Model token flow dynamics et sustainability signals using supply categories, unlock events, et behavior-driven liquidity effects."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[0].content",
          "englishWordCount": 115,
          "excerpt": "Token flow analysis turns abstract economics into operational insight. The key is to track where tokens are (staked, circulating, locked, treasury, pending unlock) et how they move over time. Useful flow metrics include:..."
        }
      ],
      "totals": {
        "exactEnglishCount": 931,
        "englishLikeCount": 454
      }
    },
    {
      "locale": "it",
      "exactEnglishMatches": [
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].prompt",
          "text": "Why does Solana care about read/write account sets?"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].options[0]",
          "text": "To calculate NFT metadata size"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What does the `owner` field mean on an account?"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "It is the user who paid the creation fee forever"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[0].options[1]",
          "text": "It is the program authorized to modify account data"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "What does `executable: true` indicate?"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].options[1]",
          "text": "The account stores runnable program bytecode"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].options[2]",
          "text": "The account can hold any SPL token mint directly"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].options[1]",
          "text": "Token balances are program-specific state managed by the token program"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "This is your active signer public key."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "Pattern only; actual value depends on wallet funding."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[1]",
          "text": "Convert SOL to lamports using 1_000_000_000 multiplier."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "What makes a program account executable?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[0].options[0]",
          "text": "It has a wallet signature on every slot"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[0].options[2]",
          "text": "It owns at least one token account"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Because RPC nodes hide account indexes from programs"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[0]",
          "text": "A client-only simulation mode"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[1]",
          "text": "Calling one on-chain program from another on-chain program"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].prompt",
          "text": "Why are PDAs useful?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].options[0]",
          "text": "They let programs derive deterministic addresses without private keys"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].options[1]",
          "text": "They avoid all account rent costs"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].options[0]",
          "text": "Any wallet holding SOL"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].options[1]",
          "text": "The runtime on behalf of the program when invoke_signed seeds match"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].prompt",
          "text": "What happens if you change a seed?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[0]",
          "text": "The PDA stays the same but bump changes"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[2]",
          "text": "You derive a different PDA address"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].explanation",
          "text": "Seed bytes are part of the hash input, so any change yields a different derived address."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "A compressed NFT ledger entry"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "Why is wallet address != token account?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[2].prompt",
          "text": "What authority controls minting?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[2].options[1]",
          "text": "Mint authority configured on the mint account"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].title",
          "text": "Wallet Manager CLI-sim"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[0]",
          "text": "Parse flags in pairs: --key value."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[2]",
          "text": "Construct JSON object in fixed key order before JSON.stringify."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does Anchor generate automatically from your program definitions?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Automatic PDA funding from devnet faucets"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A JSON interface used by clients/tests/tooling to call your program correctly"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "A private key format used only by on-chain programs"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "The account is owned by the system program"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "The account is always a signer"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is a seeds constraint verifying?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "That the provided account key matches deterministic PDA derivation rules"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "That the account has maximum rent"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "That a token mint has 9 decimals"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].prompt",
          "text": "Why is a PDA considered off-curve?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].options[0]",
          "text": "It is derived to avoid having a corresponding private key"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].explanation",
          "text": "Off-curve means no user-held private key exists; programs authorize via seed proofs."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].prompt",
          "text": "What breaks if you change one PDA seed value?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[1]",
          "text": "Only the bump changes while address stays fixed"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[2]",
          "text": "Nothing changes unless RPC endpoint changes"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].explanation",
          "text": "PDA derivation is seed-sensitive. Any seed change creates a different address namespace."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].title",
          "text": "Initialize Counter PDA (deterministic)"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[0]",
          "text": "Use a deterministic hash-like reducer over programId + authorityPubkey + static seed."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[0]",
          "text": "Represent state as a pure JS structure so increment can be deterministic in tests."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[1]",
          "text": "Return a new state object from applyIncrement; avoid mutating the input object in-place."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the main role of optional integration tests?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Validate network execution paths after deterministic logic is proven"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Replace all unit tests"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Avoid asserting exact outputs"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Integration tests add runtime confidence but should not replace deterministic core checks."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do simulation failures happen even before final send succeeds?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Because the wallet signature always expires immediately"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because fee payer is irrelevant"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "The account that stores all token balances directly"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "The account that sets RPC endpoint"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[0]",
          "text": "Compose the checkpoint from deterministic helper functions to keep output stable."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Where do SPL token balances actually live?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "In the wallet system account lamports field"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why keep raw amounts as integer strings in model code?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because decimals are always 9"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "Show pending overlays first, mutate durable balances only after stronger confirmation"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[2]",
          "text": "Disable activity feed until finalized"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "Optimistic overlays are useful, but confirmed state must remain authoritative."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].options[2]",
          "text": "Because commitment levels require it by protocol"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Phase-specific metrics enable actionable incident diagnosis."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is ordering by (ts, id) preferred over timestamp-only replay?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Stable ordering prevents environment-dependent state divergence."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should happen when the same event id arrives twice?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Idempotency guarantees deterministic behavior under retries."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[0]",
          "text": "Sort by (ts, id) before applying events."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[1]",
          "text": "Deduplicate by event id before snapshot interval checks."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[2]",
          "text": "Build checksum from stable snapshot metadata, not random values."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[0]",
          "text": "Use fixed-scale integers (micro USD) instead of floating point."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[1]",
          "text": "Apply filter -> search -> sort in a deterministic order."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "To reduce CSS size only"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because rate limits require it"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the main risk of generic one-size-fits-all error banners?"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Users cannot distinguish recovery actions across failure classes"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "They always break hydration"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Which metric should drive route selection at execution size?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Deterministic outAmount from full route simulation"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Displayed ticker price only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Lowest hop count only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Route quality is output-at-size, not headline spot labels."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does slippage tolerance directly determine?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "The minOut acceptance bound"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the deterministic minOut formula?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "minOut is a bounded percentage reduction from outAmount."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Why keep per-hop fee breakdowns?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Per-hop fee attribution makes route behavior auditable."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Minimize hop count always"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Choose first enumerated route"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "Why simulate virtual reserves per candidate route?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Virtual simulation avoids shared-state contamination."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].content",
          "text": "# Implement token/pool model + constant-product quote calc Implement deterministic CPMM quoting: - out = (reserveOut * inAfterFee) / (reserveIn + inAfterFee) - fee = floor(inAmount * feeBps / 10000) - impactBps from spot..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].hints[0]",
          "text": "Use inAfterFee = inAmount - floor(inAmount * feeBps / 10000)."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].hints[2]",
          "text": "Keep sorting deterministic to avoid route flicker."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[0]",
          "text": "Use virtual pool copies so fixture reserves are not mutated."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[2]",
          "text": "Return structured errors when pools or route links are invalid."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].prompt",
          "text": "What should happen when quote freshness expires?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].options[2]",
          "text": "Increase slippage automatically without notifying user"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Freshness boundaries should trigger deterministic recomputation."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which failures are not solved by blind retries?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].explanation",
          "text": "Planner errors require input/route changes, not repetition."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[0]",
          "text": "Keep output key order stable: swapPlan first, swapSummary second."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[1]",
          "text": "Path should be deterministic symbols along route hops."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[2]",
          "text": "Include fixtureHash + modelVersion under determinism metadata."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why are account owner checks mandatory before deserializing state?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because owner checks improve rendering speed"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Because owner checks replace signer checks"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Without owner checks, account substitution allows attacker-controlled bytes to be parsed as trusted state."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Only that the vault account is writable"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Only that an amount field exists"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the purpose of trace hashing in an audit workflow?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].options[1]",
          "text": "To replace structured test assertions"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Which sequence represents a valid evidence chain?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "Reproduce -> trace -> impact -> fix -> verify"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[1]",
          "text": "Fix -> reproduce -> trace -> release"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Accepting any PDA-like prefix"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Trusting client-provided bump values"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Deterministic re-derivation closes spoofable PDA substitution paths."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Because most exploitable bugs only appear under malformed or adversarial input"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Because traces are optional without them"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[0]",
          "text": "Compute drained lamports from recipient before/after."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[1]",
          "text": "Include deterministic field ordering in the JSON output."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[2]",
          "text": "The explanation should mention missing signer/owner validation."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].hints[2]",
          "text": "Keep output key order stable."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[1]",
          "text": "Use fixedBlockedExploit to set blocked status."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[2]",
          "text": "Return error code only when blocked is true."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].options[1]",
          "text": "They are interchangeable labels"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Good reports separate damage potential from exploit feasibility."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which recommendation is most actionable?"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[0]",
          "text": "Return stable, minimal checkpoint metadata."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[2]",
          "text": "Preserve scenarioIds order as provided."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why generate an offline deterministic launch pack before devnet/mainnet actions?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should supply checks use integer math instead of floating-point UI values?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "To avoid rounding drift in launch invariants"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Because decimals are always zero"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the primary role of freeze authority?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "text": "Freeze authority governs transfer state at account level, not branding or fee math."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[0]",
          "text": "It can materially change effective fee behavior across transfer sizes"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "It is ignored once mint is initialized"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is a core risk of permanent delegate configuration?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Privilege concentration if authority governance is weak"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].hints[2]",
          "text": "Keep output key order stable so checkpoint tests are reproducible."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].hints[1]",
          "text": "Append extension steps in deterministic order so plan labels are stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[0]",
          "text": "Transfer fee formula: fee = min(maxFee, floor(amount * feeBps / 10000))."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[2]",
          "text": "Fail when distributed amount exceeds initial supply."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is parameter closure required before execution?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Single-source configuration prevents mismatched launch behavior."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the purpose of hard stop launch criteria?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "To halt execution when invariants or authority assumptions fail"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Hard stop rules prevent progressing through unsafe operational states."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[0]",
          "text": "Keep checkpoint JSON key ordering fixed so output is stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[2]",
          "text": "Include determinism metadata (fixtures hash + encoding version) in the final object."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[0]",
          "text": "Add validation before returning the formatted string."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[1]",
          "text": "instructionCount should be treated as a number but returned as text."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].content",
          "text": "# Write a Counter Program Bankrun Test Implement a helper that returns the expected counter value after a sequence of increment operations. This mirrors a deterministic assertion you would use in a Bankrun test. Return t..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[0]",
          "text": "Use Array.reduce to sum increments."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[2]",
          "text": "Convert final number to string before returning."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the primary source of event data on Solana?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Explicit event topics like EVM"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is idempotency important in indexing?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "To prevent duplicate events during replays or forks"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "To improve RPC response times"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the standard size of an SPL Token account?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "How should amount be interpreted from token account data?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "As little-endian u64, then divided by 10^decimals"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[2].hints[0]",
          "text": "SPL Token account layout: mint (32B), owner (32B), amount (8B LE u64)"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[1].note",
          "text": "Inner CPI call at depth 2"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Success bubbles up from inner to outer"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[0]",
          "text": "Parse log entries to identify event types"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[1]",
          "text": "Extract fields using regex patterns"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It provides stable ordering during concurrent writes"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Cursor-based pagination handles concurrent writes without missing or duplicating entries."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What enables indexer recovery after crashes?"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Periodic checkpointing of last processed position"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Re-indexing from genesis on every start"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Caching all data in memory"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Checkpoints allow indexers to resume from the last known good position."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].hints[0]",
          "text": "Aggregate events by wallet address"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].hints[3]",
          "text": "Include metadata like timestamps"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the purpose of SPL Memo in payments?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What should never be included in a memo?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Memos are public on-chain; sensitive data should be hashed or kept off-chain."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[0]",
          "text": "Use base58 alphabet to validate the recipient address format."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[2]",
          "text": "Generate an idempotency key if not provided in the input."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].hints[2]",
          "text": "Key order matters: SOL transfer needs [from, to], SPL transfer needs [source, mint, dest, owner]."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Different key orders produce different signatures"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Canonicalization ensures consistent serialization so signatures match regardless of object construction order."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Initial state after intent creation"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Payment complete, generate receipt"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[0]",
          "text": "HMAC-SHA256: H(key, message) = SHA256((key XOR outer_pad) || SHA256((key XOR inner_pad) || message))"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[1]",
          "text": "Use constant-time comparison to prevent timing attacks on signature verification."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[2]",
          "text": "Verify the timestamp is recent (within 5 minutes) to prevent replay attacks."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a Merkle root commit to?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The tree depth only"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[0]",
          "text": "Start by validating the leaf index is within bounds."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[1]",
          "text": "At each level, find the sibling node (left or right of current)."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[3]",
          "text": "Traverse up to the root, collecting all updated node hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[4]",
          "text": "Use deterministic ordering: left hash comes before right hash."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].prompt",
          "text": "What determines concatenation order during verification?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[0]",
          "text": "The leaf index bits at each level"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[1]",
          "text": "The size of the sibling hashes"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[2]",
          "text": "The tree root hash"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].explanation",
          "text": "Each bit of the leaf index determines if the current hash goes left or right in the concatenation."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[1].explanation",
          "text": "log2(1024) = 10, so proofs contain 10 sibling hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[0]",
          "text": "To generate a proof, collect the sibling hash at each level from leaf to root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[1]",
          "text": "The sibling is at index+1 if current is left, index-1 if current is right."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[3]",
          "text": "Use the same ordering (left || right) when combining hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[4]",
          "text": "The proof is valid if the recomputed root matches the stored root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do old proofs fail after tree updates?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "The root changes when leaves are added/modified"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "The proof format changes"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "The leaf hashes are encrypted"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Adding leaves changes parent hashes up to the root, invalidating previous proofs."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "How can metadata attacks be prevented?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Hash verification against leaf commitments"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Using shorter metadata URIs"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Verifying metadata hashes ensures the off-chain data matches the on-chain commitment."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[0]",
          "text": "Validate the mint request has all required fields (leafIndex, nftId, owner)."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[2]",
          "text": "Insert the leaf by computing hashes up to the root, collecting sibling hashes as proof."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the purpose of a timelock in governance?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What determines voting power in most DAOs?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Token balance at snapshot block"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Voting power is typically proportional to token holdings at a specific snapshot time."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Anyone can trigger execution"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].content",
          "text": "# Challenge: Implement quorum/voting state machine Build a deterministic voting system: - Calculate vote weights from token balances - Check quorum requirements - Determine pass/fail based on thresholds - Handle abstenti..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[1]",
          "text": "Check if totalVoteWeight >= quorumThreshold to determine quorumMet."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[2]",
          "text": "Calculate support percentage as forWeight / (forWeight + againstWeight) when there are non-abstain votes."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does 2-of-3 multisig mean?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].options[0]",
          "text": "2 signatures required from 3 possible signers"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why track approvals on-chain?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[1]",
          "text": "Process actions in order - each action updates the signer's status."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[2]",
          "text": "Track the cumulative approved weight to compare against threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[3]",
          "text": "A proposal is 'approved' when approvedWeight >= threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[4]",
          "text": "A proposal is 'rejected' when no pending signers remain but threshold is not met."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "What is a replay attack in multisig systems?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Sending duplicate approval requests"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "Why verify account ownership?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Prevent account substitution attacks"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].hints[0]",
          "text": "First validate the proposal status is 'approved'."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The network automatically extends the limit"
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].hints[1]",
          "text": "Each account accessed adds 500 compute units."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].hints[2]",
          "text": "Each byte of data adds 10 compute units."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Lower fees, higher throughput"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[0]",
          "text": "Sort fields by size (largest first) to minimize padding gaps."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[1]",
          "text": "Consider if u64 fields can be reduced to u32 based on maxValue."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[2]",
          "text": "Boolean flags can be packed into a single byte as bit flags."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[3]",
          "text": "Calculate bytes saved as originalSize - optimizedSize."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of setComputeUnitPrice?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Enable additional program features"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why request specific compute unit limits?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Enable more account access"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "Optimizing without profiling or evidence of need"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Premature optimization wastes effort on theoretical rather than measured bottlenecks."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[0]",
          "text": "Compute savings by subtracting 'after' from 'before' metrics."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[1]",
          "text": "Use approximate conversion: 1 SOL = $20, 1 SOL = 1,000,000,000 lamports."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why must native SOL be wrapped before swapping?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Native SOL cannot be transferred on Solana"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Solana automatically creates the ATA"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The tokens are sent to the system program"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is 50 basis points of slippage on a 1,000,000 output?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why should minOutAmount use BigInt instead of floating point?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Floating point introduces rounding errors in token amounts"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "BigInt is faster than floating point"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Single-hop direct route"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Total execution cost includes fees + impact"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[0]",
          "text": "Use BigInt arithmetic to avoid floating point errors when computing minOutAmount."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[1]",
          "text": "Slippage in basis points: minOut = outAmount - (outAmount * slippageBps / 10000)."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[3]",
          "text": "The priceImpactPct comes directly from the quote response."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].hints[0]",
          "text": "Define a TRANSITIONS map: each key is a state, each value maps event names to next states."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "They reduce the number of required signatures"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Retryable — get fresh blockhash"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[0]",
          "text": "Use BigInt to sum fee amounts across all route legs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[1]",
          "text": "Effective price = outAmount / inAmount, formatted to 9 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the main advantage of CLMMs over constant product AMMs?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Capital efficiency — LPs concentrate liquidity where trades happen"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "CLMMs allow LPs to allocate capital to specific price ranges, dramatically improving capital efficiency compared to spreading liquidity across all prices."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs use ticks to discretize the price space?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "To reduce the number of tokens in the pool"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs store sqrtPrice instead of price directly?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "It simplifies the AMM math — token amounts become linear in sqrtPrice"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "It uses less storage space on-chain"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Price within range, position is active"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "All SOL was sold as price rose through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Position reactivates when price returns to range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "All USDC was sold as price fell through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[0]",
          "text": "Price at a tick index = 1.0001^tickIndex. Use Math.pow(1.0001, tick)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[1]",
          "text": "Reverse conversion: tick = round(ln(price) / ln(1.0001))."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[2]",
          "text": "sqrtPriceX64 = BigInt(round(sqrt(price) * 2^64)) — Solana CLMM uses Q64.64 fixed-point."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[3]",
          "text": "Tick spacing alignment: floor(tick / spacing) * spacing."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[0]",
          "text": "Convert ticks to prices: lowerPrice = 1.0001^lowerTick, upperPrice = 1.0001^upperTick."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[2]",
          "text": "Fees only accrue when the position is in range. fee = floor(volumePerPeriod * feeRate)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[3]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[4]",
          "text": "Current status is based on the last price in the path relative to the range."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the main tradeoff of using a tight price range?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Lower fees but less impermanent loss"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "More tokens required to open the position"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When should an LP consider a full-range (all ticks) position?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "JavaScript Number cannot safely represent 128-bit integers"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "sqrtPriceX64 is a u128 value that can exceed JavaScript's Number.MAX_SAFE_INTEGER (2^53 - 1). BigInt provides arbitrary precision integer arithmetic."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "They are rejected by the program"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Floor division rounds toward negative infinity: floor(-100/64) = -2, so -100 aligns to -2 * 64 = -128. This is correct CLMM behavior."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[1]",
          "text": "Status is 'in-range' if lowerPrice <= currentPrice <= upperPrice."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[3]",
          "text": "IL formula: lpValue = sqrt(priceRatio) + sqrt(1/priceRatio); compare to holdValue = 2*sqrt(priceRatio)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[4]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimals."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a utilization ratio of 80% mean?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "80% of supplied assets are currently borrowed"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "80% of borrowers have been liquidated"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The pool has 80% of its maximum capacity"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Utilization = totalBorrowed / totalSupply. At 80%, four-fifths of all deposited assets are currently lent out to borrowers."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does the reserve factor affect supplier yield?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "It reduces supplier yield by skimming a percentage of borrow interest"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It increases supplier yield by adding protocol subsidies"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "It has no effect on supplier yield"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "The reserve factor takes a cut of borrow interest before distributing the rest to suppliers, reducing their effective APY."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What happens to borrow rates when utilization exceeds the kink?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "They increase steeply according to slope2"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "They remain constant at the kink rate"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "They decrease to attract more borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is the supply rate always lower than the borrow rate?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The protocol subsidizes borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Supply rates are fixed by governance"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Only 20% buffer remaining — consider adding collateral"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[0]",
          "text": "Utilization = totalBorrowed / totalSupply. Handle the zero-supply edge case."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[1]",
          "text": "Below kink: borrowRate = baseRate + (utilization/kink) * slope1."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[2]",
          "text": "Above kink: borrowRate = baseRate + slope1 + ((util - kink)/(1 - kink)) * slope2."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[3]",
          "text": "Supply rate = borrowRate * utilization * (1 - reserveFactor)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[1]",
          "text": "Effective threshold = weighted average of liquidationThreshold by collateral value."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[2]",
          "text": "Health factor = (collateralValue * effectiveThreshold) / borrowValue."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[3]",
          "text": "Max additional borrow = max(0, collateralValue * threshold - currentBorrow)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of the liquidation bonus?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It incentivizes liquidators to repay debt by offering collateral at a discount"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When does bad debt occur in a lending protocol?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "When collateral value is insufficient to cover outstanding debt after liquidation"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "When the reserve factor is set too high"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "When utilization drops below the kink"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "To be conservative — using (price - confidence) prevents over-valuing collateral during uncertainty"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Confidence intervals make prices more accurate"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should a protocol do when all oracle feeds are stale?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "Use the last known price regardless of age"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Estimate the price from on-chain DEX data"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[2]",
          "text": "Track the worst health factor across all scenarios."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[3]",
          "text": "Count how many scenarios result in isLiquidatable: true."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do perpetual futures protocols use a mark price instead of the last-traded price?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Mark price smooths out manipulation by incorporating oracle data, preventing artificial liquidations"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Mark price is cheaper to compute on-chain"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Last-traded price is not available on Solana"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Mark price incorporates the oracle price as a stability anchor. Using last-traded price alone would allow a single large trade to trigger cascading liquidations through price manipulation."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Weighted average: (8 * 20 + 2 * 30) / 10 = (160 + 60) / 10 = $22.00. The entry price shifts toward the new fill price proportional to the additional size."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "When the perpetual mark price is above the oracle (spot) price, who pays funding?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Longs pay shorts — the positive premium makes long positions expensive to hold"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Both sides pay the protocol a fee"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "A 10 SOL-PERP position at $25 entry faces a 0.01% funding rate. What is the per-period payment?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "text": "Funding payment = size * entryPrice * rate = 10 * 25 * 0.0001 = $0.025 per funding interval."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Position snapshot at current mark price"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Long PnL = size * (mark - entry)"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Positive rate: longs pay funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "True return includes funding drag"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[0]",
          "text": "Long PnL = size * (markPrice - entryPrice). Short PnL = size * (entryPrice - markPrice)."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[1]",
          "text": "Notional value = size * markPrice — represents the total position value."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[2]",
          "text": "ROE (return on equity) = unrealizedPnL / margin * 100."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[0]",
          "text": "Funding payment per period = size * entryPrice * fundingRate."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[1]",
          "text": "Longs pay when rate is positive (totalFunding -= payment). Shorts receive."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[2]",
          "text": "Average funding rate = sum(rates) / count."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[3]",
          "text": "Net margin impact = (totalFunding / margin) * 100, as a percentage."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is the maintenance margin rate set above zero?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "What causes a cascading liquidation spiral?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Forced position closes push the price further, triggering more liquidations in a feedback loop"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Too many traders opening positions at the same time"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Oracle prices updating too slowly"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "text": "When liquidation engines close positions by selling into the market, the selling pressure moves the price further against remaining positions, triggering their liquidations too — a self-reinforcing feedback loop."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should position size always be stored as a positive number?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Positive numbers use less storage space"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "A long position has a positive funding rate of 0.01%. What happens to the trader's balance?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The balance decreases — longs pay when the funding rate is positive"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The balance increases — longs receive positive funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Nothing — funding only affects shorts"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Positive funding rate means the perp is trading above spot. Longs pay shorts to discourage the long-heavy imbalance. The long trader's effective margin decreases by the funding payment amount."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[0]",
          "text": "Effective margin = initial margin + unrealized PnL + funding payments."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[1]",
          "text": "Margin ratio = effectiveMargin / notionalValue."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[3]",
          "text": "Generate alerts based on margin ratio vs maintenance margin rate thresholds."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[4]",
          "text": "Sort alerts by severity: CRITICAL > WARNING > INFO."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How is the priority fee calculated in lamports?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "The CU price is denominated in micro-lamports per CU. Dividing by 1,000,000 converts micro-lamports to lamports. The ceiling function ensures rounding up to the nearest lamport."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is setting the CU limit to exactly the simulated value risky?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The runtime does not accept exact values"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Simulation always underreports CU usage by 50%"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Low compute = minimal priority fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Higher compute increases priority cost proportionally"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "High CU + high priority = significant fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[1]",
          "text": "Cap compute unit limit at 1,400,000 (Solana max)."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[2]",
          "text": "Priority fee = ceil(computeUnitLimit * computeUnitPrice / 1_000_000) in lamports."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[3]",
          "text": "Total fee = base fee (5000 lamports) + priority fee."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[4]",
          "text": "Versioned tx needed when unique account keys exceed 35."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].hints[3]",
          "text": "Recommend 'legacy' if fits without LUT, 'use-existing-lut' if LUT helps enough, 'create-new-lut' if still too large."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "When the blockhash has expired or pool state has changed"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Whenever any error occurs"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Only when the user manually clicks retry"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add random jitter to retry delays?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To make the delay shorter on average"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Jitter is required by the Solana protocol"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Without jitter, all clients using the same backoff formula would retry simultaneously, creating thundering herd problems on the RPC infrastructure."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Slippage exceeded -> actionable message"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Balance error -> show exact shortfall"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[1]",
          "text": "Fee estimates: low = 100 microlamports/CU, medium = 1000, high = 10000."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[2]",
          "text": "Retry policy: 3 retries, 500ms base delay, 2x backoff, always refresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[3]",
          "text": "Use the same CU calculation: ceil(totalCU * 1.1) capped at 1,400,000."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What enables persistent dApp-to-wallet communication on Android?"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Foreground services maintaining a session channel"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Deep links passed between applications"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Shared local storage between apps"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why can't iOS maintain persistent wallet sessions like Android?"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "iOS suspends app execution on background transitions, preventing persistent channels"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "iOS uses a different blockchain protocol"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "iOS does not allow arbitrary background processes or persistent inter-app communication. When the user switches apps, the dApp's execution context is suspended."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What should you do before showing any wallet connection UI?"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Detect available connection methods (MWA, deep links, QR)"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Immediately open the default wallet"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "Capability detection ensures you only present connection methods that are actually available on the user's device."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Display a clear message asking the user to switch their wallet's network"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Request sent via MWA session or deep link"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "User decision - timing is unpredictable"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[3]",
          "text": "Generate a requestId from type + payload prefix if not provided."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[0]",
          "text": "Process actions sequentially: each action modifies the session state."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[3]",
          "text": "Expire check clears session if current time >= expiresAt."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "As raw lamports or smallest unit values"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Raw simulation logs from the RPC response"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].title",
          "text": "Retry State Machine Flow"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "User action triggers request construction"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Request sent to wallet via MWA or deep link"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Wallet app may have been closed or crashed"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[0]",
          "text": "Count requests by status: 'signed' = success, 'rejected'/'timeout'/'error' = failure."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[2]",
          "text": "Session duration = sessionEnd - sessionStart in seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "solana:<recipient> (single colon, no slashes)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "solana://<recipient> (double slashes like HTTP)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "pay:<recipient> (custom pay scheme)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "When the amount exceeds 100 SOL"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How does the reference parameter enable payment tracking?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "It creates a webhook that notifies the merchant"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What amount value represents 2.5 USDC in a Solana Pay URL?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "amount=2.5 (human-readable decimal)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "text": "Solana Pay URLs use human-readable decimal amounts. The wallet handles the conversion to raw units based on the token's decimal configuration."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Native SOL transfer — no spl-token parameter"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[0]",
          "text": "Solana Pay URL format: solana:<recipient>?amount=<amount>&spl-token=<mint>&reference=<ref>&label=<label>&message=<msg>"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[1]",
          "text": "Validate recipient: must be 32-44 characters of valid base58."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[2]",
          "text": "Amount must be a positive finite number."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[0]",
          "text": "Track state transitions: pending -> found -> confirmed -> finalized."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[1]",
          "text": "The 'found' event sets the signature. 'confirmation' increments the counter."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[2]",
          "text": "Timeout check expires the reference if still pending after expiryTimeout seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[3]",
          "text": "Record each state change in the history array."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Confirmed is never sufficient — always use finalized"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What should happen when the payment request expires?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Silently restart the polling loop"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Redirect the customer to a different payment method"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Exponential backoff recovers from transient failures"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Never auto-complete mismatched payments"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Track processed references to prevent double fulfillment"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[0]",
          "text": "Generate receiptId from the last 8 chars of reference + timestamp."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[1]",
          "text": "Reconstruct the Solana Pay URL from payment data."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[2]",
          "text": "Currency is 'SPL' if splToken is present, otherwise 'SOL'."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What should happen when auto-connect fails silently on page load?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Show the connect button without an error message"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Display an error toast telling the user to reconnect"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Redirect the user to a wallet installation page"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Auto-connect is a background optimization. If it fails, the user never initiated the action, so showing an error would be confusing. Simply display the default connect button."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why should you show skeleton UI during the connecting phase?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It makes the page load faster"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "It is required by the Solana wallet adapter standard"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How do you reliably detect which Solana cluster an RPC endpoint is connected to?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Ask the wallet adapter which network it is using"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What must happen to cached data when the network changes?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "All cached data must be invalidated because account states differ across clusters"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Only token balances need to be refreshed"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Cached data can be retained since addresses are the same across clusters"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "text": "While account addresses are identical across clusters, the account states (balances, data, existence) are completely different. All cached RPC data must be cleared on network switch."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "User clicks Connect, show loading state"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Wallet approved, session active"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[0]",
          "text": "Define a TRANSITIONS map: each state maps event types to next states."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[2]",
          "text": "Error state stores the error message. Disconnected clears all session data."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[0]",
          "text": "ACCOUNT_CHANGE invalidates entries tagged 'account'."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[2]",
          "text": "DISCONNECT invalidates all non-'global' entries."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[3]",
          "text": "Track invalidation counts per event in the event log."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must cache keys include the network cluster?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "The Solana RPC protocol requires cluster identification"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "The same account address can have completely different state on mainnet vs devnet. Without the network in the key, switching clusters would return stale data from the previous cluster."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What does the stale-while-revalidate pattern do when a cache entry is past its TTL?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Blocks until fresh data is fetched from the RPC"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Primary endpoint responding normally"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Latency spike detected, slot behind tip"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Automatic failover to healthy secondary"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Primary recovered, restoring as default"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[1]",
          "text": "Average connect time = total durationMs from CONNECTED events / count."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[2]",
          "text": "Cache hit rate = hits / (hits + misses) * 100."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[3]",
          "text": "RPC health = healthy checks / total checks * 100."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "signMessage does not produce valid Ed25519 signatures"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does SIWS prevent replay attacks?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "By requiring a unique, server-generated nonce that is consumed after verification"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must nonces be generated server-side rather than client-side?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Client-generated nonces allow attackers to reuse previously valid nonce-signature pairs"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Client-side random number generators are too slow"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What format must the domain field use?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Plain domain name without protocol prefix (e.g., example.com)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Canonical text format that gets signed by the wallet"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Wallet renders structured UI from parsed fields"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[0]",
          "text": "Domain should not include protocol (https://). Strip or reject it."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[2]",
          "text": "Address must be 32-44 characters (Solana base58 public key)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[3]",
          "text": "If no statement is provided, default to 'Sign in to <domain>'."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[1]",
          "text": "issuedAt must be <= currentTime (not in the future)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[2]",
          "text": "expirationTime (if present) must be > currentTime."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should session IDs be random tokens rather than wallet addresses?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Wallet addresses are public, so anyone could forge requests using a known address"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Wallet addresses are publicly known. Using them as session IDs would allow anyone who knows a user's address to impersonate their session. Random tokens ensure only the authenticated client can present a valid session."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What should happen when a user disconnects their wallet from a dApp?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The dApp should invalidate the server-side session (treat it as logout)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "The dApp should reconnect the wallet automatically"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Wallet disconnection signals the user's intent to end the interaction. The dApp should respect this by invalidating the session, preventing confusion about authentication state."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Nonce travels: server -> client -> wallet -> signed output"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Atomic SET NX ensures only one request can consume the nonce"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Replay blocked: nonce was already consumed"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[0]",
          "text": "Track used nonces in a map. If a nonce was already used, it's a replay attempt."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[2]",
          "text": "Use an address set to count unique addresses."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does a wide p90 vs p50 spread usually indicate?"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A volatile fee regime where a guard premium may be needed"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "Floor protects small estimates."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Large payload triggers heap recommendation."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[0].content",
          "text": "Implement a deterministic compute budget planner. No RPC calls; operate only on provided input data."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[0]",
          "text": "Use percentile targeting from sorted synthetic fee samples."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[1]",
          "text": "Apply volatility guard if p90 vs p50 spread exceeds policy threshold."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[2].hints[0]",
          "text": "Map risk score bands to processed/confirmed/finalized UX levels."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].hints[1]",
          "text": "Avoid timestamps or random IDs in output."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[4].hints[1]",
          "text": "Checkpoint report should avoid nondeterministic fields."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do users still expect atomic behavior in multi-tx flows?"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because protocols always guarantee it"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Because wallet adapters hide all failures"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].title",
          "text": "Flow Graph Risk Walkthrough"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "No compensation path after swap failure."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Still verify idempotency on each step."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[0].hints[1]",
          "text": "Emit explicit edges from dependency relationships."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[1].hints[1]",
          "text": "Flag non-idempotent steps because retries can break all-or-nothing guarantees."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].content",
          "text": "Encode deterministic failure handling metadata, including compensation state."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].hints[0]",
          "text": "Generate deterministic idempotency keys from stable inputs."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[3].hints[0]",
          "text": "No real Jito calls. Build deterministic data structures only."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].content",
          "text": "Generate a stable markdown flow safety report checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[0]",
          "text": "Render a stable markdown report as the final checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[1]",
          "text": "Keep the PASS/FAIL status deterministic from issue count."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Slippage is user tolerance; impact is market footprint"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They are identical metrics"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Slippage is a user-configured bound, while impact reflects route liquidity response to trade size."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[1].hints[0]",
          "text": "Clamp recommended BPS to policy bounds."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[2].hints[0]",
          "text": "Teach difference: impact is market footprint, slippage is user tolerance."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[3].hints[0]",
          "text": "Map risk grades to deterministic banner copy."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[4].hints[1]",
          "text": "Do not include timestamps or random IDs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "It reduces RPC cost directly"
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[0].hints[1]",
          "text": "Sort by key so output is deterministic across runs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[1].hints[0]",
          "text": "Apply only confirmed-depth events to state."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[0]",
          "text": "Integrity checks must fail on negative balances."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[1]",
          "text": "Finalized keys must always be a subset of applied keys."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].title",
          "text": "RPC failures in real life: timeouts, 429s, stale nodes"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is slot lag important in endpoint scoring?"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Fast responses can still be wrong if the node is stale"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Slot lag is equivalent to timeout"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Latency alone cannot guarantee freshness of chain state."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Fast but less reliable under pressure."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].title",
          "text": "Explorer: retry/backoff simulator"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].title",
          "text": "RPC Multi-Provider Client Project Journey"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[0].hints[0]",
          "text": "Build a deterministic retry schedule including the first attempt."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[1].hints[1]",
          "text": "Tie-break deterministically by endpoint ID."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[2].hints[0]",
          "text": "Invalidate account-keyed cache entries deterministically."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[2].hints[1]",
          "text": "Use tighter TTL when node lag grows."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].title",
          "text": "Checkpoint: RPC health report export"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].hints[1]",
          "text": "Ensure field order is stable in JSON output."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why does a u8 before u64 often increase account size?"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Alignment inserts padding bytes"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "RPC forces 8-byte packets"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "u64 alignment usually forces padding after smaller fields."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "u32 length + UTF-8 bytes + u8 field"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].title",
          "text": "Account Layout Inspector Project Journey"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[0].hints[1]",
          "text": "Struct total size should be aligned to max field alignment."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].title",
          "text": "Challenge: implement borshEncode/borshDecode helpers"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].hints[0]",
          "text": "Borsh strings are length-prefixed little-endian u32 + UTF-8 bytes."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].title",
          "text": "Challenge: zero-copy vs Borsh tradeoff model"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[0]",
          "text": "Model tradeoffs deterministically: read speed vs schema flexibility."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[1]",
          "text": "Recommendation should be pure function of inputs."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[3].hints[0]",
          "text": "Validate byte length before field parsing."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].title",
          "text": "Checkpoint: stable layout report"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should export stable JSON + markdown."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].title",
          "text": "Error taxonomy: recoverable vs fatal"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why are typed error codes preferred over free-form strings?"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable machine-readable semantics"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "They reduce compile time"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].title",
          "text": "Explorer: invariant decision tree"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].title",
          "text": "Invariant Guard Library Project Journey"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].title",
          "text": "Challenge: implement InvariantError + ensure helpers"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].hints[0]",
          "text": "Return typed error payloads, not raw strings."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[1].title",
          "text": "Challenge: implement deterministic EvidenceChain"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].title",
          "text": "Challenge: deterministic invariant case runner"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].hints[0]",
          "text": "Property-ish deterministic tests can still run as fixed case sets."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].title",
          "text": "Challenge: implement formatReport() stable markdown"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].content",
          "text": "Format a deterministic markdown evidence report."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].title",
          "text": "Checkpoint: invariant audit report"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].content",
          "text": "Export deterministic invariant audit checkpoint artifacts."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should capture deterministic summary fields only."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[1]",
          "text": "No wall-clock timestamps in exported artifact."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why use deterministic cost models before microbenchmarks?"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable regression signals in CI"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They replace all profiling"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Deterministic models make relative regressions easy to catch early."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].title",
          "text": "Data structures: Vec, HashMap, BTreeMap tradeoffs"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].title",
          "text": "Explorer: cost model sandbox"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].title",
          "text": "Compute Budget Profiler (Sim)"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].title",
          "text": "Challenge: implement CostModel::estimate()"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].content",
          "text": "Estimate deterministic operation costs from fixed weighting rules."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].title",
          "text": "Challenge: optimize function metrics"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[0]",
          "text": "Treat optimization as deterministic metric diffs, not runtime benchmarking."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[1]",
          "text": "Clamp reduced metrics at zero."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].title",
          "text": "Challenge: model serialization overhead"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[0]",
          "text": "Show why repeated encode/decode loops are expensive."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[1]",
          "text": "Keep the model deterministic by counting bytes instead of timing."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].content",
          "text": "Generate stable optimization suggestions from deterministic metrics."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[0]",
          "text": "Output suggestions as a stable, sorted list."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[1]",
          "text": "Use threshold-based recommendations to avoid noisy advice."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].title",
          "text": "Checkpoint: stable perf report"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].hints[1]",
          "text": "Use deterministic percentage rounding."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].title",
          "text": "Async fundamentals: futures, tasks, channels"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].title",
          "text": "Reorg-safe Async Pipeline Project Journey"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].title",
          "text": "Challenge: implement Pipeline::run()"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].hints[1]",
          "text": "No real timers; simulate progression by decrementing remaining ticks."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[1].title",
          "text": "Challenge: implement RetryPolicy schedule"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].title",
          "text": "Challenge: idempotency key dedupe"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].content",
          "text": "Deduplicate replay events by deterministic idempotency keys."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].hints[0]",
          "text": "Use idempotency keys to collapse duplicate replay events."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[3].content",
          "text": "Build deterministic snapshot state from simulated event streams."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].title",
          "text": "Checkpoint: pipeline run report"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint output should mirror deterministic pipeline run artifacts."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "It verifies expansion matches policy intent"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].title",
          "text": "Safety through codegen: constraint checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].title",
          "text": "Explorer: constraint builder to generated checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].title",
          "text": "Account Constraint Codegen (Sim)"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].content",
          "text": "Parse mini-DSL constraints into deterministic AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].hints[0]",
          "text": "Parse mini DSL lines into typed AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].content",
          "text": "Generate stable pseudo-code from parsed constraint AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[0]",
          "text": "Generate stable pseudo-code output from AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[1]",
          "text": "One deterministic line per constraint node."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].title",
          "text": "Challenge: deterministic golden-file checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].content",
          "text": "Compare generated check output against deterministic golden strings."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[0]",
          "text": "Golden tests compare generated output strings exactly."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[1]",
          "text": "Keep check output deterministic to make golden tests meaningful."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].content",
          "text": "Execute generated constraints on deterministic sample input."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].hints[0]",
          "text": "Evaluate generated constraints against sample account state."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].hints[1]",
          "text": "Return deterministic failure reasons."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].title",
          "text": "Checkpoint: generated safety report"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].content",
          "text": "Export deterministic markdown safety report from generated checks."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].hints[0]",
          "text": "Render a deterministic markdown report from generated check results."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].title",
          "text": "Upgrade authority lifecycle in Anchor programs"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Compare approved build hash to expected programdata hash policy input"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Rely on signer memory without written report"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is release communication part of upgrade safety?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Because Anchor automatically writes support tickets"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because all upgrades are backward compatible"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "Freeze writes before touching account schema."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].title",
          "text": "Explorer: upgrade risk matrix"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].title",
          "text": "Challenge: implement migration step planner"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].hints[1]",
          "text": "requiresMigration should be true only when toVersion > fromVersion."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].title",
          "text": "Challenge: implement upgrade safety gate checks"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[1]",
          "text": "Return issueCount plus ordered issue code array."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[2]",
          "text": "Keep order stable to make report diffs deterministic."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What should happen first when rollback trigger thresholds are hit?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Continue migration batches to avoid confusion"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Delete all historical reports"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Trigger conditions should map to immediate deterministic response actions."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add deterministic fixtures after an incident?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "To prove policy changes prevent the same failure path"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To increase deploy complexity without benefit"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "To replace all code reviews"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].title",
          "text": "Challenge: build stable upgrade markdown summary"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].hints[2]",
          "text": "Return plain markdown string without trailing spaces."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].title",
          "text": "Checkpoint: upgrade readiness artifact"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[0]",
          "text": "ready is true only when issueCount equals 0."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[1]",
          "text": "Return stable keys in releaseTag, ready, migrationBatches order."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[2]",
          "text": "Checkpoint output should be machine-readable deterministic JSON."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[0]",
          "text": "Use match on the BackoffStrategy enum to handle each case"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[2]",
          "text": "should_retry simply checks if attempt is less than max_attempts"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].content",
          "text": "Implement a deadline management system to enforce time limits on operations."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].hints[0]",
          "text": "Store the absolute expiration timestamp in the Deadline struct"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].content",
          "text": "Implement a fallback mechanism that provides alternative execution paths when primary operations fail."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].hints[1]",
          "text": "Only call fallback if primary returns None"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].hints[1]",
          "text": "record_success should reset everything to Closed state"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[0]",
          "text": "Always refill before checking if consumption is possible"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[2]",
          "text": "Use min() to ensure tokens don't exceed capacity"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].content",
          "text": "Implement an error classification system to determine if errors are retryable."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[1]",
          "text": "should_retry can use matches! macro or match on classify result"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[2]",
          "text": "batch_classify can use iter().map().collect() pattern"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].title",
          "text": "Test Assertion Framework Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].hints[1]",
          "text": "Use format! to create descriptive error messages"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[2].title",
          "text": "Mock Account Generator Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[2].hints[0]",
          "text": "Use vec![0; size] to create zero-filled data of specified size"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].title",
          "text": "Test Scenario Builder Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].hints[1]",
          "text": "Push strings into vectors (use to_string() to convert &str)"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].title",
          "text": "Fuzz Input Generator Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].hints[1]",
          "text": "Generate bytes by taking random % 256"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[2].content",
          "text": "Implement a property verifier that checks invariants hold across operations."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].title",
          "text": "Boundary Value Analyzer Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[1]",
          "text": "Typical value is the midpoint of the range"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[2]",
          "text": "Return all 7 boundary values as test cases"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].content",
          "text": "Implement a compute unit counter to estimate operation costs."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[0]",
          "text": "Loop cost is overhead plus iterations times per-iteration cost"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[2]",
          "text": "Apply safety margin by multiplying budget by the percentage"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].title",
          "text": "Data Structure Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[0]",
          "text": "Use copy_from_slice to write data efficiently"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[1]",
          "text": "Track the highest written position as 'used'"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[2]",
          "text": "Always check bounds before read/write operations"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].title",
          "text": "Batch Operation Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].content",
          "text": "Optimize batch operations to minimize compute units."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].content",
          "text": "Implement a data packer that efficiently packs fields into account data."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[0]",
          "text": "Use to_le_bytes() to convert integers to bytes"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[1]",
          "text": "Use from_le_bytes() to convert bytes back to integers"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[2]",
          "text": "Alignment formula: if remainder, add (alignment - remainder)"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[0]",
          "text": "Annual rent is data size times lamports per byte per year"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[1]",
          "text": "Exemption threshold is annual rent times threshold years"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[2]",
          "text": "Check if balance is greater than or equal to minimum"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].title",
          "text": "Zero-Copy Deserializer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[0]",
          "text": "Use copy_from_slice to read fixed-size data into stack arrays"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[2]",
          "text": "Always advance offset after reading"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].title",
          "text": "Vesting Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[0]",
          "text": "Use saturating_sub to avoid underflow when calculating elapsed time"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[2]",
          "text": "Releasable is simply vested minus already released"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].title",
          "text": "Token Allocation Distributor Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[0]",
          "text": "Use iter().map().sum() to calculate total percentage"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[2]",
          "text": "Use find() to locate allocation by recipient"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].title",
          "text": "Release Schedule Generator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].hints[0]",
          "text": "Divide duration by intervals to get interval duration"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[0]",
          "text": "Use compound interest formula: A = P(1 + r/n)^(nt)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[1]",
          "text": "Convert basis points to decimal by dividing by 10000"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[0]",
          "text": "If delegated_to is Some, voting power is 0 (they gave it away)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[1]",
          "text": "Use filter to find voters who delegated to a specific address"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[2]",
          "text": "Sum staked amounts to calculate delegated power"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].title",
          "text": "Proposal Threshold Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].hints[0]",
          "text": "Convert basis points to amount: (supply * bps) / 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[1].title",
          "text": "Constant Product AMM Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].title",
          "text": "Liquidity Provider Calculator Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].hints[2]",
          "text": "Rewards are proportional to LP token holdings"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].content",
          "text": "Implement a time-weighted average price oracle."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[0]",
          "text": "Use retain() to filter out old observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[1]",
          "text": "Calculate duration between consecutive observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[2]",
          "text": "TWAP is weighted sum divided by total duration"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[0]",
          "text": "Max borrow is collateral value times LTV ratio"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[1]",
          "text": "Position is liquidatable when borrowed exceeds threshold * value"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[2]",
          "text": "Health factor shows how close to liquidation (higher is safer)"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].title",
          "text": "Interest Rate Model Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].content",
          "text": "Implement a utilization-based interest rate model."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].hints[0]",
          "text": "Utilization is borrowed divided by supplied"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].content",
          "text": "Implement flash loan validation logic."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[0]",
          "text": "Fee is amount times fee_bps divided by 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[1]",
          "text": "Total repay is principal plus fee"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[1].title",
          "text": "NFT Metadata Parser Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[2].hints[2]",
          "text": "Only verify if collection is complete"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].title",
          "text": "Attribute Rarity Calculator Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].content",
          "text": "Calculate NFT attribute rarity scores."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[0]",
          "text": "Rarity percentage is (count / total) * 100"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[1]",
          "text": "Rarity score is inverse of rarity (1 / rarity)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[1].hints[2]",
          "text": "Use any() to check if address is in restrictions list"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].title",
          "text": "Dynamic NFT Updater Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].content",
          "text": "Implement dynamic NFT attributes that can evolve over time."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[1]",
          "text": "Update last_updated timestamp after successful update"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[2]",
          "text": "Time until update is max(0, next_update - current_time)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[3].hints[2]",
          "text": "Filter equipped items by matching type in items list"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[1].hints[2]",
          "text": "Privilege extension: if caller is signer, child can sign too"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[0]",
          "text": "Convert string seeds to bytes using as_bytes()"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[1]",
          "text": "Simulate PDA finding by trying different bump values"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[0]",
          "text": "Use HashMap insert to register handlers"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[1]",
          "text": "Route by looking up instruction_type in handlers map"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].title",
          "text": "Atomic Swap Orchestrator Challenge"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].content",
          "text": "Implement an atomic swap across multiple programs."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].hints[1]",
          "text": "Atomicity requires output_token of step N equals input_token of step N+1"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[2].content",
          "text": "Validate state consistency across multiple CPI calls."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[0]",
          "text": "Push permission into vector to register"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[2]",
          "text": "Use retain() to remove caller from allowed list"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].title",
          "text": "Arbitrage Opportunity Detector Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].content",
          "text": "Detect arbitrage opportunities across DEXes."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[1]",
          "text": "Profit percent is (sell - buy) / buy * 100"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[2]",
          "text": "Use max_by to find best opportunity"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].title",
          "text": "Liquidation Opportunity Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[0]",
          "text": "Position is liquidatable when borrowed > threshold * collateral_value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[2]",
          "text": "Liquidation profit is bonus percentage of collateral value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].title",
          "text": "Priority Fee Calculator Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[0]",
          "text": "Urgency factor scales the base fee"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[1]",
          "text": "Execution probability decreases as more fees are higher"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[0]",
          "text": "Tip is percentage of total profit"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[1]",
          "text": "Bundle is profitable if profit exceeds tip"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].title",
          "text": "Multi-Hop Arbitrage Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].content",
          "text": "Find multi-hop arbitrage paths across token pairs."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[1]",
          "text": "Two-hop arbitrage goes A -> B -> A through different pools"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[2]",
          "text": "Profit is final output minus initial input"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].title",
          "text": "MEV Simulation Engine Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].content",
          "text": "Simulate MEV extraction to estimate profitability."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].hints[2]",
          "text": "Expected value weights profit by success probability"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[0]",
          "text": "Push config into vector to add"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[1]",
          "text": "Use find() to locate config by environment name"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[0]",
          "text": "Compare binary length against MAX_PROGRAM_SIZE"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[2]",
          "text": "Compression ratio shows percentage size reduction"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].title",
          "text": "Upgrade Authority Manager Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[0]",
          "text": "Push metadata into vector to register"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[1]",
          "text": "can_upgrade checks if authority matches stored authority"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[0]",
          "text": "Track seen stages to enforce ordering constraints"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[2]",
          "text": "Can skip build/test if only documentation files changed"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].title",
          "text": "Version Compatibility Checker Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[1]",
          "text": "Compatibility requires same major, actual >= required"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[2]",
          "text": "Use min_by to find smallest compatible version"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].title",
          "text": "Cross-Chain Messaging Architecture"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].content",
          "text": "Implement VAA (Verified Action Approval) signature verification."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[0]",
          "text": "Check signatures length against MIN_SIGNERS first"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[2]",
          "text": "Quorum is 2/3 of total guardians rounded up"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[0]",
          "text": "Increment sequence before creating message"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[2]",
          "text": "Verify message sequence is within emitted range"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[0]",
          "text": "Use contains() to check if sequence was processed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[1]",
          "text": "Return error if trying to mark already-processed sequence"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[2]",
          "text": "Use retain() to filter out old sequences"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[1].hints[1]",
          "text": "Verify requester matches owner before unlocking"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].title",
          "text": "Wrapped Token Mint Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].hints[1]",
          "text": "Check bounds before minting/burning"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].title",
          "text": "Bridge Rate Limiter Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[0]",
          "text": "Reset window before checking if duration passed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[1]",
          "text": "Only consume if total won't exceed max"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[1].hints[1]",
          "text": "Confidence ratio: conf / |price| < threshold"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[0]",
          "text": "Multiplier formula: smoothing / (period + 1)"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[1]",
          "text": "First EMA equals first price"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[2]",
          "text": "Subsequent EMAs use weighted average formula"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].title",
          "text": "Median Price Calculator Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].content",
          "text": "Calculate median price from multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].hints[2]",
          "text": "Use retain() to filter out outliers"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].content",
          "text": "Implement consensus checking across multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[0]",
          "text": "Check minimum sources first"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[2]",
          "text": "Agreement percent is (agreeing / total) * 100"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].title",
          "text": "Fallback Oracle Manager Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[0]",
          "text": "Store sources in priority order"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[1]",
          "text": "current_source index tracks which is active"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[2]",
          "text": "Fallback if index > 0 (not primary)"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].title",
          "text": "Proposal Lifecycle Manager Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].hints[1]",
          "text": "Voting active only during time window in Active state"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[0]",
          "text": "Delegated voters have 0 voting power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[1]",
          "text": "Quadratic voting uses square root of balance"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[2]",
          "text": "Apply cap after calculating base power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].content",
          "text": "Manage vote delegation between DAO members."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].hints[0]",
          "text": "Remove existing delegation before creating new one"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].title",
          "text": "Treasury Spending Limit Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].hints[1]",
          "text": "Reset period if duration has passed"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[2].hints[2]",
          "text": "Remove operation from list to cancel"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].title",
          "text": "Automated Action Trigger Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[1]",
          "text": "Match on condition type to evaluate"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[2]",
          "text": "Only return non-triggered actions that meet conditions"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[1].hints[1]",
          "text": "Turn complete when all players submitted"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].title",
          "text": "Game State Compressor Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[0]",
          "text": "Use bit shifting to pack x in high 4 bits, y in low 4 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[2]",
          "text": "Health stored as percentage (0-100) fits in 7 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].title",
          "text": "Player Progression Tracker Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[0]",
          "text": "XP formula: base * multiplier^(level-1)"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[1]",
          "text": "Keep leveling up while XP exceeds requirement"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[2]",
          "text": "Check contains() before adding achievement"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[1].hints[1]",
          "text": "Verify by recomputing hash from reveal"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[2].hints[2]",
          "text": "4d6 drop lowest: roll 4, sum all, subtract minimum"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[1]",
          "text": "Generate random number in range [0, total)"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[2]",
          "text": "Find item where cumulative weight exceeds roll"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].title",
          "text": "Storage Cost Estimator Challenge"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].content",
          "text": "Estimate Arweave storage costs based on data size."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].hints[0]",
          "text": "Calculate winston cost then convert to USD"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[3].hints[0]",
          "text": "Sort items by priority before bundling"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[0]",
          "text": "Validate tx_id length before adding"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[1]",
          "text": "Resolve in order: exact, index, fallback"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[0]",
          "text": "Push item to vector to add"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[1]",
          "text": "Filter items where any tag matches"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].title",
          "text": "Staking Rewards Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].hints[0]",
          "text": "Apply commission as (1 - commission) multiplier"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[2].hints[0]",
          "text": "Weight factors: commission 40%, uptime 40%, skip rate 20%"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[0]",
          "text": "Target is total divided by count, clamped to min/max"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[2]",
          "text": "Check all allocations within tolerance percentage"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[1].hints[0]",
          "text": "Sum all cost components"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[2].title",
          "text": "Epoch Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].title",
          "text": "Stake Account Manager Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[0]",
          "text": "Only inactive stakes can be activated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[1]",
          "text": "Only active stakes can be deactivated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[2]",
          "text": "Fully active after warmup_epochs from activation"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[1].title",
          "text": "Multi-Signature Wallet Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[1].content",
          "text": "Implement M-of-N multi-signature wallet."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[1].hints[0]",
          "text": "Use contains() to check ownership"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[2].hints[1]",
          "text": "Check guardian status before approving"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].title",
          "text": "Session Key Manager Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[0]",
          "text": "Valid if current time before expiration"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[2]",
          "text": "Remaining is max minus used"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].title",
          "text": "Spending Limit Enforcer Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[0]",
          "text": "Reset counters before checking"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[1]",
          "text": "Check all three limits: per-tx, daily, weekly"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[2]",
          "text": "Reset daily if new day, weekly if 7+ days passed"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[2].hints[1]",
          "text": "Check contains() before adding"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[3].title",
          "text": "Time Lock Enforcer Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[0]",
          "text": "Try bumps from 255 down to 0"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[2]",
          "text": "Check if derived address matches expected"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[2].hints[2]",
          "text": "Collect into Vec<Vec<u8>>"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[3].hints[1]",
          "text": "Signer seeds include all seeds plus bump"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].title",
          "text": "Nested PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].content",
          "text": "Generate PDAs derived from other PDA addresses."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].hints[0]",
          "text": "Include parent address in child seeds"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].title",
          "text": "Counter PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].content",
          "text": "Generate unique PDAs using incrementing counters."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[0]",
          "text": "Increment counter after each generation"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[2]",
          "text": "Batch generation calls generate_next multiple times"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].title",
          "text": "PDA Collision Detector Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[0]",
          "text": "Check if seeds match any existing entry"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[1]",
          "text": "Return error if collision detected"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[1]",
          "text": "Compound inflation year over year"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[2]",
          "text": "APY is inflation divided by staked percentage"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].title",
          "text": "Fee Burn Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].hints[1]",
          "text": "Burn is percentage of total fee"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].title",
          "text": "Rent Economics Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[0]",
          "text": "Annual rent is bytes times rate"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[1]",
          "text": "Exemption is annual times threshold years"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[2]",
          "text": "Rent due is annual times period"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].title",
          "text": "Supply Flow Tracker Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[0]",
          "text": "Total excludes burned tokens"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[1]",
          "text": "Apply flow by subtracting from source, adding to destination"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[2]",
          "text": "Net flow is inflow minus outflow"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].title",
          "text": "Vesting Schedule Impact Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].content",
          "text": "Calculate token unlock impact on supply."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[0]",
          "text": "0 before cliff, linear after, full at end"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[1]",
          "text": "Monthly unlock is difference between consecutive months"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[2]",
          "text": "Check multiple months to find peak"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].title",
          "text": "Protocol Sustainability Score Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[0]",
          "text": "Net issuance is inflation minus burn"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[1]",
          "text": "Burn ratio is burn divided by inflation"
        }
      ],
      "englishLikeMatches": [
        {
          "path": "courses.solana-fundamentals.description",
          "englishWordCount": 20,
          "excerpt": "Introduzione di livello production per principianti che vogliono modelli mentali Solana chiari, debugging delle transazioni piu solido e workflow wallet-manager deterministici."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Core execution model, account semantics, e transazione construction patterns you need before writing programs or complex clients."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].content",
          "englishWordCount": 269,
          "excerpt": "# Solana modello mentale Solana development gets much easier once you stop thinking in terms of \"contracts that own state\" e start thinking in terms of \"programs that operate on account.\" On Solana, the durable state of ..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 17,
          "excerpt": "On Solana, mutable app state is account data. Programs validate e mutate those account but do not hold mutable state internally."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "The runtime checks the message envelope e authorization: fee payer, freshness via blockhash, required signatures, e istruzione payloads."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].explanation",
          "englishWordCount": 12,
          "excerpt": "Read/write sets let the runtime detect conflicts e parallelize independent work deterministically."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].content",
          "englishWordCount": 243,
          "excerpt": "# Account model analisi approfondita Every on-chain object on Solana is an account con a standard envelope. You can reason about any account using a small set of fields: address, lamports, owner, executable flag, e data ..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Executable account are code containers; they are not ordinary mutable data account."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].explanation",
          "englishWordCount": 13,
          "excerpt": "SPL token state uses dedicated account layouts e authorization rules enforced by the token program."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].content",
          "englishWordCount": 303,
          "excerpt": "# Transazioni & istruzioni An istruzione is the smallest executable unit on Solana: `programId + account metas + opaque data bytes`. A transazione wraps one or more istruzioni plus signatures e message metadata. This pro..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].content",
          "englishWordCount": 61,
          "excerpt": "# Build a SOL transfer transazione Implement a deterministic `buildTransferTx(params)` helper in the project file: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` - Use `@solana/web3.js` - Return a trans..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[2]",
          "englishWordCount": 14,
          "excerpt": "Mirror this logic in the real project helper in src/lib/corsi/solana-fundamentals/project/walletManager.ts."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Program behavior, deterministic PDA progettazione, e SPL token modello mentales con pratico safety checks."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].content",
          "englishWordCount": 240,
          "excerpt": "# Programs: what they are (e aren’t) A Solana program is executable account code, not an object that secretly owns mutable storage. Your program receives account from the transazione, verifies constraints, e writes only ..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Account lists are part of the istruzione contract; hidden discovery would break determinism e scheduling assumptions."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].content",
          "englishWordCount": 237,
          "excerpt": "# Indirizzi Derivati dal Programma (PDAs) A Indirizzo Derivato dal Programma (PDA) is a deterministic account address derived from seeds plus a program ID, con one key property: it is intentionally off-curve, so no priva..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "invoke_signed proves seed derivation to runtime, which grants PDA signer semantics per that invocation."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].content",
          "englishWordCount": 230,
          "excerpt": "# SPL Tokens fondamenti SPL Token is Solana’s standard token program family per fungible assets. A token mint account defines token-level configuration: decimals, total supply accounting, e authorities such as mint autho..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "Associated Token Account standardize where fungible token balances are stored per each owner/mint."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "englishWordCount": 13,
          "excerpt": "Wallet can only hold SOL while token balances are separate program-owned account"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "SPL balances are state in token account, not direct fields on wallet system account."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].content",
          "englishWordCount": 53,
          "excerpt": "# Wallet Manager CLI-sim Implement a deterministic CLI parser + command executor in: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` Required behavior: - `address` prints the active pubkey - `build-trans..."
        },
        {
          "path": "courses.anchor-development.description",
          "englishWordCount": 22,
          "excerpt": "Corso orientato al progetto per passare dalle basi all ingegneria Anchor reale: modellazione deterministica degli account, instruction builder, disciplina nei test e UX client affidabile."
        },
        {
          "path": "courses.anchor-development.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Anchor architecture, account constraints, e PDA foundations con explicit ownership of sicurezza-critical decisions."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].content",
          "englishWordCount": 350,
          "excerpt": "# Anchor modello mentale Anchor is best understood as a contract between three layers that must agree on shape: your Rust handlers, generated interface metadata (IDL), e client-side istruzione builders. In raw Solana pro..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].content",
          "englishWordCount": 264,
          "excerpt": "# Account, constraints, e safety Most serious Solana vulnerabilities come from account validation mistakes, not from arithmetic. Anchor’s constraint system exists to turn those checks into declarative, auditable rules. Y..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].content",
          "englishWordCount": 243,
          "excerpt": "# PDAs in Anchor Indirizzi Derivati dal Programma are the backbone of predictable account topology in Anchor applications. A PDA is derived from seed bytes plus program ID e intentionally lives off the ed25519 curve, so ..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].content",
          "englishWordCount": 67,
          "excerpt": "# Initialize Counter PDA (deterministic) Implement deterministic helper functions per a Counter project: - `deriveCounterPda(programId, authorityPubkey)` - `buildInitCounterIx(params)` This lezione validates client-side ..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[1]",
          "englishWordCount": 15,
          "excerpt": "The init istruzione must include four keys in fixed order: counter PDA, authority, payer, system program."
        },
        {
          "path": "courses.anchor-development.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Deterministic istruzione builders, stable state emulation, e test strategy that separates pure logic from network integration."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].content",
          "englishWordCount": 40,
          "excerpt": "# Increment istruzione builder + state layout Implement deterministic increment behavior in pure TypeScript: - Build a reusable state representation per counter data. - Implement `applyIncrement` as a pure transition fun..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].content",
          "englishWordCount": 245,
          "excerpt": "# Test strategy without flakiness A reliable Solana curriculum should teach deterministic engineering first, then optional network integration. Flaky tests are usually caused by external dependencies: RPC latency, faucet..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].content",
          "englishWordCount": 253,
          "excerpt": "# Client composition & UX Once istruzione layouts e PDA logic are deterministic, client integration becomes a composition exercise: wallet adapter per signing, provider/connection per transport, transazione builder per i..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].content",
          "englishWordCount": 49,
          "excerpt": "# Counter project checkpoint Compose the full deterministic flow: 1. Derive counter PDA from authority + program ID. 2. Build init istruzione metadata. 3. Build increment istruzione metadata. 4. Emulate state transitions..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[1]",
          "englishWordCount": 13,
          "excerpt": "Use fixed key order e fixed JSON key order to satisfy strict expected output matching."
        },
        {
          "path": "courses.solana-frontend.description",
          "englishWordCount": 20,
          "excerpt": "Corso orientato al progetto per ingegneri frontend che vogliono dashboard Solana pronte per la produzione: reducer deterministici, pipeline eventi replayabili e UX transazioni affidabile."
        },
        {
          "path": "courses.solana-frontend.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Modella correttamente stato wallet/account, progetta UX del ciclo di vita transazione e applica regole deterministiche per debugging riproducibile."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].content",
          "englishWordCount": 468,
          "excerpt": "# Wallet state + account modello mentale per UI devs Most Solana frontend bugs are not visual bugs. They are model bugs. A dashboard can look polished while silently computing balances from the wrong account class, mixin..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].content",
          "englishWordCount": 355,
          "excerpt": "# Transazione lifecycle per UI: pending/confirmed/finalized, optimistic UI Frontend transazione UX is a state machine problem. Users press one button, but your app traverses multiple phases: intent creation, transazione ..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].content",
          "englishWordCount": 354,
          "excerpt": "# Data correctness: dedupe, ordering, idempotency, correction events Frontend teams frequently assume event streams are perfectly ordered e unique. Production systems rarely behave that way. You can receive duplicate eve..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].content",
          "englishWordCount": 34,
          "excerpt": "# Build core state model + reducer from events Implement a deterministic reducer per dashboard state: - apply event stream transitions per balances e mint metadata - enforce idempotency by event id - support correction m..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Corrections should mark replaced event ids e remove their effects from state transitions."
        },
        {
          "path": "courses.solana-frontend.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Costruisci reducer, snapshot di replay, metriche di query e output dashboard deterministici stabili con dati parziali o ritardati."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].content",
          "englishWordCount": 28,
          "excerpt": "# Implement event stream simulator + replay timeline + snapshots Build deterministic replay tooling: - replay sorted events by (ts, id) - snapshot every N applied events - compute stable checksum per replay output - retu..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].content",
          "englishWordCount": 30,
          "excerpt": "# Implement query layer + computed metrics Implement dashboard query/view logic: - search/filter/sort rows deterministically - compute total e row valueUsd con fixed-scale integer math - expose stable view model per UI r..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].content",
          "englishWordCount": 386,
          "excerpt": "# Production UX: caching, pagination, error banners, skeletons, rate limits After model correctness, frontend quality is mostly about user trust under imperfect conditions. Users do not evaluate your dashboard by clean d..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[3].content",
          "englishWordCount": 27,
          "excerpt": "# Emit stable DashboardSummary from fixtures Compose deterministic checkpoint output: - owner, token count, totalValueUsd - top tokens sorted deterministically - recent activity rows - invariants e determinism metadata (..."
        },
        {
          "path": "courses.defi-solana.description",
          "englishWordCount": 22,
          "excerpt": "Corso avanzato orientato al progetto per ingegneri che costruiscono sistemi di swap: pianificazione offline deterministica in stile Jupiter, ranking delle route, sicurezza minOut e diagnostica riproducibile."
        },
        {
          "path": "courses.defi-solana.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Comprendere matematica CPMM, anatomia del quote e tradeoff di routing deterministico con protezioni utente orientate alla sicurezza."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].content",
          "englishWordCount": 525,
          "excerpt": "# AMM fondamenti on Solana: pools, fees, slippage, e impatto sul prezzo When users click “Swap,” they usually assume there is one objective truth: the current price. In practice, frontend swap systems compute an estimate..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].content",
          "englishWordCount": 390,
          "excerpt": "# Quote anatomy: in/out, fees, minOut, e worst-case execution A production quote is not one number. It is a structured object that must tell users what they send, what they likely receive, how much they pay in fees, e wh..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].content",
          "englishWordCount": 407,
          "excerpt": "# Routing: why two-hop can beat one-hop Users often assume direct pair routes are always best because they are simpler. In fragmented liquidity systems, that assumption fails frequently. A direct SOL -> JUP pool might ha..."
        },
        {
          "path": "courses.defi-solana.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Costruire quoting deterministico, selezione route e controlli minOut, quindi produrre artefatti checkpoint stabili per review riproducibili."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].content",
          "englishWordCount": 29,
          "excerpt": "# Implement route enumeration e best-route selection Implement deterministic route planner: - enumerate one-hop e two-hop candidates - quote each candidate at exact input size - select best route using stable tie-breaker..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].content",
          "englishWordCount": 35,
          "excerpt": "# Implement slippage/minOut, fee breakdown, e safety invariants Implement deterministic safety layer: - apply slippage to compute minOut - simulate route con virtual reserve updates - return structured errors per invalid..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].content",
          "englishWordCount": 404,
          "excerpt": "# Production swap UX: stale quotes, protection, e simulation A deterministic route engine is necessary but not sufficient per production. Users experience DeFi through timing, messaging, e safety affordances. A mathemati..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].content",
          "englishWordCount": 29,
          "excerpt": "# Produce stable SwapPlan + SwapSummary checkpoint Compose deterministic checkpoint artifacts: - build swap plan from selected route quote - include fixtureHash e modelVersion - emit stable summary con path, minOut, fee ..."
        },
        {
          "path": "courses.solana-security.description",
          "englishWordCount": 17,
          "excerpt": "Lab deterministico di vulnerabilita per auditor Solana che richiedono evidenza exploit ripetibile, remediation precisa e artefatti di audit ad alto segnale."
        },
        {
          "path": "courses.solana-security.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Threat modeling centrato sugli account, riproduzione deterministica degli exploit e disciplina dell evidenza per finding di audit credibili."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].content",
          "englishWordCount": 562,
          "excerpt": "# Solana threat model per auditors: account, owners, signers, writable, PDAs Sicurezza work on Solana starts con one non-negotiable fact: istruzione callers choose the account list. Programs do not receive trusted implic..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].content",
          "englishWordCount": 445,
          "excerpt": "# Evidence chain: reproduce, trace, impact, fix, verify Strong sicurezza reports are built on evidence chains, not opinions. In the Solana context, that means moving from a claim such as “missing signer check exists” to ..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].content",
          "englishWordCount": 475,
          "excerpt": "# Common Solana bug classes e mitigations Auditors on Solana repeatedly encounter the same core bug families. The implementation details differ across protocols, but exploit mechanics are surprisingly consistent: identit..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "Sicurezza failures are usually adversarial edge cases, so tests must target those edges directly."
        },
        {
          "path": "courses.solana-security.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Sfruttare, correggere, verificare e produrre artefatti audit-ready con trace deterministiche e conclusioni supportate da invarianti."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].content",
          "englishWordCount": 43,
          "excerpt": "# Break it: exploit missing signer + owner checks Implement a deterministic exploit-proof formatter per signer/owner vulnerabilities. Expected output fields: - scenario - before/after vault balance - before/after recipie..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].content",
          "englishWordCount": 30,
          "excerpt": "# Break it: exploit PDA spoof mismatch Implement a deterministic PDA spoof proof output. You must show: - expected PDA - accepted PDA - mismatch boolean - trace hash This lezione validates evidence generation per derivat..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].content",
          "englishWordCount": 30,
          "excerpt": "# Fix it: validations + invariant suite Implement patch validation output that confirms: - signer check - owner check - PDA check - safe u64 arithmetic - exploit blocked state con error code Keep output deterministic per..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].content",
          "englishWordCount": 455,
          "excerpt": "# Writing audit reports: severity, likelihood, blast radius, remediation A strong audit report is an engineering document, not a narrative essay. It should allow a reader to answer four questions quickly: what failed, ho..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].content",
          "englishWordCount": 29,
          "excerpt": "# Checkpoint: deterministic AuditReport JSON + markdown Create the final deterministic checkpoint payload: - corso + version - scenario IDs - finding count This checkpoint mirrors the final corso artifact produced by the..."
        },
        {
          "path": "courses.token-engineering.description",
          "englishWordCount": 22,
          "excerpt": "Corso orientato al progetto per team che lanciano token Solana reali: pianificazione deterministica Token-2022, design delle authority, simulazione della supply e disciplina operativa di lancio."
        },
        {
          "path": "courses.token-engineering.modules[0].description",
          "englishWordCount": 17,
          "excerpt": "Comprendi primitive token, anatomia delle policy di mint e controlli delle estensioni Token-2022 con framing esplicito di governance e threat model."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].content",
          "englishWordCount": 392,
          "excerpt": "# SPL tokens vs Token-2022: what extensions change Token engineering starts con a clean boundary between base token semantics e configurable policy. Legacy SPL Token gives you a stable fungible primitive: mint metadata, ..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].content",
          "englishWordCount": 365,
          "excerpt": "# Mint anatomy: authorities, decimals, supply, freeze, mint A production token launch succeeds or fails on parameter discipline. The mint account is a compact policy object: it defines decimal precision, minting authorit..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].content",
          "englishWordCount": 360,
          "excerpt": "# Extension safety pitfalls: fee configs, delegate abuse, default account state Token-2022 extensions let teams express policy in a standard token framework, but policy power is exactly where operational failures happen...."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].content",
          "englishWordCount": 35,
          "excerpt": "# Validate token config + derive deterministic addresses offline Implement strict config validation e deterministic pseudo-derivation: - validate decimals, u64 strings, recipient totals, extension fields - derive stable ..."
        },
        {
          "path": "courses.token-engineering.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Costruisci workflow deterministici di validazione, pianificazione e simulazione che producano artefatti di lancio revisionabili e criteri go/no-go chiari."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].content",
          "englishWordCount": 32,
          "excerpt": "# Build Token-2022 initialization istruzione plan Create a deterministic offline initialization plan: - create mint account step - init mint step con decimals - append selected extension steps in stable order - base64 en..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].hints[0]",
          "englishWordCount": 12,
          "excerpt": "Add base steps first: create mint account, then initialize mint con decimals."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].content",
          "englishWordCount": 28,
          "excerpt": "# Build mint-to + transfer-fee math + simulation Implement pure simulation per transfer fees e launch distribution: - fee = min(maxFee, floor(amount * feeBps / 10000)) - aggregate distribution totals deterministically - ..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].content",
          "englishWordCount": 359,
          "excerpt": "# Launch checklist: params, upgrade/authority strategy, airdrop/test plan A successful token launch is an operations exercise as much as a programming task. By the time users see your token in wallet, dozens of choices h..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].content",
          "englishWordCount": 27,
          "excerpt": "# Emit stable LaunchPackSummary Compose full project output as stable JSON: - normalized authorities e extensions - supply totals e optional fee model examples - deterministic plan metadata e invariants - fixtures hash +..."
        },
        {
          "path": "courses.solana-mobile.description",
          "englishWordCount": 19,
          "excerpt": "Costruisci dApp Solana mobile pronte per la produzione con MWA, architettura robusta delle sessioni wallet, UX di firma esplicita e operazioni di distribuzione disciplinate."
        },
        {
          "path": "courses.solana-mobile.modules[0].description",
          "englishWordCount": 17,
          "excerpt": "Protocollo MWA centrale, controllo del ciclo di vita della sessione e pattern resilienti di handoff wallet per app mobile in produzione."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[0].content",
          "englishWordCount": 343,
          "excerpt": "# Mobile Wallet Panoramica Solana Mobile development is built around the Solana Mobile Stack (SMS), a set of standards e tooling designed per secure, high-quality crypto-native mobile experiences. SMS is more than a hard..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[1].content",
          "englishWordCount": 237,
          "excerpt": "# MWA Integration Integrating Mobile Wallet Adapter typically starts con `@solana-mobile/mobile-wallet-adapter` APIs e an interaction pattern built around `transact()`. Within a transazione session, the app can authorize..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].content",
          "englishWordCount": 25,
          "excerpt": "# Build a Mobile Transazione Function Implement a helper that formats a deterministic MWA transazione request summary string. Expected output format: `<cluster>|<payer>|<instructionCount>` Use this exact order e delimite..."
        },
        {
          "path": "courses.solana-mobile.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Pubblicazione, readiness operativa e pratiche UX mobile orientate alla fiducia per la distribuzione di app Solana."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[0].content",
          "englishWordCount": 261,
          "excerpt": "# dApp Store Submission Publishing to the Solana dApp Store requires more than packaging binaries. Teams should treat submission as a product, compliance, e sicurezza review process. A strong submission demonstrates safe..."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[1].content",
          "englishWordCount": 284,
          "excerpt": "# Mobile Best practice Mobile crypto UX requires balancing speed, safety, e trust. Users make high-stakes decisions on small screens, often on unstable networks. Solana mobile apps should therefore optimize per explicitn..."
        },
        {
          "path": "courses.solana-testing.description",
          "englishWordCount": 17,
          "excerpt": "Costruisci sistemi di testing Solana robusti su ambienti locali, simulati e di rete con invarianti di sicurezza esplicite e confidence gate di qualita release."
        },
        {
          "path": "courses.solana-testing.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Strategia di test centrale su livelli unit/integration con workflow deterministici e copertura di casi avversariali."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[0].content",
          "englishWordCount": 313,
          "excerpt": "# Test Approaches Test Solana programs requires multiple layers because failures can occur in logic, account validation, transazione composition, or network behavior. A production test strategy usually combines unit test..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[1].content",
          "englishWordCount": 244,
          "excerpt": "# Bankrun Test Solana Bankrun provides deterministic, high-speed test execution per Solana programs from TypeScript environments. It emulates a local bank-like runtime where transazioni can be processed predictably, acco..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[0].content",
          "englishWordCount": 249,
          "excerpt": "# Fuzzing con Trident Fuzzing explores large input spaces automatically to find bugs that handcrafted tests miss. Per Solana e Anchor programs, Trident-style fuzzing workflows generate randomized istruzione sequences e p..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[1].content",
          "englishWordCount": 220,
          "excerpt": "# Devnet Test Devnet test bridges the gap between deterministic local tests e real-world network conditions. While local validatori e Bankrun are ideal per speed e reproducibility, devnet reveals behavior under real RPC ..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[2].content",
          "englishWordCount": 216,
          "excerpt": "# CI/CD Pipeline per Solana A mature Solana CI/CD pipeline enforces quality gates across code, tests, sicurezza checks, e distribuzione workflows. Per program teams, CI is not just linting Rust e TypeScript; it is about ..."
        },
        {
          "path": "courses.solana-indexing.description",
          "englishWordCount": 17,
          "excerpt": "Costruisci un indexer eventi Solana di livello produzione con decoding deterministico, contratti di ingestion resilienti, recovery a checkpoint e output analytics affidabili."
        },
        {
          "path": "courses.solana-indexing.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Modello eventi, decoding di account token e parsing dei metadati transazione per pipeline di indicizzazione affidabili."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].content",
          "englishWordCount": 318,
          "excerpt": "# Events model: transazioni, logs, e program istruzioni Indexing Solana starts con understanding where data lives e how to extract structured events from raw chain data. Unlike EVM chains where events are explicit log to..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Solana programs emit events via logs e state changes, not explicit event topics."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Idempotent ingestion ensures the same transazione processed twice creates only one event."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].content",
          "englishWordCount": 219,
          "excerpt": "# Token account decoding e SPL layout SPL Token account follow a standardized binary layout that indexers must parse to track balances e mint operations. Understanding this layout enables you to extract meaningful data f..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Standard SPL Token account are 165 bytes, containing mint, owner, amount, e optional fields."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Amounts are stored as little-endian u64 e must be converted using the mint's decimal places."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[2].content",
          "englishWordCount": 52,
          "excerpt": "# Challenge: Decode token account + diff token balances Implement deterministic token account decoding e balance diffing: - Parse a 165-byte SPL Token account layout - Extract mint, owner, e amount fields - Compute balan..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].content",
          "englishWordCount": 240,
          "excerpt": "# Transazione meta parsing: logs, errors, e inner istruzioni Transazione metadata provides the context needed to index complex operations. Understanding how to parse logs, handle errors, e traverse inner istruzioni enabl..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].content",
          "englishWordCount": 44,
          "excerpt": "# Challenge: Index transazioni to normalized events Implement a transazione indexer that produces normalized Event objects: - Parse istruzione logs e identify event types - Extract transfer events con from/to/amount/mint..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].content",
          "englishWordCount": 228,
          "excerpt": "# Pagination, checkpointing, e caching semantics Production indexers must handle large datasets efficiently while maintaining consistency. Pagination, checkpointing, e caching form the backbone of scalable indexing infra..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[2].content",
          "englishWordCount": 213,
          "excerpt": "# Analytics aggregation: per wallet, per token metrics Raw event data becomes valuable through aggregation. Building analytics pipelines enables insights into user behavior, token flows, e protocol usage patterns. Per-wa..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].content",
          "englishWordCount": 50,
          "excerpt": "# Checkpoint: Produce stable JSON analytics summary Implement the final analytics checkpoint that produces a deterministic summary: - Aggregate events into per-wallet e per-token metrics - Generate sorted, stable JSON ou..."
        },
        {
          "path": "courses.solana-payments.description",
          "englishWordCount": 19,
          "excerpt": "Costruisci flussi di pagamento Solana di livello produzione con validazione robusta, idempotenza sicura contro replay, webhook sicuri e ricevute deterministiche per la riconciliazione."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].content",
          "englishWordCount": 264,
          "excerpt": "# Address validation e memo strategies Payment flows on Solana require robust address validation e thoughtful memo strategies. Unlike traditional payment systems con account numbers, Solana uses base58-encoded public key..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[1].content",
          "englishWordCount": 221,
          "excerpt": "# Idempotency keys e replay protection Payment systems must handle network failures gracefully. Idempotency ensures that retrying a failed request produces the same outcome as the original, preventing duplicate charges e..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].content",
          "englishWordCount": 48,
          "excerpt": "# Challenge: Create payment intent con validation Implement a payment intent creator con full validation: - Validate recipient address format (base58, 32 bytes) - Validate amount (positive, within limits) - Generate dete..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[3].content",
          "englishWordCount": 216,
          "excerpt": "# Transazione building e key metadata Building payment transazioni requires careful attention to istruzione construction, account metadata, e program interactions. The goal is creating valid, efficient transazioni that m..."
        },
        {
          "path": "courses.solana-payments.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Costruzione transazione, verifica autenticita webhook e generazione deterministica della ricevuta con gestione chiara degli stati di errore."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].content",
          "englishWordCount": 36,
          "excerpt": "# Challenge: Build transfer transazione Implement a transfer transazione builder: - Build SystemProgram.transfer per SOL transfers - Build TokenProgram.transfer per SPL transfers - Return istruzione bundle con correct ke..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].content",
          "englishWordCount": 187,
          "excerpt": "# Webhook signing e verification Webhooks enable asynchronous payment notifications. Sicurezza requires cryptographic signing so recipients can verify webhook authenticity e detect tampering. Webhook signing uses HMAC-SH..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].content",
          "englishWordCount": 195,
          "excerpt": "# Error state machine e receipt format Payment flows require well-defined state machines to handle the complexity of asynchronous confirmations, failures, e retries. Clear state transitions e receipt formats ensure relia..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].content",
          "englishWordCount": 43,
          "excerpt": "# Challenge: Verify webhook e produce receipt Implement the final payment flow checkpoint: - Verify signed webhook signature (HMAC-SHA256) - Extract payment details from payload - Generate standardized receipt JSON - Inc..."
        },
        {
          "path": "courses.solana-nft-compression.description",
          "englishWordCount": 17,
          "excerpt": "Padroneggia l ingegneria degli NFT compressi su Solana: commitment Merkle, sistemi di proof, modellazione delle collection e controlli di sicurezza di livello produzione."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Costruzione dell albero, hashing foglia, meccanica di inserimento e modello di commitment on-chain/off-chain dietro gli asset compressi."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].content",
          "englishWordCount": 278,
          "excerpt": "# Merkle trees per state compression Compressed NFTs (cNFTs) on Solana use Merkle trees to dramatically reduce storage costs. Understanding Merkle trees is essential per working con compressed NFTs e building compression..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[1].content",
          "englishWordCount": 214,
          "excerpt": "# Leaf hashing conventions e metadata Leaf hashing determines how NFT metadata is committed to the Merkle tree. Understanding these conventions ensures compatibility con compression standards e proper proof generation. L..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].content",
          "englishWordCount": 42,
          "excerpt": "# Challenge: Implement Merkle tree insert + root updates Build a Merkle tree implementation con insertions: - Insert leaves e compute new root - Update parent hashes up the tree - Handle tree growth e depth limits - Retu..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].content",
          "englishWordCount": 227,
          "excerpt": "# Proof generation e path computation Merkle proofs enable verification of leaf inclusion without accessing the entire tree. Understanding proof generation is essential per working con compressed NFTs e building verifica..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Generazione e verifica proof, integrita collection e hardening di sicurezza contro replay e spoof dei metadata."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement proof generation + verifier Build a complete proof system: - Generate proofs from a Merkle tree e leaf index - Verify proofs against a root hash - Handle invalid proofs (wrong siblings, wrong index..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[1].content",
          "englishWordCount": 216,
          "excerpt": "# Collection mints e metadata simulation Compressed NFT collections use a collection mint as the parent NFT, enabling grouping e verification of related assets. Understanding this hierarchy is essential per building coll..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].content",
          "englishWordCount": 254,
          "excerpt": "# Attack surface: invalid proofs e replay Compressed NFTs introduce unique sicurezza considerations. Understanding attack vectors e mitigations is critical per building secure compression-aware applications. Invalid proo..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].content",
          "englishWordCount": 53,
          "excerpt": "# Checkpoint: Simulate mint + verify ownership proof Complete the compression lab checkpoint: - Simulate minting a cNFT (insert leaf, update root) - Generate ownership proof per the minted NFT - Verify the proof against ..."
        },
        {
          "path": "courses.solana-governance-multisig.description",
          "englishWordCount": 17,
          "excerpt": "Costruisci sistemi DAO e tesoreria multisig pronti per la produzione con conteggio voti deterministico, sicurezza timelock e controlli di esecuzione sicuri."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Ciclo di vita delle proposte, meccaniche di voto deterministiche, policy di quorum e sicurezza timelock per una governance DAO credibile."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].content",
          "englishWordCount": 247,
          "excerpt": "# DAO model: proposals, voting, e execution Decentralized governance on Solana follows a proposal-based model where token holders vote on changes e the DAO treasury executes approved decisions. Understanding this flow is..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[1].content",
          "englishWordCount": 185,
          "excerpt": "# Quorum math e vote weight calculation Accurate vote counting is critical per legitimate governance outcomes. Understanding quorum requirements, vote weight calculation, e edge cases ensures fair decision-making. Quorum..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].content",
          "englishWordCount": 169,
          "excerpt": "# Timelock states e execution scheduling Timelocks provide a critical safety layer between governance approval e execution. Understanding timelock states e transitions ensures reliable proposal execution. Timelock states..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Costruzione transazioni multisig, controlli di approvazione, difese anti-replay e pattern sicuri di esecuzione della tesoreria."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].content",
          "englishWordCount": 176,
          "excerpt": "# Multisig transazione building e approvals Multisig wallet provide collective control over treasury funds. Understanding multisig construction, approval flows, e sicurezza patterns is essential per treasury operations. ..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].content",
          "englishWordCount": 34,
          "excerpt": "# Challenge: Implement multisig tx builder + approval rules Build a multisig transazione system: - Create transazioni con istruzioni - Record signer approvals - Enforce threshold requirements - Handle approval revocation..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].content",
          "englishWordCount": 191,
          "excerpt": "# Safe defaults: owner checks e replay guards Governance e multisig systems require robust sicurezza defaults. Understanding common vulnerabilities e their mitigations protects treasury funds. Owner checks validate that ..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].content",
          "englishWordCount": 48,
          "excerpt": "# Challenge: Execute proposal e produce treasury diff Complete the governance simulator checkpoint: - Execute approved proposals con timelock validation - Apply treasury state changes atomically - Generate execution trac..."
        },
        {
          "path": "courses.solana-performance.description",
          "englishWordCount": 19,
          "excerpt": "Padroneggia l ingegneria delle performance Solana con workflow misurabili di ottimizzazione: compute budget, data layout, efficienza di encoding e modellazione deterministica dei costi."
        },
        {
          "path": "courses.solana-performance.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Modello compute, decisioni di layout account/dati e stima costi deterministica per ragionare sulle performance a livello transazione."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].content",
          "englishWordCount": 234,
          "excerpt": "# Compute model: budgets, costs, e limits Solana's compute model enforces deterministic execution limits through compute budgets. Understanding this model is essential per building efficient programs that stay within lim..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[1].content",
          "englishWordCount": 198,
          "excerpt": "# Account layout progettazione e serialization cost Account data layout significantly impacts compute costs. Well-designed layouts minimize serialization overhead e reduce account access costs. Serialization formats affe..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement estimateCost(op) model Build a compute cost estimation system: - Model costs per different operation types - Account per istruzione complexity - Include memory access costs - Return baseline measur..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].content",
          "englishWordCount": 172,
          "excerpt": "# Istruzione data size e encoding optimization Istruzione data size directly impacts transazione cost e throughput. Optimizing encoding reduces fees e increases the operations possible within compute limits. Compact enco..."
        },
        {
          "path": "courses.solana-performance.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Ottimizzazione layout, tuning del compute budget e analisi before/after delle performance con salvaguardie di correttezza."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].content",
          "englishWordCount": 42,
          "excerpt": "# Challenge: Implement optimized layout/codec Optimize an account data layout while preserving semantics: - Reduce data size through compact encoding - Maintain all original functionality - Preserve backward compatibilit..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].content",
          "englishWordCount": 176,
          "excerpt": "# Compute budget istruzione fondamenti Compute budget istruzioni give developers control over resource allocation e transazione prioritization. Understanding these tools enables precise optimization. setComputeUnitLimit ..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "Specific limits optimize costs - you pay per the limit requested, not actual usage."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].content",
          "englishWordCount": 172,
          "excerpt": "# Micro-optimizations e tradeoffs Prestazioni optimization involves balancing competing concerns. Understanding tradeoffs helps make informed decisions about when e what to optimize. Readability vs prestazioni is a const..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].content",
          "englishWordCount": 40,
          "excerpt": "# Checkpoint: Compare before/after + output perf report Complete the optimization lab checkpoint: - Measure baseline prestazioni metrics - Apply optimization techniques - Verify correctness is preserved - Generate presta..."
        },
        {
          "path": "courses.defi-swap-aggregator.description",
          "englishWordCount": 18,
          "excerpt": "Padroneggia l aggregazione swap in produzione su Solana: parsing deterministico dei quote, tradeoff di ottimizzazione route, sicurezza slippage ed esecuzione orientata all affidabilita."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Meccaniche di swap token, protezione slippage, composizione route e costruzione deterministica di SwapPlan con tradeoff trasparenti."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].content",
          "englishWordCount": 404,
          "excerpt": "# Swap modello mentale: mints, ATAs, decimals, e routes Token swaps on Solana follow a fundamentally different model than centralized exchanges. Understanding the building blocks — mints, associated token account (ATAs),..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "AMM programs interact con SPL token account. Native SOL must be wrapped into the SPL token format so it can be processed by swap programs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].content",
          "englishWordCount": 383,
          "excerpt": "# Slippage e impatto sul prezzo: protecting swap outcomes Slippage is the difference between the expected output amount at quote time e the actual amount received at execution time. In volatile markets con active trading..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Token amounts are integers. Floating-point math can produce off-by-one errors that cause transazione failures or incorrect minimum amounts."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].content",
          "englishWordCount": 406,
          "excerpt": "# Route visualization: understanding swap legs e fees Swap routes reveal the path your tokens take through DeFi liquidity. Visualizing routes helps users understand why a multi-hop path might yield more output than a dir..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].content",
          "englishWordCount": 65,
          "excerpt": "# Challenge: Build a normalized SwapPlan from a quote Parse a raw aggregator quote response e produce a normalized SwapPlan: - Extract input/output mints e amounts from the quote - Calculate minOutAmount using BigInt sli..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Esecuzione con macchina a stati, anatomia transazione, pattern di affidabilita retry/staleness e reporting di esecuzione ad alto segnale."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].content",
          "englishWordCount": 68,
          "excerpt": "# Challenge: Implement swap UI state machine Build a deterministic state machine per the swap UI flow: - States: idle → quoting → ready → sending → confirming → success | error - Process a sequence of events e track all ..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].hints[1]",
          "englishWordCount": 12,
          "excerpt": "If an event is not valid per the current state, transition to 'error' con a descriptive message."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].content",
          "englishWordCount": 418,
          "excerpt": "# Swap transazione anatomy: istruzioni, account, e compute A swap transazione on Solana is a carefully ordered sequence of istruzioni that together achieve an atomic token exchange. Understanding each istruzione's role, ..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 13,
          "excerpt": "Compute budget istruzioni configure the transazione's CU limit e price before any program execution begins."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "ALTs allow transazioni to reference many account without exceeding the 1232-byte transazione size limit."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].content",
          "englishWordCount": 382,
          "excerpt": "# Reliability patterns: retries, stale quotes, e latency Production swap flows must handle the reality of network latency, expired quotes, e transazione failures. Reliability engineering separates toy swap implementation..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].content",
          "englishWordCount": 68,
          "excerpt": "# Checkpoint: Generate a SwapRunReport Build the final swap run report that combines all corso concepts: - Summarize the route con leg details e total fees (using BigInt summation) - Compute the effective price as outAmo..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Collect errors from both the state machine result e any additional errors array."
        },
        {
          "path": "courses.defi-clmm-liquidity.description",
          "englishWordCount": 17,
          "excerpt": "Padroneggia la liquidita concentrata sui DEX Solana: matematica dei tick, strategia di range, dinamiche fee/IL e reporting deterministico delle posizioni LP."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Concetti di liquidita concentrata, matematica tick/prezzo e comportamento delle posizioni di range per ragionare sull esecuzione CLMM."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].content",
          "englishWordCount": 646,
          "excerpt": "# CLMM vs constant product: why ticks exist Concentrated Liquidity Market Makers (CLMMs) represent a fundamental evolution in automated market maker progettazione. To understand why they exist, we must first understand t..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Ticks provide discrete price points per position boundaries, liquidity transitions, e efficient fee tracking at tick crossings."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].content",
          "englishWordCount": 553,
          "excerpt": "# Price, tick, e sqrtPrice: core conversions The mathematical foundation of every CLMM rests on three interrelated representations of price: the human-readable price, the tick index, e the sqrtPriceX64. Understanding how..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Token amounts in a CLMM position are linear functions of sqrtPrice, making on-chain computation simpler e more gas-efficient."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].content",
          "englishWordCount": 627,
          "excerpt": "# Range positions: in-range e out-of-range dynamics A CLMM position is defined by its lower tick e upper tick. These two boundaries determine the price range in which the position is active, earns fees, e holds a mix of ..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].content",
          "englishWordCount": 61,
          "excerpt": "# Challenge: Implement tick/price conversion helpers Implement the core tick math functions used in every CLMM integration: - Convert a tick index to a human-readable price using price = 1.0001^tick - Convert the price t..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Simulazione dell accumulo fee, tradeoff delle strategie di range, rischi di precisione e reporting deterministico del rischio di posizione."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].content",
          "englishWordCount": 66,
          "excerpt": "# Challenge: Simulate position fee accrual Implement a fee accrual simulator per a CLMM position over a price path: - Convert lower e upper tick boundaries to prices - Walk through each price in the path e determine in-r..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].content",
          "englishWordCount": 628,
          "excerpt": "# Range strategies: tight, wide, e rebalancing rules Choosing the right price range is the most important decision a CLMM liquidity provider makes. The range determines capital efficiency, fee income, impermanent loss ex..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "Tight ranges concentrate capital per higher efficiency e fee share, but the position goes out-of-range more often, requiring active management."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 18,
          "excerpt": "Full-range positions replicate constant product behavior e never go out-of-range, making them suitable per highly volatile or unpredictable pairs."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].content",
          "englishWordCount": 666,
          "excerpt": "# CLMM risks: rounding, overflow, e tick spacing errors Building reliable CLMM integrations requires awareness of precision risks that can cause incorrect calculations, failed transazioni, or lost funds. This lezione cat..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].content",
          "englishWordCount": 64,
          "excerpt": "# Checkpoint: Generate a Position Report Implement a comprehensive LP position report generator that combines all CLMM concepts: - Convert tick boundaries to human-readable prices - Determine in-range or out-of-range sta..."
        },
        {
          "path": "courses.defi-lending-risk.description",
          "englishWordCount": 18,
          "excerpt": "Padroneggia l ingegneria del rischio lending su Solana: meccaniche di tasso/utilizzo, analisi dei percorsi di liquidazione, sicurezza oracle e reporting deterministico di scenario."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].description",
          "englishWordCount": 18,
          "excerpt": "Meccaniche dei pool di lending, modelli di tasso guidati dall utilizzo e basi di health factor necessarie per un analisi del rischio difendibile."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].content",
          "englishWordCount": 530,
          "excerpt": "# Lending pool model: supply, borrow, e utilization Lending protocols are the backbone of decentralized finance. They enable users to earn yield on idle assets by supplying them to a shared pool, while borrowers draw fro..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].content",
          "englishWordCount": 435,
          "excerpt": "# Interest rate curves e the kink model Interest rates in lending protocols are not fixed. They adjust dynamically based on pool utilization to balance supply e demand per liquidity. The piecewise-linear \"kink\" model is ..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "Above the kink, slope2 (the jump multiplier) applies, causing borrow rates to spike sharply e discourage further borrowing."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Supply rate = borrowRate * utilization * (1 - reserveFactor). Since utilization < 1 e reserveFactor > 0, the supply rate is always less than the borrow rate."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].content",
          "englishWordCount": 440,
          "excerpt": "# Health factor monitoring e liquidation preview The health factor is the single number that determines whether a lending position is safe or subject to liquidation. Monitoring health factors in real time is essential pe..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].content",
          "englishWordCount": 85,
          "excerpt": "# Challenge: Compute utilization-based interest rates Implement the kink-based interest rate model used by lending protocols: - Calculate the utilization ratio from total supply e total borrowed - Apply the piecewise-lin..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Calcolo health factor, meccaniche di liquidazione, gestione guasti oracle e reporting di rischio multi-scenario per mercati sotto stress."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].content",
          "englishWordCount": 74,
          "excerpt": "# Challenge: Compute health factor e liquidation status Implement the health factor computation per a multi-asset lending position: - Sum collateral e borrow values from an array of position objects - Compute weighted av..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].content",
          "englishWordCount": 531,
          "excerpt": "# Liquidation mechanics: bonus, close factor, e bad debt Liquidation is the enforcement mechanism that keeps lending protocols solvent. When a borrower's health factor falls below 1.0, external actors called liquidators ..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 17,
          "excerpt": "The liquidation bonus compensates liquidators per gas costs e risk, ensuring positions are liquidated promptly to protect the protocol."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 20,
          "excerpt": "Bad debt materializes when rapid price drops make collateral worth less than the debt, leaving the protocol con unrecoverable losses."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].content",
          "englishWordCount": 573,
          "excerpt": "# Oracle risk e stale pricing in lending Lending protocols depend entirely on accurate, timely price feeds to compute collateral values, health factors, e liquidation eligibility. Oracles — the services that bring off-ch..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "Using price minus confidence per collateral gives a conservative valuation, protecting the protocol when oracle publishers disagree or markets are volatile."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Operating on stale prices is dangerous. Pausing operations prevents incorrect liquidations e under-collateralized borrows during oracle outages."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].content",
          "englishWordCount": 78,
          "excerpt": "# Checkpoint: Generate a multi-scenario risk report Build the final risk report that combines all corso concepts: - Evaluate a base case using current position prices - Apply price overrides from multiple named scenarios..."
        },
        {
          "path": "courses.defi-perps-risk-console.description",
          "englishWordCount": 16,
          "excerpt": "Padroneggia il rischio perps su Solana: contabilita precisa di PnL/funding, monitoraggio del margine, simulazione di liquidazione e reporting deterministico su console."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Meccaniche dei futures perpetui, logica di accumulo del funding e basi di modellazione PnL per diagnosi di posizione accurate."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].content",
          "englishWordCount": 608,
          "excerpt": "# Perpetual futures: base positions, entry price, e mark vs oracle Perpetual futures (perps) are synthetic derivatives that let traders gain exposure to an asset's price movement without holding the underlying token. Unl..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].content",
          "englishWordCount": 601,
          "excerpt": "# Funding rates: why they exist e how they accrue Funding rates are the mechanism that tethers a perpetual contract's price to the underlying spot price. Without funding, the perp price could drift arbitrarily far from r..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "A positive premium (mark > oracle) produces a positive funding rate. Longs pay shorts, which discourages excessive long demand e pushes the perp price back toward spot."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].content",
          "englishWordCount": 561,
          "excerpt": "# PnL visualization: tracking profit over time Profit e loss (PnL) tracking in perpetual futures requires careful accounting across multiple dimensions: unrealized PnL from price movement, realized PnL from closed portio..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].content",
          "englishWordCount": 56,
          "excerpt": "# Challenge: Calculate perpetual futures PnL Implement a PnL calculator per perpetual futures positions: - Compute unrealized PnL based on entry price vs mark price - Handle both long e short positions correctly - Calcul..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].content",
          "englishWordCount": 71,
          "excerpt": "# Challenge: Simulate funding rate accrual Build a funding accrual simulator that processes discrete funding intervals: - Iterate through an array of funding rates e compute the payment per each period - Longs pay (subtr..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Monitoraggio di margine e liquidazione, bug comuni di implementazione e output deterministici della console di rischio per osservabilita in produzione."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].content",
          "englishWordCount": 600,
          "excerpt": "# Margin ratio e liquidation thresholds Margin is the collateral that backs a leveraged position. When the margin falls below a critical threshold relative to the position's notional value, the protocol forcibly closes t..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 27,
          "excerpt": "The maintenance buffer ensures that when a position is liquidated, there is still margin left to pay liquidation fees e absorb slippage during the close. Without it, positions could go underwater, creating bad debt."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].content",
          "englishWordCount": 752,
          "excerpt": "# Common bugs: sign errors, units, e funding direction Perpetual futures implementations are mathematically straightforward — the formulas are basic arithmetic. Yet sign errors, unit mismatches, e funding direction bugs ..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 37,
          "excerpt": "When size carries the direction sign, every formula that uses size must account per the sign — not just PnL, but also notional value, funding payments, e liquidation price. Keeping size positive e branching on a separate..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].content",
          "englishWordCount": 75,
          "excerpt": "# Checkpoint: Generate a Risk Console Report Build the comprehensive risk console report that integrates all corso concepts: - Calculate unrealized PnL e ROE per the position - Accumulate funding payments across all prov..."
        },
        {
          "path": "courses.defi-tx-optimizer.description",
          "englishWordCount": 18,
          "excerpt": "Padroneggia l ottimizzazione delle transazioni DeFi su Solana: tuning compute/fee, strategia ALT, pattern di affidabilita e pianificazione deterministica della strategia di invio."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Diagnosi dei fallimenti di transazione, meccaniche compute budget, strategia priority fee e basi di stima fee."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].content",
          "englishWordCount": 564,
          "excerpt": "# Why DeFi transazioni fail: CU limits, size, e blockhash expiry DeFi transazioni on Solana fail per three primary reasons: compute budget exhaustion, transazione size overflow, e blockhash expiry. Understanding each fai..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "Solana allocates 200,000 CUs by default. DeFi transazioni almost always need more, requiring an explicit SetComputeUnitLimit istruzione."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Expired blockhash transazioni are never processed e produce no on-chain record. The client must detect the timeout e resubmit con a fresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].content",
          "englishWordCount": 463,
          "excerpt": "# Compute budget istruzioni e priority fee strategy The Compute Budget Program provides two critical istruzioni that every serious DeFi transazione should include: `SetComputeUnitLimit` e `SetComputeUnitPrice`. Together,..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Account state may change between simulation e execution, causing minor CU variations. A 10% margin absorbs these differences."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].content",
          "englishWordCount": 462,
          "excerpt": "# Transazione cost estimation e fee planning Accurate fee estimation is the foundation of a good DeFi user experience. Users need to know what a transazione will cost before they sign it. Validatori need sufficient fees ..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].content",
          "englishWordCount": 79,
          "excerpt": "# Challenge: Build a transazione plan con compute budgeting Build a transazione planning function that analyzes a set of istruzioni e produces a complete transazione plan: - Sum estimatedCU from all istruzioni e add a 10..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Pianificazione Address Lookup Table, pattern di affidabilita/retry, UX di errore azionabile e report completo della strategia di invio."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].content",
          "englishWordCount": 97,
          "excerpt": "# Challenge: Plan Address Lookup Table usage Build a function that determines the optimal Address Lookup Table strategy per a transazione: - Collect all unique account keys across istruzioni - Check which keys exist in a..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].content",
          "englishWordCount": 550,
          "excerpt": "# Reliability patterns: retry, re-quote, resend vs rebuild Production DeFi applications must handle transazione failures gracefully. The difference between a frustrating e a reliable experience comes down to retry strate..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "Rebuilding is necessary when the transazione's blockhash is stale or when on-chain state has changed (e.g., slippage exceeded). Simple network issues only require resending the same bytes."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "englishWordCount": 12,
          "excerpt": "To prevent many clients from retrying at the exact same moment e overwhelming the network"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].content",
          "englishWordCount": 586,
          "excerpt": "# UX: actionable error messages per transazione failures Raw Solana error messages are cryptic. \"Transazione simulation failed: Error processing Istruzione 2: custom program error: 0x1771\" tells a developer something but..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].content",
          "englishWordCount": 89,
          "excerpt": "# Checkpoint: Generate a send strategy report Build the final send strategy report that combines all corso concepts into a comprehensive transazione optimization plan: - Build a tx plan: sum CU estimates con 10% margin (..."
        },
        {
          "path": "courses.solana-mobile-signing.description",
          "englishWordCount": 18,
          "excerpt": "Padroneggia la firma wallet mobile in produzione su Solana: sessioni Android MWA, vincoli deep-link iOS, retry resilienti e telemetria di sessione deterministica."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Vincoli di piattaforma, pattern UX di connessione, comportamento timeline della firma e costruzione tipizzata di request su Android/iOS."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].content",
          "englishWordCount": 709,
          "excerpt": "# Mobile signing reality check: Android vs iOS constraints Mobile wallet signing on Solana is fundamentally different from browser-based wallet interactions. The constraints imposed by Android e iOS operating systems sha..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "Android MWA uses foreground services to maintain a persistent communication channel between the dApp e wallet, enabling multi-request sessions without app switching."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].content",
          "englishWordCount": 715,
          "excerpt": "# Wallet connection UX patterns: connect, reconnect, e recovery Wallet connection on mobile is the first interaction users have con your dApp. A smooth connection flow builds trust; a broken one drives users away. This l..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "Network mismatches should be communicated clearly to the user con istruzioni on how to resolve them, avoiding confusing silent failures."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].content",
          "englishWordCount": 667,
          "excerpt": "# Signing session timeline: request, wallet, e response flow Understanding the complete lifecycle of a mobile signing request is essential per building reliable dApps. Every sign request passes through multiple stages, e..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].content",
          "englishWordCount": 70,
          "excerpt": "# Challenge: Build a typed sign request Implement a sign request builder per Mobile Wallet Adapter: - Validate the payload type (transazione or message) - Validate payload data (base64 per transazioni, non-empty string p..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[2]",
          "englishWordCount": 13,
          "excerpt": "App identity requires at least name e URI. Icon is optional but should default to empty string."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].description",
          "englishWordCount": 17,
          "excerpt": "Persistenza sessione, sicurezza delle schermate di review transazione, macchine a stati di retry e report deterministico di sessione per app mobile in produzione."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].content",
          "englishWordCount": 59,
          "excerpt": "# Challenge: Session persistence e restoration Implement a session persistence manager per mobile wallet sessions: - Process a sequence of actions: save, restore, clear, e expire_check - Track wallet address e last sign ..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].content",
          "englishWordCount": 633,
          "excerpt": "# Mobile transazione review: what users need to see Transazione review screens are the last line of defense between a user e a potentially harmful transazione. On mobile, screen real estate is limited e user attention is..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 17,
          "excerpt": "Token amounts must be converted to human-readable format using the token's decimal configuration e include the symbol per clarity."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Balance change summaries (e.g., -1.5 SOL, +150 USDC) are the most user-friendly way to communicate what a transazione will do."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].content",
          "englishWordCount": 710,
          "excerpt": "# One-tap retry: handling offline, rejected, e timeout states Mobile environments are inherently unreliable. Users move between WiFi e cellular, enter tunnels, close apps mid-transazione, e wallet crash. A robust retry s..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].content",
          "englishWordCount": 59,
          "excerpt": "# Checkpoint: Generate a session report Implement a session report generator that summarizes a complete mobile signing session: - Count total requests, successful signs, e failed signs - Sum retry attempts across all req..."
        },
        {
          "path": "courses.solana-pay-commerce.description",
          "englishWordCount": 17,
          "excerpt": "Padroneggia l integrazione commerce Solana Pay: encoding URL robusto, workflow di tracking QR/pagamento, UX di conferma e artefatti deterministici per la riconciliazione POS."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Specifica Solana Pay, rigore nell encoding URL, anatomia delle transfer request e pattern deterministici di builder/encoder."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].content",
          "englishWordCount": 589,
          "excerpt": "# Solana Pay modello mentale e URL encoding rules Solana Pay is an open specification per encoding payment requests into URLs that wallet can parse e execute. Unlike traditional payment processors that rely on centralize..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "The Solana Pay specification uses the 'solana:' scheme followed immediately by the recipient address con no slashes."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Transazione requests allow the server to build arbitrarily complex transazioni. Transfer requests only support simple single-token transfers."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].content",
          "englishWordCount": 631,
          "excerpt": "# Transfer request anatomy: recipient, amount, reference, e labels A Solana Pay transfer request URL contains everything a wallet needs to construct e submit a payment transazione. Each component of the URL serves a spec..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 22,
          "excerpt": "The reference public key is included as a non-signer account in the transfer istruzione. The merchant polls getSignaturesForAddress(reference) to detect when the payment transazione confirms."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].content",
          "englishWordCount": 473,
          "excerpt": "# URL builder: live preview of Solana Pay URLs Building Solana Pay URLs correctly requires understanding how each parameter contributes to the final encoded string. In this lezione, we walk through the construction proce..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].content",
          "englishWordCount": 73,
          "excerpt": "# Challenge: Encode a Solana Pay transfer request URL Build a function that encodes a Solana Pay transfer request URL from input parameters: - Validate the recipient address (must be 32-44 characters of valid base58) - V..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Macchine a stati di tracking per reference, UX di conferma, gestione dei guasti e generazione deterministica di ricevuta POS."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].content",
          "englishWordCount": 84,
          "excerpt": "# Challenge: Track payment references through confirmation states Build a reference tracking state machine that processes payment events: - States flow: pending -> found -> confirmed -> finalized (or pending -> expired) ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].content",
          "englishWordCount": 644,
          "excerpt": "# Confirmation UX: pending, confirmed, e expired states The user experience during payment confirmation is the most critical moment in any Solana Pay integration. Between the customer scanning the QR code e the merchant ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "englishWordCount": 13,
          "excerpt": "Confirmed is sufficient per low-value POS transazioni; finalized is needed per irreversible digital fulfillment"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "Per coffee-shop-scale payments, confirmed commitment provides a strong enough guarantee. Finalized adds 6-12 seconds of latency e is only necessary when fulfillment is irreversible."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 22,
          "excerpt": "Expired requests should be clearly communicated. The customer may have been in the middle of approving — they need to know the request expired e can try again."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].content",
          "englishWordCount": 698,
          "excerpt": "# Error handling e edge cases in payment flows Production payment systems encounter a wide range of failure modes that must be handled gracefully. Solana Pay integrations face challenges unique to blockchain payments: ne..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].content",
          "englishWordCount": 78,
          "excerpt": "# Checkpoint: Generate a POS receipt Build the final POS receipt generator that combines all corso concepts: - Reconstruct the Solana Pay URL from payment data (recipient, amount, spl-token, reference, label) - Generate ..."
        },
        {
          "path": "courses.wallet-ux-engineering.description",
          "englishWordCount": 15,
          "excerpt": "Padroneggia l ingegneria UX wallet in produzione su Solana: stato di connessione deterministico, sicurezza di rete, resilienza RPC e pattern di affidabilita misurabili."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Design della connessione wallet, network gating e architettura deterministica della macchina a stati per onboarding e riconnessione prevedibili."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].content",
          "englishWordCount": 701,
          "excerpt": "# Connection UX that doesn't suck: a progettazione checklist Wallet connection is the first interaction a user has con any Solana dApp. If this experience is slow, confusing, or error-prone, most users will leave before ..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 18,
          "excerpt": "Skeleton UI reserves the layout space per wallet-dependent content, preventing jarring shifts when the connection resolves e data loads."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].content",
          "englishWordCount": 715,
          "excerpt": "# Network gating e wrong-network recovery Solana has multiple clusters: mainnet-beta, devnet, testnet, e localnet. Unlike EVM chains where the wallet controls the network e emits chain-change events, Solana's network sel..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 31,
          "excerpt": "Each Solana cluster has a unique genesis hash. Comparing the RPC's genesis hash against known values is the only reliable detection method, since URL strings can be misleading e wallet don't always expose network info."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].content",
          "englishWordCount": 605,
          "excerpt": "# Connection state machine: states, events, e transitions Wallet connection logic in most dApps is implemented as a tangle of boolean flags, useEffect hooks, e conditional renders. This approach leads to impossible state..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].content",
          "englishWordCount": 73,
          "excerpt": "# Challenge: Implement wallet connection state machine Build a deterministic state machine per wallet connection management: - States: disconnected, connecting, connected, error - Process a sequence of events e track all..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Invalidazione cache, resilienza e monitoraggio salute RPC, e reporting misurabile della qualita UX wallet per operazioni in produzione."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].content",
          "englishWordCount": 85,
          "excerpt": "# Challenge: Cache invalidation on wallet events Build a cache invalidation engine that processes wallet events e invalidates the correct cache entries: - Cache entries have tags: \"account\" (wallet-specific data), \"netwo..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].content",
          "englishWordCount": 686,
          "excerpt": "# RPC reads e caching strategy per wallet apps Every interaction in a Solana wallet application ultimately depends on RPC calls: fetching balances, loading token account, reading program state, e confirming transazioni. ..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "englishWordCount": 12,
          "excerpt": "Account states differ across clusters, so cached devnet data would be wrong per mainnet"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "SWR prioritizes responsiveness by serving stale data instantly while refreshing in the background. This eliminates loading states per data that has only slightly exceeded its TTL."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].content",
          "englishWordCount": 859,
          "excerpt": "# RPC health monitoring e graceful degradation RPC endpoints are the lifeline of every Solana wallet application. When they go down, become slow, or return stale data, your app becomes unusable. Production wallet apps mu..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].content",
          "englishWordCount": 74,
          "excerpt": "# Checkpoint: Generate a Wallet UX Report Build the final wallet UX quality report that combines all corso concepts: - Count connection attempts (CONNECT events) e successful connections (CONNECTED events) - Calculate su..."
        },
        {
          "path": "courses.sign-in-with-solana.description",
          "englishWordCount": 19,
          "excerpt": "Padroneggia l autenticazione SIWS in produzione su Solana: input standardizzati, invarianti rigorose di verifica, ciclo di vita nonce resistente al replay e reporting pronto per audit."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Razionale SIWS, semantica rigorosa dei campi input, comportamento di rendering wallet e costruzione deterministica del sign-in input."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].content",
          "englishWordCount": 806,
          "excerpt": "# Why SIWS exists: replacing connect-e-signMessage Before Sign-In Con Solana (SIWS) became a standard, dApps authenticated wallet holders using a two-step pattern: connect the wallet, then call `signMessage` con an arbit..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 25,
          "excerpt": "Without structured format, wallet treat signMessage payloads as opaque bytes e cannot validate or warn about the content, making it easy per malicious dApps to disguise harmful payloads as sign-in requests."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "The server generates a unique nonce per each sign-in attempt. After successful verification, the nonce is marked as consumed. Any reuse of the same nonce is rejected as a replay attack."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].content",
          "englishWordCount": 826,
          "excerpt": "# SIWS input fields e sicurezza rules The Sign-In Con Solana input is a structured object that defines every parameter of an authentication request. Each field has specific validation rules, sicurezza implications, e ren..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "If the client generates nonces, an attacker can replay a previously captured nonce-signature pair. Server-generated nonces ensure each authentication attempt is unique e controlled by the server."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "The domain field must be a plain domain name. Protocol prefixes, paths, ports, e query strings must be rejected to ensure consistent domain matching."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[2].content",
          "englishWordCount": 818,
          "excerpt": "# Message preview: how wallet render SIWS requests When a dApp sends a SIWS sign-in request to a wallet, the wallet transforms the structured input into a human-readable message that the user sees on the approval screen...."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].content",
          "englishWordCount": 69,
          "excerpt": "# Challenge: Build a validated SIWS sign-in input Implement a function that creates a validated Sign-In Con Solana input: - Validate domain (non-empty, must not include protocol prefix) - Validate nonce (at least 8 chara..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Invarianti di verifica server-side, difese nonce anti-replay, gestione sessione e reporting deterministico di audit autenticazione."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].content",
          "englishWordCount": 59,
          "excerpt": "# Challenge: Verify a SIWS sign-in response Implement server-side verification of a SIWS sign-in output: - Check domain matches expected domain - Check nonce matches expected nonce - Check issuedAt is not in the future r..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].content",
          "englishWordCount": 791,
          "excerpt": "# Sessions e logout: what to store e what not to store After a successful SIWS sign-in verification, the server must establish a session so the user does not need to re-authenticate on every request. Session management p..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].content",
          "englishWordCount": 881,
          "excerpt": "# Replay protection e nonce registry progettazione Replay attacks are the most critical threat to any signature-based authentication system. In a replay attack, an adversary captures a valid signed message e submits it a..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].content",
          "englishWordCount": 80,
          "excerpt": "# Checkpoint: Generate an auth audit report Build the final auth audit report that combines all corso concepts: - Process an array of authentication attempts con address, nonce, e verified status - Track used nonces to d..."
        },
        {
          "path": "courses.priority-fees-compute-budget.description",
          "englishWordCount": 17,
          "excerpt": "Ingegneria difensiva delle fee Solana con pianificazione compute deterministica, politica adattiva di priorita e contratti UX di affidabilita orientati alla conferma."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Meccaniche di inclusione, accoppiamento compute/fee e design policy guidato da explorer con framing deterministico di affidabilita."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].content",
          "englishWordCount": 587,
          "excerpt": "# Fee markets on Solana: what actually moves inclusion Priority fees on Solana are often explained as a simple slider, but production systems need a more precise model. Inclusion is influenced by contention per compute, ..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "A large CU request con weak price can lose inclusion, while aggressive price on oversized CU can overpay."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].content",
          "englishWordCount": 542,
          "excerpt": "# Compute budget fondamenti e common failure modes Most transazione failures blamed on \"network issues\" are actually planning errors in compute budget e payload sizing. A defensive client treats compute planning as a det..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[2].content",
          "englishWordCount": 465,
          "excerpt": "# Explorer: compute budget planner inputs to plan Explorers are useful only when they expose policy tradeoffs clearly. Per a fee e compute planner, that means visualizing how input estimates, percentile targets, e confir..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implementare planner deterministici, motori di policy di conferma e artefatti stabili di strategia fee per review di release."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].content",
          "englishWordCount": 12,
          "excerpt": "Implement policy-based priority fee estimation using synthetic sample arrays e deterministic warnings."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[2].content",
          "englishWordCount": 12,
          "excerpt": "Encode confirmation UX policy per processed, confirmed, e finalized states using deterministic risk bands."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].content",
          "englishWordCount": 15,
          "excerpt": "Build stable markdown output per a fee strategy summary that users e support teams can review quickly."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[4].content",
          "englishWordCount": 12,
          "excerpt": "Produce a deterministic checkpoint report JSON per the Fee Optimizer final project artifact."
        },
        {
          "path": "courses.bundles-atomicity.description",
          "englishWordCount": 19,
          "excerpt": "Progetta flussi Solana difensivi multi-transazione con validazione deterministica dell atomicita, modellazione della compensazione e reporting di sicurezza pronto per audit."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Modello di atomicita, rischi dei flussi multi-transazione e validazione difensiva di sicurezza per proteggere le aspettative utente."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].content",
          "englishWordCount": 525,
          "excerpt": "# Atomicity concepts e why users assume all-or-nothing Users rarely think in transazione graphs. They think in intents: \"swap my token\" or \"close my position.\" When a workflow spans multiple transazioni, user expectation..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].content",
          "englishWordCount": 503,
          "excerpt": "# Multi-transazione flows: approvals, ATA creation, swaps, refunds A reliable flow simulator must encode where partial execution risk lives. In practice, risk points cluster at boundaries: before value transfer, during v..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[2].content",
          "englishWordCount": 463,
          "excerpt": "# Explorer: flow graph steps e risk points Flow graph explorers are most valuable when they highlight risk semantics, not just sequence order. A defensive explorer should display each step con dependency context, idempot..."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implementare validatori deterministici di atomicita, pattern di gestione failure e composizione stabile dei bundle per review di release."
        },
        {
          "path": "courses.mempool-ux-defense.description",
          "englishWordCount": 17,
          "excerpt": "Ingegneria difensiva UX per swap con grading del rischio deterministico, policy di slippage limitate e comunicazione di sicurezza pronta per incidenti."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Rischi tra quote ed esecuzione, guardrail di slippage e decisioni di freshness per swap piu sicuri in produzione."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].content",
          "englishWordCount": 533,
          "excerpt": "# What can go wrong between quote e execution A swap quote is a prediction, not a guarantee. Between quote generation e execution, liquidity changes, competing orders land, e network conditions shift. Users often assume ..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[1].content",
          "englishWordCount": 482,
          "excerpt": "# Slippage controls e guardrails Slippage settings are a policy surface, not a cosmetic preference. Defensive swap UX defines explicit bounds, context-aware defaults, e clear consequences when users attempt risky overrid..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[2].content",
          "englishWordCount": 448,
          "excerpt": "# Explorer: quote freshness timer e decision table A quote freshness explorer should make policy behavior obvious under time pressure. Users e engineers need to see when a quote transitions from safe to warning to blocke..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[0].content",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic swap risk grading from quote, slippage, impact, hops, e liquidity inputs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.description",
          "englishWordCount": 16,
          "excerpt": "Costruisci pipeline di indicizzazione deterministiche di livello produzione per ingestion sicura ai duplicati, gestione reorg e reporting orientato all integrita."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Basi di indicizzazione, realta reorg/confirmations e stadi della pipeline per ingestion tracciabili e sicure."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].content",
          "englishWordCount": 509,
          "excerpt": "# Indexing 101: logs, account, e transazione parsing Reliable indexers are not just fast parsers. They are consistency systems that decide what to trust, when to trust it, e how to recover from changing chain history. On..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[1].content",
          "englishWordCount": 457,
          "excerpt": "# Reorgs e fork choice: why confirmed is not finalized Confirmation labels are useful but often misunderstood in indexing pipelines. A confirmed event has stronger confidence than processed, but it is not equivalent to f..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[2].content",
          "englishWordCount": 462,
          "excerpt": "# Explorer: ingest to dedupe to confirm to apply A pipeline explorer should explain transformation stages clearly so engineers can inspect where correctness can break. Per indexing reliability, the core stages are ingest..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implementare logica confirmations, pianificazione backfill/idempotenza e controlli di integrita per report pipeline stabili."
        },
        {
          "path": "courses.rpc-reliability-latency.description",
          "englishWordCount": 15,
          "excerpt": "Progetta client RPC Solana multi-provider di livello produzione con policy deterministiche di retry, routing, caching e observability."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Real-world RPC failure behavior, endpoint selection strategy, e deterministic retry policy modeling."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].content",
          "englishWordCount": 520,
          "excerpt": "# RPC failures in real life: timeouts, 429s, stale nodes Reliable client infrastructure begins con realistic failure assumptions. RPC calls fail per many reasons: transient network timeouts, provider rate limits, stale n..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].content",
          "englishWordCount": 430,
          "excerpt": "# Multi-endpoint strategies: hedged requests e fallbacks Multi-endpoint progettazione is more than adding a backup URL. It is a scheduling problem where each request should be sent to the most suitable endpoint given rec..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].content",
          "englishWordCount": 460,
          "excerpt": "# Explorer: retry/backoff simulator Retry e backoff policies determine whether clients recover gracefully or amplify outages. A simulator should make schedule behavior explicit so teams can reason about user latency e pr..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Build deterministic policy engines per routing, retries, metrics reduction, e health report exports."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].content",
          "englishWordCount": 12,
          "excerpt": "Export deterministic JSON e markdown health report artifacts per multi-provider reliability review."
        },
        {
          "path": "courses.rust-data-layout-borsh.description",
          "englishWordCount": 19,
          "excerpt": "Ingegneria del layout dati Solana con approccio Rust-first e tooling deterministico byte-level, insieme a pratiche schema sicure per la compatibilita."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Alignment behavior, Borsh encoding rules, e pratico parsing safety per stable byte-level contracts."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].content",
          "englishWordCount": 555,
          "excerpt": "# Memory layout: alignment, padding, e why Solana account care Rust layout behavior is deterministic inside one compiled binary but can vary when assumptions are implicit. Per Solana account, this matters because raw byt..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].content",
          "englishWordCount": 492,
          "excerpt": "# Struct e enum layout pitfalls plus Borsh rules Borsh is widely used because it gives deterministic serialization across languages, but teams still get tripped up by how enums, vectors, e strings map to bytes. Understan..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[2].content",
          "englishWordCount": 443,
          "excerpt": "# Explorer: layout visualizer per field offsets A layout visualizer turns abstract alignment rules into concrete numbers engineers can review. Instead of debating whether a struct is \"probably fine,\" teams can inspect ex..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic layout analysis, encoding/decoding, safe parsing, e compatibility-focused reporting helpers."
        },
        {
          "path": "courses.rust-errors-invariants.description",
          "englishWordCount": 17,
          "excerpt": "Costruisci librerie tipizzate di guardie per invarianti con artefatti di evidenza deterministici, contratti errore compatibili e reporting pronto per audit."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].content",
          "englishWordCount": 536,
          "excerpt": "# Error taxonomy: recoverable vs fatal Rust encourages explicit error modeling, but teams still produce weak error contracts when they rely on ad hoc strings or inconsistent wrappers. In Solana e Anchor-adjacent systems,..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[1].content",
          "englishWordCount": 513,
          "excerpt": "# Result<T, E> patterns, ? operator, e context Result-based control flow is one of Rust's strongest tools per building robust services e on-chain-adjacent clients. The key is not merely using Result, but designing error ..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].content",
          "englishWordCount": 452,
          "excerpt": "# Explorer: invariant decision tree An invariant decision tree helps teams reason about guard ordering e failure priority. Not every invariant should be checked in arbitrary order. Early checks should prevent expensive w..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement guard helpers, evidence-chain generation, e stable audit reporting per reliability e incident response."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.description",
          "englishWordCount": 17,
          "excerpt": "Simula e ottimizza il comportamento del costo compute con tooling deterministico Rust-first e governance delle performance guidata dal budget."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Rust prestazioni modello mentales, data-structure tradeoffs, e deterministic cost reasoning per reliable optimization decisions."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].content",
          "englishWordCount": 493,
          "excerpt": "# Prestazioni modello mentale: allocations, clones, hashing Rust prestazioni work in Solana ecosystems is mostly about data movement discipline. Teams often chase micro-optimizations while ignoring dominant costs such as..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].content",
          "englishWordCount": 472,
          "excerpt": "# Data structures: Vec, HashMap, BTreeMap tradeoffs Data structure choice is one of the highest leverage prestazioni decisions in Rust systems. Vec offers compact contiguous storage e predictable iteration speed. HashMap..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].content",
          "englishWordCount": 451,
          "excerpt": "# Explorer: cost model sandbox A cost sandbox lets teams test optimization hypotheses without waiting per full benchmark infrastructure. Provide operation counts, compute weighted costs, e inspect which buckets dominate ..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.description",
          "englishWordCount": 14,
          "excerpt": "Ingegneria di pipeline async Rust-first con concorrenza limitata, reducer replay-safe e reporting operativo deterministico."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].content",
          "englishWordCount": 501,
          "excerpt": "# Async fundamentals: futures, tasks, channels Rust async systems are built on explicit scheduling rather than implicit thread-per-task models. Futures represent pending work, executors poll futures, e channels coordinat..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[1].content",
          "englishWordCount": 446,
          "excerpt": "# Concurrency limits e backpressure Backpressure is not optional in high-volume pipelines. Without it, producer speed can overwhelm reducers, retries, or storage sinks. A resilient progettazione sets explicit concurrency..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[2].content",
          "englishWordCount": 465,
          "excerpt": "# Explorer: pipeline graph e concurrency Pipeline graphs help teams communicate stage boundaries, concurrency budgets, e retry behaviors. A graph that shows ingest, dedupe, retry, e snapshot stages con explicit capacitie..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implement deterministic scheduling, retries, dedupe/reducer stages, e report exports per reorg-safe pipeline operations."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.description",
          "englishWordCount": 15,
          "excerpt": "Sicurezza macro/codegen in Rust insegnata con parser deterministico e tooling di generazione controlli con output audit-friendly."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].content",
          "englishWordCount": 489,
          "excerpt": "# Macro modello mentale: declarative vs procedural Rust macros come in two broad forms: declarative macros per pattern-based expansion e procedural macros per syntax-aware transformation. Anchor relies heavily on macro-d..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].content",
          "englishWordCount": 455,
          "excerpt": "# Safety through codegen: constraint checks Constraint codegen converts compact declarations into explicit runtime guards. Typical constraints include signer presence, account ownership, has-one relations, e mutability r..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].content",
          "englishWordCount": 451,
          "excerpt": "# Explorer: constraint builder to generated checks A constraint builder explorer helps engineers see how DSL choices affect generated code e runtime safety outcomes. Input one attribute line, observe parsed AST, generate..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Parse DSL constraints, generate checks, run deterministic evaluations, e publish stable safety reports."
        },
        {
          "path": "courses.anchor-upgrades-migrations.description",
          "englishWordCount": 17,
          "excerpt": "Progetta workflow di release Anchor sicuri per la produzione con pianificazione migrazione deterministica, gate di upgrade, playbook rollback ed evidenze di readiness."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Authority lifecycle, account versioning strategy, e deterministic upgrade risk modeling per Anchor releases."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].content",
          "englishWordCount": 552,
          "excerpt": "# Upgrade authority lifecycle in Anchor programs Anchor makes istruzione development easier, but upgrade safety still depends on disciplined control of program authority. In production Solana systems, most upgrade incide..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[1].content",
          "englishWordCount": 504,
          "excerpt": "# Account versioning e migration strategy Solana account are long-lived state containers, so program upgrades must respect historical data. In Anchor, adding or changing account fields can be safe, risky, or catastrophic..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].content",
          "englishWordCount": 453,
          "excerpt": "# Explorer: upgrade risk matrix A useful upgrade explorer should show cause-e-effect between release inputs e safety outcomes. If a flag changes, engineers should immediately see how severity e readiness changes. This le..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Safety validation gates, rollback planning, e deterministic readiness artifacts per controlled migration execution."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].content",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic blocking issue checks per authority, artifact hash, e dry-run status."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].content",
          "englishWordCount": 450,
          "excerpt": "# Rollback strategy e incident playbooks Even strong upgrade plans can encounter surprises: incompatible downstream clients, unexpected account edge cases, or release pipeline mistakes. Teams that recover quickly are the..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].content",
          "englishWordCount": 14,
          "excerpt": "Produce the final deterministic checkpoint artifact con release tag, readiness flag, e migration batch count."
        },
        {
          "path": "courses.solana-reliability.description",
          "englishWordCount": 20,
          "excerpt": "Ingegneria di affidabilita orientata alla produzione per sistemi Solana: fault tolerance, retry, deadline, circuit breaker e degradazione graduale con risultati operativi misurabili."
        },
        {
          "path": "courses.solana-reliability.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Implement fault-tolerance building blocks con clear failure classification, retry boundaries, e deterministic recovery behavior."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[0].content",
          "englishWordCount": 221,
          "excerpt": "Fault tolerance in Solana systems is not just about catching errors. It is about deciding which failures are safe to retry, which should fail fast, e how to preserve user trust while doing both. A pratico reliability mod..."
        },
        {
          "path": "courses.solana-reliability.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Build resilience mechanisms (circuit breakers, bulkheads, e rate controls) that protect core user flows during provider instability."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[0].content",
          "englishWordCount": 187,
          "excerpt": "Resilience patterns are controls that prevent localized failures from becoming system-wide incidents. On Solana integrations, they are especially important because provider health can change quickly under bursty network ..."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].content",
          "englishWordCount": 13,
          "excerpt": "Implement a circuit breaker pattern that opens after consecutive failures e closes after a recovery period."
        },
        {
          "path": "courses.solana-testing-strategies.description",
          "englishWordCount": 20,
          "excerpt": "Strategia di testing completa e orientata alla produzione per Solana: test unitari deterministici, integration test realistici, fuzz/property testing e reporting di confidenza release."
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Build deterministic unit e integration test layers con clear ownership of invariants, fixtures, e failure diagnostics."
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[0].content",
          "englishWordCount": 161,
          "excerpt": "Test Solana systems effectively requires layered confidence, not one giant test suite. Unit tests validate pure logic: math, state transitions, e invariant checks. They should be fast, deterministic, e run on every chang..."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Use fuzzing, property-based tests, e mutation-style checks to expose edge-case failures before release."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[0].content",
          "englishWordCount": 156,
          "excerpt": "Avanzato test techniques uncover failures that example-based tests rarely find. Fuzzing explores broad random input space to trigger parser edge cases, boundary overflows, e unexpected state combinations. It is especiall..."
        },
        {
          "path": "courses.solana-program-optimization.description",
          "englishWordCount": 17,
          "excerpt": "Progetta performance Solana di livello produzione: compute budgeting, efficienza del layout account, tradeoff memoria/rent e workflow di ottimizzazione deterministici."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Optimize compute-heavy paths con explicit CU budgets, operation-level profiling, e predictable prestazioni tradeoffs."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Compute units are the hard resource budget that shapes what your Solana program can do in a single transazione. Prestazioni optimization starts by treating CU usage as a contract, not an afterthought. A reliable optimiza..."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Progettazione memory/storage-efficient account layouts con rent-aware sizing, serialization discipline, e safe migration planning."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[0].content",
          "englishWordCount": 96,
          "excerpt": "Account data optimization is both a cost e correctness discipline. Poor layouts increase rent, slow parsing, e make migrations fragile. Progettazione principles: - Keep hot fields compact e easy to parse. - Use fixed-siz..."
        },
        {
          "path": "courses.solana-tokenomics-design.description",
          "englishWordCount": 16,
          "excerpt": "Progetta economie di token Solana robuste con disciplina di distribuzione, sicurezza vesting, incentivi staking e meccaniche di governance difendibili operativamente."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Model token allocation e vesting systems con explicit fairness, unlock predictability, e deterministic accounting rules."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[0].content",
          "englishWordCount": 93,
          "excerpt": "Token distribution is a sicurezza e credibility decision, not just a spreadsheet exercise. Allocation e vesting rules shape long-term trust in the protocol. A strong distribution model answers: - who receives tokens e wh..."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Progettazione staking e governance mechanics con clear incentive alignment, anti-manipulation constraints, e measurable participation health."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[0].content",
          "englishWordCount": 93,
          "excerpt": "Staking e governance systems must balance participation incentives con manipulation resistance. Rewarding lock behavior is useful, but poorly tuned models can over-concentrate influence. Core progettazione questions: 1) ..."
        },
        {
          "path": "courses.solana-defi-primitives.description",
          "englishWordCount": 18,
          "excerpt": "Costruisci fondamenta DeFi pratiche su Solana: meccaniche AMM, contabilita della liquidita, primitive lending e pattern di composizione sicuri contro flash loan."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Implement AMM e liquidity primitives con deterministic math, slippage-aware outputs, e LP accounting correctness."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[0].content",
          "englishWordCount": 96,
          "excerpt": "AMM fundamentals are simple in formula but subtle in implementation quality. The invariant math must be deterministic, fee handling explicit, e rounding behavior consistent across paths. Per constant-product pools, route..."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Model lending e flash-loan flows con collateral safety, utilization-aware pricing, e strict repayment invariants."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[0].content",
          "englishWordCount": 85,
          "excerpt": "Lending primitives e flash-loan logic are powerful but unforgiving. Safety depends on strict collateral valuation, clear LTV/threshold rules, e deterministic repayment checks. A pratico lending model should define: - col..."
        },
        {
          "path": "courses.solana-nft-standards.description",
          "englishWordCount": 17,
          "excerpt": "Implementa NFT Solana con standard pronti per la produzione: integrita metadata, disciplina collection e comportamenti avanzati programmabili/non trasferibili."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build core NFT functionality con standards-compliant metadata, collection verification, e deterministic asset-state handling."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[0].content",
          "englishWordCount": 78,
          "excerpt": "NFT architecture on Solana combines token mechanics con metadata e collection semantics. A correct implementation requires more than minting a token con supply one. Core components include: - mint/state ownership correct..."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implement avanzato NFT behaviors (soulbound e programmable flows) con explicit policy controls e safe update semantics."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[0].content",
          "englishWordCount": 72,
          "excerpt": "Avanzato NFT features introduce policy complexity that must be explicit. Soulbound behavior, programmable restrictions, e dynamic metadata updates all expand failure surface. Per soulbound models, non-transferability mus..."
        },
        {
          "path": "courses.solana-cpi-patterns.description",
          "englishWordCount": 16,
          "excerpt": "Padroneggia composizione CPI su Solana con validazione account sicura, disciplina signer PDA e pattern deterministici di orchestrazione multi-programma."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build CPI fundamentals con strict account/signer checks, ownership validation, e safe PDA signing boundaries."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[0].content",
          "englishWordCount": 86,
          "excerpt": "Invocazione tra Programmi (CPI) is where Solana composability becomes pratico e where many sicurezza failures appear. The caller controls account lists, so every CPI boundary must be treated as untrusted input. Safe CPI ..."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Compose avanzato multi-program flows con atomicity awareness, consistency checks, e deterministic failure handling."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[0].content",
          "englishWordCount": 88,
          "excerpt": "Multi-program composition introduces sequencing e consistency risk. Even when each CPI call is correct in isolation, combined flows can violate business invariants if ordering or rollback assumptions are weak. Robust com..."
        },
        {
          "path": "courses.solana-mev-strategies.description",
          "englishWordCount": 19,
          "excerpt": "Ingegneria di ordinamento transazioni orientata alla produzione su Solana: routing MEV-aware, strategia bundle, modellazione liquidazione/arbitraggio e controlli di esecuzione a tutela utente."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Understand MEV mechanics e transazione ordering realities, then model opportunities e risks con deterministic safety-aware policies."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[0].content",
          "englishWordCount": 162,
          "excerpt": "Maximal Extractable Value (MEV) on Solana is fundamentally about transazione ordering under limited blockspace. Whether you are building trading tools, liquidation infrastructure, or user-facing apps, you need a realisti..."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Progettazione avanzato ordering/bundle strategies con explicit risk controls, failure handling, e user-impact guardrails."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[0].content",
          "englishWordCount": 123,
          "excerpt": "Avanzato transazione-ordering strategies require disciplined orchestration, not just faster opportunity scans. Bundle-oriented execution is valuable because it can express dependency sets e all-or-nothing intent, but bun..."
        },
        {
          "path": "courses.solana-deployment-cicd.description",
          "englishWordCount": 16,
          "excerpt": "Ingegneria di deployment produzione per programmi Solana: strategia ambienti, release gating, controlli qualita CI/CD e workflow operativi upgrade-safe."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Model environment-specific distribuzione behavior con deterministic configs, artifact checks, e release preflight validation."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[0].content",
          "englishWordCount": 132,
          "excerpt": "Solana distribuzione is not one command; it is a release system con environment-specific risk. Localnet, devnet, e mainnet each serve different validation goals, e production quality depends on using them intentionally. ..."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Build CI/CD pipelines that enforce build/test/sicurezza gates, compatibility checks, e controlled rollout/rollback evidence."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[0].content",
          "englishWordCount": 116,
          "excerpt": "CI/CD per Solana should enforce release quality, not just automate command execution. A pratico pipeline includes staged gates: 1) static quality gate (lint/type/sicurezza checks), 2) deterministic unit/integration tests..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.description",
          "englishWordCount": 18,
          "excerpt": "Costruisci integrazioni cross-chain piu sicure su Solana con messaggistica stile Wormhole, verifica attestations e controlli deterministici dello stato bridge."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].content",
          "englishWordCount": 133,
          "excerpt": "Cross-chain messaging is a trust-boundary problem before it is a transport problem. In Wormhole-style systems, messages are observed, attested, e consumed across different chain environments, each con independent failure..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement asset-bridging patterns con strict supply/accounting invariants, replay protection, e reconciliation workflows."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Token bridging requires strict supply e state invariants. Lock-e-mint e burn-e-mint models both rely on one central rule: represented supply across chains must remain coherent. Critical controls include: - single-consume..."
        },
        {
          "path": "courses.solana-oracle-pyth.description",
          "englishWordCount": 17,
          "excerpt": "Integra feed oracle Solana in sicurezza: validazione prezzo, policy confidence/staleness e aggregazione multi-source per decisioni di protocollo resilienti."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand oracle data semantics (price, confidence, staleness) e enforce deterministic validation before business logic."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[0].content",
          "englishWordCount": 110,
          "excerpt": "Oracle integration is a risk-control problem, not a data-fetch problem. Price feeds must be evaluated per freshness, confidence, e contextual fitness before they drive protocol decisions. A safe oracle validation pipelin..."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Progettazione multi-oracle aggregation e consensus policies that reduce single-source failure risk while remaining explainable e testable."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Multi-oracle aggregation reduces single-point dependency but adds policy complexity. The goal is not to average blindly; it is to produce a robust decision value con clear confidence in adverse conditions. Common strateg..."
        },
        {
          "path": "courses.solana-dao-tooling.description",
          "englishWordCount": 17,
          "excerpt": "Costruisci sistemi DAO production-ready su Solana: governance proposte, integrita del voto, controlli tesoreria e workflow deterministici di esecuzione/reporting."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Implement governance mechanics con explicit proposal lifecycle rules, voting-power logic, e deterministic state transitions."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[0].content",
          "englishWordCount": 106,
          "excerpt": "DAO governance architecture is a system of enforceable process rules. Proposal creation, voting, e execution must be deterministic, auditable, e resistant to manipulation. A robust governance model defines: 1) proposal l..."
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Engineer treasury e execution tooling con policy gates, timelock safeguards, e auditable automation outcomes."
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[0].content",
          "englishWordCount": 106,
          "excerpt": "DAO treasury management is where governance intent becomes real financial action. Treasury tooling must therefore combine flexibility con strict policy constraints. Core controls include: - spending limits e role-based a..."
        },
        {
          "path": "courses.solana-gaming.description",
          "englishWordCount": 19,
          "excerpt": "Costruisci sistemi di gioco on-chain production-ready su Solana: modelli stato efficienti, integrita turno, controlli fairness ed economia scalabile della progressione giocatore."
        },
        {
          "path": "courses.solana-gaming.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Progettazione game state e turn logic con deterministic transitions, storage efficiency, e anti-cheat validation boundaries."
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[0].content",
          "englishWordCount": 133,
          "excerpt": "On-chain game progettazione on Solana is a systems-engineering tradeoff between fairness, responsiveness, e cost. The best designs keep critical rules verifiable while minimizing expensive state writes. Core architecture..."
        },
        {
          "path": "courses.solana-gaming.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement fairness-oriented randomness e integrity controls that keep gameplay auditable e dispute-resistant."
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Randomness is one of the hardest fairness problems in blockchain games because execution is deterministic. Robust designs avoid naive pseudo-randomness tied directly to manipulable context. Pratico fairness patterns incl..."
        },
        {
          "path": "courses.solana-permanent-storage.description",
          "englishWordCount": 19,
          "excerpt": "Integra storage decentralizzato permanente con Solana tramite workflow stile Arweave: content addressing, integrita manifest e accesso dati verificabile a lungo termine."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand permanent-storage architecture e build deterministic linking between Solana state e external immutable content."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[0].content",
          "englishWordCount": 119,
          "excerpt": "Permanent storage integration is a data durability contract. On Solana, storing full content on-chain is often impractical, so systems rely on immutable external storage references anchored by on-chain metadata. A robust..."
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Work con manifests, verification pipelines, e cost/prestazioni controls per reliable long-lived data serving."
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[0].content",
          "englishWordCount": 96,
          "excerpt": "Manifests turn many stored assets into one navigable root, but they introduce their own integrity responsibilities. A manifest is only trustworthy if path mapping e referenced content IDs are validated consistently. Key ..."
        },
        {
          "path": "courses.solana-staking-economics.description",
          "englishWordCount": 16,
          "excerpt": "Comprendi staking ed economia validator Solana per decisioni reali: strategia delega, dinamica reward, effetti commissione e sostenibilita operativa."
        },
        {
          "path": "courses.solana-staking-economics.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Impara native staking mechanics con deterministic reward modeling, validatore selection criteria, e delegation risk framing."
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[0].content",
          "englishWordCount": 108,
          "excerpt": "Solana staking economics is an incentives system connecting delegators, validatori, e network sicurezza. Good delegation decisions require more than chasing headline APY. Delegators should evaluate: 1) validatore prestaz..."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Analyze validatore-side economics, operational cost pressure, e incentive alignment per long-term network health."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Validatore economics balances revenue opportunities against operational costs e reliability obligations. Sustainable validatori optimize per long-term trust, not short-term extraction. Revenue sources include inflation r..."
        },
        {
          "path": "courses.solana-account-abstraction.description",
          "englishWordCount": 16,
          "excerpt": "Implementa pattern smart-wallet/account abstraction su Solana con autorizzazione programmabile, controlli recupero e validazione transazioni policy-driven."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build smart-wallet fundamentals including multisig e social-recovery designs con clear trust e failure boundaries."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Account abstraction on Solana shifts control from a single key to programmable policy. Smart wallet can enforce richer authorization logic, but policy complexity must be managed carefully. A robust smart-wallet progettaz..."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement programmable validation policies (limits, allowlists, time/risk rules) con deterministic enforcement e auditability."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Programmable validation is where smart wallet deliver real value, but it is also where subtle policy bugs appear. Typical controls include spending limits, destination allowlists, time windows, e risk-score gates. These ..."
        },
        {
          "path": "courses.solana-pda-mastery.description",
          "englishWordCount": 18,
          "excerpt": "Padroneggia ingegneria avanzata PDA su Solana: design schema seed, disciplina bump e uso sicuro cross-program dei PDA su scala produzione."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Build strong PDA foundations con deterministic derivation, canonical seed composition, e collision-resistant namespace strategy."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[0].content",
          "englishWordCount": 114,
          "excerpt": "Indirizzi Derivati dal Programma (PDAs) are deterministic authority e state anchors on Solana. Their power comes from predictable derivation; their risk comes from inconsistent seed discipline. A strong PDA progettazione..."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement avanzato PDA patterns (nested/counter/stateful) while preserving sicurezza invariants e migration safety."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[0].content",
          "englishWordCount": 102,
          "excerpt": "Avanzato PDA patterns solve real scaling e composability needs but increase progettazione complexity. Nested PDAs, counter-based PDAs, e multi-tenant PDA namespaces each require explicit invariants around uniqueness, lif..."
        },
        {
          "path": "courses.solana-economics.description",
          "englishWordCount": 17,
          "excerpt": "Analizza dinamiche economiche Solana in contesto produzione: interazione inflation/fee-burn, flussi staking, movimento supply e tradeoff di sostenibilita protocollo."
        },
        {
          "path": "courses.solana-economics.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand Solana macro token economics (inflation, burn, rewards, fees) con deterministic scenario modeling."
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[0].content",
          "englishWordCount": 112,
          "excerpt": "Solana economics is the interaction of issuance, burn, staking rewards, e usage demand. Sustainable protocol decisions require understanding these flows as a system, not isolated metrics. Core mechanisms include: 1) infl..."
        },
        {
          "path": "courses.solana-economics.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Model token flow dynamics e sustainability signals using supply categories, unlock events, e behavior-driven liquidity effects."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[0].content",
          "englishWordCount": 115,
          "excerpt": "Token flow analysis turns abstract economics into operational insight. The key is to track where tokens are (staked, circulating, locked, treasury, pending unlock) e how they move over time. Useful flow metrics include: ..."
        }
      ],
      "totals": {
        "exactEnglishCount": 942,
        "englishLikeCount": 456
      }
    },
    {
      "locale": "de",
      "exactEnglishMatches": [
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].options[0]",
          "text": "To calculate NFT metadata size"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].options[2]",
          "text": "To compress signatures on mobile wallets"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "It is the user who paid the creation fee forever"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "What does `executable: true` indicate?"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].options[1]",
          "text": "Token balances are program-specific state managed by the token program"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "This is your active signer public key."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "Pattern only; actual value depends on wallet funding."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[1]",
          "text": "Convert SOL to lamports using 1_000_000_000 multiplier."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[0].options[0]",
          "text": "It has a wallet signature on every slot"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[0]",
          "text": "A client-only simulation mode"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[1]",
          "text": "Calling one on-chain program from another on-chain program"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[2]",
          "text": "A validator-level rent optimization flag"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].prompt",
          "text": "Why are PDAs useful?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].options[0]",
          "text": "They let programs derive deterministic addresses without private keys"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].options[0]",
          "text": "Any wallet holding SOL"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].options[1]",
          "text": "The runtime on behalf of the program when invoke_signed seeds match"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].prompt",
          "text": "What happens if you change a seed?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[0]",
          "text": "The PDA stays the same but bump changes"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[2]",
          "text": "You derive a different PDA address"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].explanation",
          "text": "Seed bytes are part of the hash input, so any change yields a different derived address."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "A compressed NFT ledger entry"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[2].prompt",
          "text": "What authority controls minting?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].title",
          "text": "Wallet Manager CLI-sim"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[0]",
          "text": "Parse flags in pairs: --key value."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[2]",
          "text": "Construct JSON object in fixed key order before JSON.stringify."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does Anchor generate automatically from your program definitions?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Automatic PDA funding from devnet faucets"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A JSON interface used by clients/tests/tooling to call your program correctly"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "A private key format used only by on-chain programs"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is a seeds constraint verifying?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "That a token mint has 9 decimals"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].prompt",
          "text": "Why is a PDA considered off-curve?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].options[0]",
          "text": "It is derived to avoid having a corresponding private key"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].explanation",
          "text": "Off-curve means no user-held private key exists; programs authorize via seed proofs."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].prompt",
          "text": "What breaks if you change one PDA seed value?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[1]",
          "text": "Only the bump changes while address stays fixed"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[2]",
          "text": "Nothing changes unless RPC endpoint changes"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].explanation",
          "text": "PDA derivation is seed-sensitive. Any seed change creates a different address namespace."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].title",
          "text": "Initialize Counter PDA (deterministic)"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[0]",
          "text": "Use a deterministic hash-like reducer over programId + authorityPubkey + static seed."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[0]",
          "text": "Represent state as a pure JS structure so increment can be deterministic in tests."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[1]",
          "text": "Return a new state object from applyIncrement; avoid mutating the input object in-place."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Validator gossip propagation speed"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the main role of optional integration tests?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Validate network execution paths after deterministic logic is proven"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Replace all unit tests"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Avoid asserting exact outputs"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Integration tests add runtime confidence but should not replace deterministic core checks."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do simulation failures happen even before final send succeeds?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Because the wallet signature always expires immediately"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because fee payer is irrelevant"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[0]",
          "text": "Compose the checkpoint from deterministic helper functions to keep output stable."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Where do SPL token balances actually live?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why keep raw amounts as integer strings in model code?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Because wallets only accept strings"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because decimals are always 9"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "Show pending overlays first, mutate durable balances only after stronger confirmation"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[2]",
          "text": "Disable activity feed until finalized"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "Optimistic overlays are useful, but confirmed state must remain authoritative."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].options[2]",
          "text": "Because commitment levels require it by protocol"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Phase-specific metrics enable actionable incident diagnosis."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is ordering by (ts, id) preferred over timestamp-only replay?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Stable ordering prevents environment-dependent state divergence."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should happen when the same event id arrives twice?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Idempotency guarantees deterministic behavior under retries."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[0]",
          "text": "Sort by (ts, id) before applying events."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[1]",
          "text": "Deduplicate by event id before snapshot interval checks."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[2]",
          "text": "Build checksum from stable snapshot metadata, not random values."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[0]",
          "text": "Use fixed-scale integers (micro USD) instead of floating point."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[1]",
          "text": "Apply filter -> search -> sort in a deterministic order."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "To reduce CSS size only"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because rate limits require it"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the main risk of generic one-size-fits-all error banners?"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Users cannot distinguish recovery actions across failure classes"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "They always break hydration"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Which metric should drive route selection at execution size?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Deterministic outAmount from full route simulation"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Displayed ticker price only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Lowest hop count only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Route quality is output-at-size, not headline spot labels."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does slippage tolerance directly determine?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "The minOut acceptance bound"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the deterministic minOut formula?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "minOut is a bounded percentage reduction from outAmount."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Why keep per-hop fee breakdowns?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Per-hop fee attribution makes route behavior auditable."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Minimize hop count always"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Choose first enumerated route"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "Why simulate virtual reserves per candidate route?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Virtual simulation avoids shared-state contamination."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].content",
          "text": "# Implement token/pool model + constant-product quote calc Implement deterministic CPMM quoting: - out = (reserveOut * inAfterFee) / (reserveIn + inAfterFee) - fee = floor(inAmount * feeBps / 10000) - impactBps from spot..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].hints[0]",
          "text": "Use inAfterFee = inAmount - floor(inAmount * feeBps / 10000)."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].hints[2]",
          "text": "Keep sorting deterministic to avoid route flicker."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[0]",
          "text": "Use virtual pool copies so fixture reserves are not mutated."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[2]",
          "text": "Return structured errors when pools or route links are invalid."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].prompt",
          "text": "What should happen when quote freshness expires?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].options[2]",
          "text": "Increase slippage automatically without notifying user"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Freshness boundaries should trigger deterministic recomputation."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which failures are not solved by blind retries?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].explanation",
          "text": "Planner errors require input/route changes, not repetition."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[0]",
          "text": "Keep output key order stable: swapPlan first, swapSummary second."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[1]",
          "text": "Path should be deterministic symbols along route hops."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[2]",
          "text": "Include fixtureHash + modelVersion under determinism metadata."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because owner checks improve rendering speed"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Because owner checks replace signer checks"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Only that an amount field exists"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the purpose of trace hashing in an audit workflow?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].options[1]",
          "text": "To replace structured test assertions"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Which sequence represents a valid evidence chain?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "Reproduce -> trace -> impact -> fix -> verify"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[1]",
          "text": "Fix -> reproduce -> trace -> release"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Accepting any PDA-like prefix"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Trusting client-provided bump values"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Deterministic re-derivation closes spoofable PDA substitution paths."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Because most exploitable bugs only appear under malformed or adversarial input"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Because traces are optional without them"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[0]",
          "text": "Compute drained lamports from recipient before/after."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[1]",
          "text": "Include deterministic field ordering in the JSON output."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[2]",
          "text": "The explanation should mention missing signer/owner validation."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].hints[2]",
          "text": "Keep output key order stable."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[1]",
          "text": "Use fixedBlockedExploit to set blocked status."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[2]",
          "text": "Return error code only when blocked is true."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].options[1]",
          "text": "They are interchangeable labels"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Good reports separate damage potential from exploit feasibility."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which recommendation is most actionable?"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[0]",
          "text": "Return stable, minimal checkpoint metadata."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[2]",
          "text": "Preserve scenarioIds order as provided."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why generate an offline deterministic launch pack before devnet/mainnet actions?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should supply checks use integer math instead of floating-point UI values?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "To avoid rounding drift in launch invariants"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Because decimals are always zero"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the primary role of freeze authority?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[0]",
          "text": "It can materially change effective fee behavior across transfer sizes"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "It is ignored once mint is initialized"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is a core risk of permanent delegate configuration?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Privilege concentration if authority governance is weak"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].hints[2]",
          "text": "Keep output key order stable so checkpoint tests are reproducible."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].hints[1]",
          "text": "Append extension steps in deterministic order so plan labels are stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[0]",
          "text": "Transfer fee formula: fee = min(maxFee, floor(amount * feeBps / 10000))."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[2]",
          "text": "Fail when distributed amount exceeds initial supply."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is parameter closure required before execution?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Single-source configuration prevents mismatched launch behavior."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the purpose of hard stop launch criteria?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "To halt execution when invariants or authority assumptions fail"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Hard stop rules prevent progressing through unsafe operational states."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[0]",
          "text": "Keep checkpoint JSON key ordering fixed so output is stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[2]",
          "text": "Include determinism metadata (fixtures hash + encoding version) in the final object."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[0]",
          "text": "Add validation before returning the formatted string."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[1]",
          "text": "instructionCount should be treated as a number but returned as text."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].content",
          "text": "# Write a Counter Program Bankrun Test Implement a helper that returns the expected counter value after a sequence of increment operations. This mirrors a deterministic assertion you would use in a Bankrun test. Return t..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[0]",
          "text": "Use Array.reduce to sum increments."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[2]",
          "text": "Convert final number to string before returning."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the primary source of event data on Solana?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Explicit event topics like EVM"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is idempotency important in indexing?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "To prevent duplicate events during replays or forks"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "To improve RPC response times"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "As little-endian u64, then divided by 10^decimals"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[1].note",
          "text": "Inner CPI call at depth 2"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Success bubbles up from inner to outer"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[0]",
          "text": "Parse log entries to identify event types"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[1]",
          "text": "Extract fields using regex patterns"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It provides stable ordering during concurrent writes"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Cursor-based pagination handles concurrent writes without missing or duplicating entries."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What enables indexer recovery after crashes?"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Periodic checkpointing of last processed position"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Re-indexing from genesis on every start"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Caching all data in memory"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Checkpoints allow indexers to resume from the last known good position."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].hints[0]",
          "text": "Aggregate events by wallet address"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].hints[3]",
          "text": "Include metadata like timestamps"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the purpose of SPL Memo in payments?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What should never be included in a memo?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Memos are public on-chain; sensitive data should be hashed or kept off-chain."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[0]",
          "text": "Use base58 alphabet to validate the recipient address format."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[2]",
          "text": "Generate an idempotency key if not provided in the input."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].hints[2]",
          "text": "Key order matters: SOL transfer needs [from, to], SPL transfer needs [source, mint, dest, owner]."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Different key orders produce different signatures"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Canonicalization ensures consistent serialization so signatures match regardless of object construction order."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Initial state after intent creation"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Payment complete, generate receipt"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[0]",
          "text": "HMAC-SHA256: H(key, message) = SHA256((key XOR outer_pad) || SHA256((key XOR inner_pad) || message))"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[1]",
          "text": "Use constant-time comparison to prevent timing attacks on signature verification."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[2]",
          "text": "Verify the timestamp is recent (within 5 minutes) to prevent replay attacks."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a Merkle root commit to?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The tree depth only"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[0]",
          "text": "Start by validating the leaf index is within bounds."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[1]",
          "text": "At each level, find the sibling node (left or right of current)."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[3]",
          "text": "Traverse up to the root, collecting all updated node hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[4]",
          "text": "Use deterministic ordering: left hash comes before right hash."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].prompt",
          "text": "What determines concatenation order during verification?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[0]",
          "text": "The leaf index bits at each level"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[1]",
          "text": "The size of the sibling hashes"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[2]",
          "text": "The tree root hash"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].explanation",
          "text": "Each bit of the leaf index determines if the current hash goes left or right in the concatenation."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[1].explanation",
          "text": "log2(1024) = 10, so proofs contain 10 sibling hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[0]",
          "text": "To generate a proof, collect the sibling hash at each level from leaf to root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[1]",
          "text": "The sibling is at index+1 if current is left, index-1 if current is right."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[3]",
          "text": "Use the same ordering (left || right) when combining hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[4]",
          "text": "The proof is valid if the recomputed root matches the stored root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do old proofs fail after tree updates?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "The root changes when leaves are added/modified"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "The proof format changes"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "The leaf hashes are encrypted"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Adding leaves changes parent hashes up to the root, invalidating previous proofs."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "How can metadata attacks be prevented?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Hash verification against leaf commitments"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Using shorter metadata URIs"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Verifying metadata hashes ensures the off-chain data matches the on-chain commitment."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[0]",
          "text": "Validate the mint request has all required fields (leafIndex, nftId, owner)."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[2]",
          "text": "Insert the leaf by computing hashes up to the root, collecting sibling hashes as proof."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the purpose of a timelock in governance?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What determines voting power in most DAOs?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Token balance at snapshot block"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Voting power is typically proportional to token holdings at a specific snapshot time."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Anyone can trigger execution"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].content",
          "text": "# Challenge: Implement quorum/voting state machine Build a deterministic voting system: - Calculate vote weights from token balances - Check quorum requirements - Determine pass/fail based on thresholds - Handle abstenti..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[1]",
          "text": "Check if totalVoteWeight >= quorumThreshold to determine quorumMet."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[2]",
          "text": "Calculate support percentage as forWeight / (forWeight + againstWeight) when there are non-abstain votes."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does 2-of-3 multisig mean?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].options[0]",
          "text": "2 signatures required from 3 possible signers"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why track approvals on-chain?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[1]",
          "text": "Process actions in order - each action updates the signer's status."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[2]",
          "text": "Track the cumulative approved weight to compare against threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[3]",
          "text": "A proposal is 'approved' when approvedWeight >= threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[4]",
          "text": "A proposal is 'rejected' when no pending signers remain but threshold is not met."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "What is a replay attack in multisig systems?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Sending duplicate approval requests"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].hints[0]",
          "text": "First validate the proposal status is 'approved'."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The network automatically extends the limit"
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].hints[2]",
          "text": "Each byte of data adds 10 compute units."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Lower fees, higher throughput"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[0]",
          "text": "Sort fields by size (largest first) to minimize padding gaps."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[1]",
          "text": "Consider if u64 fields can be reduced to u32 based on maxValue."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[2]",
          "text": "Boolean flags can be packed into a single byte as bit flags."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[3]",
          "text": "Calculate bytes saved as originalSize - optimizedSize."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of setComputeUnitPrice?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Enable additional program features"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why request specific compute unit limits?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "Optimizing without profiling or evidence of need"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Premature optimization wastes effort on theoretical rather than measured bottlenecks."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[0]",
          "text": "Compute savings by subtracting 'after' from 'before' metrics."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[1]",
          "text": "Use approximate conversion: 1 SOL = $20, 1 SOL = 1,000,000,000 lamports."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why must native SOL be wrapped before swapping?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Native SOL cannot be transferred on Solana"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Solana automatically creates the ATA"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The tokens are sent to the system program"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is 50 basis points of slippage on a 1,000,000 output?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why should minOutAmount use BigInt instead of floating point?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Floating point introduces rounding errors in token amounts"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "BigInt is faster than floating point"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Single-hop direct route"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Total execution cost includes fees + impact"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[0]",
          "text": "Use BigInt arithmetic to avoid floating point errors when computing minOutAmount."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[1]",
          "text": "Slippage in basis points: minOut = outAmount - (outAmount * slippageBps / 10000)."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[3]",
          "text": "The priceImpactPct comes directly from the quote response."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].hints[0]",
          "text": "Define a TRANSITIONS map: each key is a state, each value maps event names to next states."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "They reduce the number of required signatures"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Retryable — get fresh blockhash"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[0]",
          "text": "Use BigInt to sum fee amounts across all route legs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[1]",
          "text": "Effective price = outAmount / inAmount, formatted to 9 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the main advantage of CLMMs over constant product AMMs?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Capital efficiency — LPs concentrate liquidity where trades happen"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "CLMMs allow LPs to allocate capital to specific price ranges, dramatically improving capital efficiency compared to spreading liquidity across all prices."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs use ticks to discretize the price space?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "To reduce the number of tokens in the pool"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs store sqrtPrice instead of price directly?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "It simplifies the AMM math — token amounts become linear in sqrtPrice"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "It uses less storage space on-chain"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Price within range, position is active"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "All SOL was sold as price rose through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Position reactivates when price returns to range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "All USDC was sold as price fell through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[0]",
          "text": "Price at a tick index = 1.0001^tickIndex. Use Math.pow(1.0001, tick)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[1]",
          "text": "Reverse conversion: tick = round(ln(price) / ln(1.0001))."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[2]",
          "text": "sqrtPriceX64 = BigInt(round(sqrt(price) * 2^64)) — Solana CLMM uses Q64.64 fixed-point."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[3]",
          "text": "Tick spacing alignment: floor(tick / spacing) * spacing."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[0]",
          "text": "Convert ticks to prices: lowerPrice = 1.0001^lowerTick, upperPrice = 1.0001^upperTick."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[2]",
          "text": "Fees only accrue when the position is in range. fee = floor(volumePerPeriod * feeRate)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[3]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[4]",
          "text": "Current status is based on the last price in the path relative to the range."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the main tradeoff of using a tight price range?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Lower fees but less impermanent loss"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "More tokens required to open the position"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When should an LP consider a full-range (all ticks) position?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "JavaScript Number cannot safely represent 128-bit integers"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "sqrtPriceX64 is a u128 value that can exceed JavaScript's Number.MAX_SAFE_INTEGER (2^53 - 1). BigInt provides arbitrary precision integer arithmetic."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "They are rejected by the program"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Floor division rounds toward negative infinity: floor(-100/64) = -2, so -100 aligns to -2 * 64 = -128. This is correct CLMM behavior."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[1]",
          "text": "Status is 'in-range' if lowerPrice <= currentPrice <= upperPrice."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[3]",
          "text": "IL formula: lpValue = sqrt(priceRatio) + sqrt(1/priceRatio); compare to holdValue = 2*sqrt(priceRatio)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[4]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimals."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a utilization ratio of 80% mean?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "80% of supplied assets are currently borrowed"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "80% of borrowers have been liquidated"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The pool has 80% of its maximum capacity"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Utilization = totalBorrowed / totalSupply. At 80%, four-fifths of all deposited assets are currently lent out to borrowers."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does the reserve factor affect supplier yield?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "It reduces supplier yield by skimming a percentage of borrow interest"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It increases supplier yield by adding protocol subsidies"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "It has no effect on supplier yield"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "The reserve factor takes a cut of borrow interest before distributing the rest to suppliers, reducing their effective APY."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What happens to borrow rates when utilization exceeds the kink?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "They increase steeply according to slope2"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "They remain constant at the kink rate"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "They decrease to attract more borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is the supply rate always lower than the borrow rate?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The protocol subsidizes borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Supply rates are fixed by governance"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Only 20% buffer remaining — consider adding collateral"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[0]",
          "text": "Utilization = totalBorrowed / totalSupply. Handle the zero-supply edge case."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[1]",
          "text": "Below kink: borrowRate = baseRate + (utilization/kink) * slope1."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[2]",
          "text": "Above kink: borrowRate = baseRate + slope1 + ((util - kink)/(1 - kink)) * slope2."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[3]",
          "text": "Supply rate = borrowRate * utilization * (1 - reserveFactor)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[1]",
          "text": "Effective threshold = weighted average of liquidationThreshold by collateral value."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[2]",
          "text": "Health factor = (collateralValue * effectiveThreshold) / borrowValue."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[3]",
          "text": "Max additional borrow = max(0, collateralValue * threshold - currentBorrow)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of the liquidation bonus?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It incentivizes liquidators to repay debt by offering collateral at a discount"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When does bad debt occur in a lending protocol?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "When collateral value is insufficient to cover outstanding debt after liquidation"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "When the reserve factor is set too high"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "When utilization drops below the kink"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "To be conservative — using (price - confidence) prevents over-valuing collateral during uncertainty"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Confidence intervals make prices more accurate"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should a protocol do when all oracle feeds are stale?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "Use the last known price regardless of age"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Estimate the price from on-chain DEX data"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[2]",
          "text": "Track the worst health factor across all scenarios."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[3]",
          "text": "Count how many scenarios result in isLiquidatable: true."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do perpetual futures protocols use a mark price instead of the last-traded price?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Mark price smooths out manipulation by incorporating oracle data, preventing artificial liquidations"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Mark price is cheaper to compute on-chain"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Last-traded price is not available on Solana"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Mark price incorporates the oracle price as a stability anchor. Using last-traded price alone would allow a single large trade to trigger cascading liquidations through price manipulation."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Weighted average: (8 * 20 + 2 * 30) / 10 = (160 + 60) / 10 = $22.00. The entry price shifts toward the new fill price proportional to the additional size."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "When the perpetual mark price is above the oracle (spot) price, who pays funding?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Longs pay shorts — the positive premium makes long positions expensive to hold"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Both sides pay the protocol a fee"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "A 10 SOL-PERP position at $25 entry faces a 0.01% funding rate. What is the per-period payment?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "text": "Funding payment = size * entryPrice * rate = 10 * 25 * 0.0001 = $0.025 per funding interval."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Position snapshot at current mark price"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Long PnL = size * (mark - entry)"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Positive rate: longs pay funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "True return includes funding drag"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[0]",
          "text": "Long PnL = size * (markPrice - entryPrice). Short PnL = size * (entryPrice - markPrice)."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[1]",
          "text": "Notional value = size * markPrice — represents the total position value."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[2]",
          "text": "ROE (return on equity) = unrealizedPnL / margin * 100."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[0]",
          "text": "Funding payment per period = size * entryPrice * fundingRate."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[1]",
          "text": "Longs pay when rate is positive (totalFunding -= payment). Shorts receive."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[2]",
          "text": "Average funding rate = sum(rates) / count."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[3]",
          "text": "Net margin impact = (totalFunding / margin) * 100, as a percentage."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is the maintenance margin rate set above zero?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "What causes a cascading liquidation spiral?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Forced position closes push the price further, triggering more liquidations in a feedback loop"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Too many traders opening positions at the same time"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Oracle prices updating too slowly"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "text": "When liquidation engines close positions by selling into the market, the selling pressure moves the price further against remaining positions, triggering their liquidations too — a self-reinforcing feedback loop."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should position size always be stored as a positive number?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Positive numbers use less storage space"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "A long position has a positive funding rate of 0.01%. What happens to the trader's balance?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The balance decreases — longs pay when the funding rate is positive"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The balance increases — longs receive positive funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Nothing — funding only affects shorts"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Positive funding rate means the perp is trading above spot. Longs pay shorts to discourage the long-heavy imbalance. The long trader's effective margin decreases by the funding payment amount."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[0]",
          "text": "Effective margin = initial margin + unrealized PnL + funding payments."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[1]",
          "text": "Margin ratio = effectiveMargin / notionalValue."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[3]",
          "text": "Generate alerts based on margin ratio vs maintenance margin rate thresholds."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[4]",
          "text": "Sort alerts by severity: CRITICAL > WARNING > INFO."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How is the priority fee calculated in lamports?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "The CU price is denominated in micro-lamports per CU. Dividing by 1,000,000 converts micro-lamports to lamports. The ceiling function ensures rounding up to the nearest lamport."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is setting the CU limit to exactly the simulated value risky?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The runtime does not accept exact values"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Simulation always underreports CU usage by 50%"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Low compute = minimal priority fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Higher compute increases priority cost proportionally"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "High CU + high priority = significant fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[1]",
          "text": "Cap compute unit limit at 1,400,000 (Solana max)."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[2]",
          "text": "Priority fee = ceil(computeUnitLimit * computeUnitPrice / 1_000_000) in lamports."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[3]",
          "text": "Total fee = base fee (5000 lamports) + priority fee."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].hints[3]",
          "text": "Recommend 'legacy' if fits without LUT, 'use-existing-lut' if LUT helps enough, 'create-new-lut' if still too large."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "When the blockhash has expired or pool state has changed"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Whenever any error occurs"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Only when the user manually clicks retry"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add random jitter to retry delays?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To make the delay shorter on average"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Jitter is required by the Solana protocol"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Without jitter, all clients using the same backoff formula would retry simultaneously, creating thundering herd problems on the RPC infrastructure."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Slippage exceeded -> actionable message"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Balance error -> show exact shortfall"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[1]",
          "text": "Fee estimates: low = 100 microlamports/CU, medium = 1000, high = 10000."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[2]",
          "text": "Retry policy: 3 retries, 500ms base delay, 2x backoff, always refresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[3]",
          "text": "Use the same CU calculation: ceil(totalCU * 1.1) capped at 1,400,000."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What enables persistent dApp-to-wallet communication on Android?"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Foreground services maintaining a session channel"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Deep links passed between applications"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Shared local storage between apps"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why can't iOS maintain persistent wallet sessions like Android?"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "iOS suspends app execution on background transitions, preventing persistent channels"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "iOS wallets do not support Solana"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "iOS uses a different blockchain protocol"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "iOS does not allow arbitrary background processes or persistent inter-app communication. When the user switches apps, the dApp's execution context is suspended."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What should you do before showing any wallet connection UI?"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Detect available connection methods (MWA, deep links, QR)"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Immediately open the default wallet"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "Capability detection ensures you only present connection methods that are actually available on the user's device."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Display a clear message asking the user to switch their wallet's network"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Request sent via MWA session or deep link"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "User decision - timing is unpredictable"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[3]",
          "text": "Generate a requestId from type + payload prefix if not provided."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[0]",
          "text": "Process actions sequentially: each action modifies the session state."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[3]",
          "text": "Expire check clears session if current time >= expiresAt."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "As raw lamports or smallest unit values"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Raw simulation logs from the RPC response"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].title",
          "text": "Retry State Machine Flow"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "User action triggers request construction"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Request sent to wallet via MWA or deep link"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Wallet app may have been closed or crashed"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[0]",
          "text": "Count requests by status: 'signed' = success, 'rejected'/'timeout'/'error' = failure."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[2]",
          "text": "Session duration = sessionEnd - sessionStart in seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "solana:<recipient> (single colon, no slashes)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "solana://<recipient> (double slashes like HTTP)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "pay:<recipient> (custom pay scheme)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "When the amount exceeds 100 SOL"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How does the reference parameter enable payment tracking?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "It creates a webhook that notifies the merchant"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What amount value represents 2.5 USDC in a Solana Pay URL?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "amount=2.5 (human-readable decimal)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "text": "Solana Pay URLs use human-readable decimal amounts. The wallet handles the conversion to raw units based on the token's decimal configuration."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Native SOL transfer — no spl-token parameter"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[0]",
          "text": "Solana Pay URL format: solana:<recipient>?amount=<amount>&spl-token=<mint>&reference=<ref>&label=<label>&message=<msg>"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[1]",
          "text": "Validate recipient: must be 32-44 characters of valid base58."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[2]",
          "text": "Amount must be a positive finite number."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[0]",
          "text": "Track state transitions: pending -> found -> confirmed -> finalized."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[1]",
          "text": "The 'found' event sets the signature. 'confirmation' increments the counter."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[2]",
          "text": "Timeout check expires the reference if still pending after expiryTimeout seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[3]",
          "text": "Record each state change in the history array."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Confirmed is never sufficient — always use finalized"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What should happen when the payment request expires?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Silently restart the polling loop"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Redirect the customer to a different payment method"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Exponential backoff recovers from transient failures"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Never auto-complete mismatched payments"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Track processed references to prevent double fulfillment"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[0]",
          "text": "Generate receiptId from the last 8 chars of reference + timestamp."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[1]",
          "text": "Reconstruct the Solana Pay URL from payment data."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[2]",
          "text": "Currency is 'SPL' if splToken is present, otherwise 'SOL'."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What should happen when auto-connect fails silently on page load?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Show the connect button without an error message"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Display an error toast telling the user to reconnect"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Redirect the user to a wallet installation page"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Auto-connect is a background optimization. If it fails, the user never initiated the action, so showing an error would be confusing. Simply display the default connect button."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why should you show skeleton UI during the connecting phase?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It makes the page load faster"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "It is required by the Solana wallet adapter standard"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How do you reliably detect which Solana cluster an RPC endpoint is connected to?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Ask the wallet adapter which network it is using"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What must happen to cached data when the network changes?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Only token balances need to be refreshed"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Cached data can be retained since addresses are the same across clusters"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "User clicks Connect, show loading state"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Wallet approved, session active"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[0]",
          "text": "Define a TRANSITIONS map: each state maps event types to next states."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[2]",
          "text": "Error state stores the error message. Disconnected clears all session data."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[2]",
          "text": "DISCONNECT invalidates all non-'global' entries."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[3]",
          "text": "Track invalidation counts per event in the event log."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must cache keys include the network cluster?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "The Solana RPC protocol requires cluster identification"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What does the stale-while-revalidate pattern do when a cache entry is past its TTL?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Blocks until fresh data is fetched from the RPC"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Primary endpoint responding normally"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Latency spike detected, slot behind tip"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Automatic failover to healthy secondary"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Primary recovered, restoring as default"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[1]",
          "text": "Average connect time = total durationMs from CONNECTED events / count."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[2]",
          "text": "Cache hit rate = hits / (hits + misses) * 100."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[3]",
          "text": "RPC health = healthy checks / total checks * 100."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Wallets cannot distinguish sign-in requests from malicious payloads"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "signMessage does not produce valid Ed25519 signatures"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does SIWS prevent replay attacks?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "By requiring a unique, server-generated nonce that is consumed after verification"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must nonces be generated server-side rather than client-side?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Client-generated nonces allow attackers to reuse previously valid nonce-signature pairs"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Client-side random number generators are too slow"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Wallets cannot sign messages containing client-generated nonces"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What format must the domain field use?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Plain domain name without protocol prefix (e.g., example.com)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Canonical text format that gets signed by the wallet"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Wallet renders structured UI from parsed fields"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[0]",
          "text": "Domain should not include protocol (https://). Strip or reject it."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[2]",
          "text": "Address must be 32-44 characters (Solana base58 public key)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[3]",
          "text": "If no statement is provided, default to 'Sign in to <domain>'."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[1]",
          "text": "issuedAt must be <= currentTime (not in the future)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[2]",
          "text": "expirationTime (if present) must be > currentTime."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should session IDs be random tokens rather than wallet addresses?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Wallet addresses are public, so anyone could forge requests using a known address"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Wallet addresses are publicly known. Using them as session IDs would allow anyone who knows a user's address to impersonate their session. Random tokens ensure only the authenticated client can present a valid session."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What should happen when a user disconnects their wallet from a dApp?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The dApp should invalidate the server-side session (treat it as logout)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "The dApp should reconnect the wallet automatically"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Wallet disconnection signals the user's intent to end the interaction. The dApp should respect this by invalidating the session, preventing confusion about authentication state."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Nonce travels: server -> client -> wallet -> signed output"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Atomic SET NX ensures only one request can consume the nonce"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Replay blocked: nonce was already consumed"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[0]",
          "text": "Track used nonces in a map. If a nonce was already used, it's a replay attempt."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[2]",
          "text": "Use an address set to count unique addresses."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does a wide p90 vs p50 spread usually indicate?"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A volatile fee regime where a guard premium may be needed"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "Floor protects small estimates."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Large payload triggers heap recommendation."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[0].content",
          "text": "Implement a deterministic compute budget planner. No RPC calls; operate only on provided input data."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[0]",
          "text": "Use percentile targeting from sorted synthetic fee samples."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[1]",
          "text": "Apply volatility guard if p90 vs p50 spread exceeds policy threshold."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[2].hints[0]",
          "text": "Map risk score bands to processed/confirmed/finalized UX levels."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].hints[1]",
          "text": "Avoid timestamps or random IDs in output."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[4].hints[1]",
          "text": "Checkpoint report should avoid nondeterministic fields."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do users still expect atomic behavior in multi-tx flows?"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because protocols always guarantee it"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Because wallet adapters hide all failures"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].title",
          "text": "Flow Graph Risk Walkthrough"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "No compensation path after swap failure."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Still verify idempotency on each step."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[0].hints[1]",
          "text": "Emit explicit edges from dependency relationships."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[1].hints[1]",
          "text": "Flag non-idempotent steps because retries can break all-or-nothing guarantees."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].content",
          "text": "Encode deterministic failure handling metadata, including compensation state."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].hints[0]",
          "text": "Generate deterministic idempotency keys from stable inputs."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[3].hints[0]",
          "text": "No real Jito calls. Build deterministic data structures only."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].content",
          "text": "Generate a stable markdown flow safety report checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[0]",
          "text": "Render a stable markdown report as the final checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[1]",
          "text": "Keep the PASS/FAIL status deterministic from issue count."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Slippage is user tolerance; impact is market footprint"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They are identical metrics"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Slippage is a user-configured bound, while impact reflects route liquidity response to trade size."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[1].hints[0]",
          "text": "Clamp recommended BPS to policy bounds."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[2].hints[0]",
          "text": "Teach difference: impact is market footprint, slippage is user tolerance."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[3].hints[0]",
          "text": "Map risk grades to deterministic banner copy."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[4].hints[1]",
          "text": "Do not include timestamps or random IDs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "It reduces RPC cost directly"
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[0].hints[1]",
          "text": "Sort by key so output is deterministic across runs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[1].hints[0]",
          "text": "Apply only confirmed-depth events to state."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[0]",
          "text": "Integrity checks must fail on negative balances."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[1]",
          "text": "Finalized keys must always be a subset of applied keys."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].title",
          "text": "RPC failures in real life: timeouts, 429s, stale nodes"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is slot lag important in endpoint scoring?"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Fast responses can still be wrong if the node is stale"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Slot lag only affects validator rewards"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Slot lag is equivalent to timeout"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Latency alone cannot guarantee freshness of chain state."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Fast but less reliable under pressure."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].title",
          "text": "Explorer: retry/backoff simulator"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].title",
          "text": "RPC Multi-Provider Client Project Journey"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[0].hints[0]",
          "text": "Build a deterministic retry schedule including the first attempt."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[1].hints[1]",
          "text": "Tie-break deterministically by endpoint ID."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[2].hints[1]",
          "text": "Use tighter TTL when node lag grows."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].title",
          "text": "Checkpoint: RPC health report export"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].hints[1]",
          "text": "Ensure field order is stable in JSON output."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Alignment inserts padding bytes"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "RPC forces 8-byte packets"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "u64 alignment usually forces padding after smaller fields."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "u32 length + UTF-8 bytes + u8 field"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[0].hints[1]",
          "text": "Struct total size should be aligned to max field alignment."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].title",
          "text": "Challenge: implement borshEncode/borshDecode helpers"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].hints[0]",
          "text": "Borsh strings are length-prefixed little-endian u32 + UTF-8 bytes."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].title",
          "text": "Challenge: zero-copy vs Borsh tradeoff model"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[0]",
          "text": "Model tradeoffs deterministically: read speed vs schema flexibility."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[1]",
          "text": "Recommendation should be pure function of inputs."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[3].hints[0]",
          "text": "Validate byte length before field parsing."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].title",
          "text": "Checkpoint: stable layout report"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should export stable JSON + markdown."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].title",
          "text": "Error taxonomy: recoverable vs fatal"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why are typed error codes preferred over free-form strings?"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable machine-readable semantics"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "They reduce compile time"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].title",
          "text": "Explorer: invariant decision tree"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].title",
          "text": "Invariant Guard Library Project Journey"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].title",
          "text": "Challenge: implement InvariantError + ensure helpers"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].hints[0]",
          "text": "Return typed error payloads, not raw strings."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[1].title",
          "text": "Challenge: implement deterministic EvidenceChain"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].title",
          "text": "Challenge: deterministic invariant case runner"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].hints[0]",
          "text": "Property-ish deterministic tests can still run as fixed case sets."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].title",
          "text": "Challenge: implement formatReport() stable markdown"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].content",
          "text": "Format a deterministic markdown evidence report."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].title",
          "text": "Checkpoint: invariant audit report"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].content",
          "text": "Export deterministic invariant audit checkpoint artifacts."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should capture deterministic summary fields only."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[1]",
          "text": "No wall-clock timestamps in exported artifact."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why use deterministic cost models before microbenchmarks?"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable regression signals in CI"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They replace all profiling"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Deterministic models make relative regressions easy to catch early."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].title",
          "text": "Data structures: Vec, HashMap, BTreeMap tradeoffs"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].title",
          "text": "Explorer: cost model sandbox"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].title",
          "text": "Compute Budget Profiler (Sim)"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].title",
          "text": "Challenge: implement CostModel::estimate()"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].content",
          "text": "Estimate deterministic operation costs from fixed weighting rules."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].title",
          "text": "Challenge: optimize function metrics"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[0]",
          "text": "Treat optimization as deterministic metric diffs, not runtime benchmarking."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[1]",
          "text": "Clamp reduced metrics at zero."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].title",
          "text": "Challenge: model serialization overhead"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[0]",
          "text": "Show why repeated encode/decode loops are expensive."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[1]",
          "text": "Keep the model deterministic by counting bytes instead of timing."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].content",
          "text": "Generate stable optimization suggestions from deterministic metrics."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[0]",
          "text": "Output suggestions as a stable, sorted list."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[1]",
          "text": "Use threshold-based recommendations to avoid noisy advice."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].title",
          "text": "Checkpoint: stable perf report"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].hints[1]",
          "text": "Use deterministic percentage rounding."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].title",
          "text": "Async fundamentals: futures, tasks, channels"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].title",
          "text": "Reorg-safe Async Pipeline Project Journey"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].title",
          "text": "Challenge: implement Pipeline::run()"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].hints[1]",
          "text": "No real timers; simulate progression by decrementing remaining ticks."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[1].title",
          "text": "Challenge: implement RetryPolicy schedule"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].title",
          "text": "Challenge: idempotency key dedupe"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].content",
          "text": "Deduplicate replay events by deterministic idempotency keys."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].hints[0]",
          "text": "Use idempotency keys to collapse duplicate replay events."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[3].content",
          "text": "Build deterministic snapshot state from simulated event streams."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].title",
          "text": "Checkpoint: pipeline run report"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint output should mirror deterministic pipeline run artifacts."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "It verifies expansion matches policy intent"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].title",
          "text": "Safety through codegen: constraint checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].title",
          "text": "Explorer: constraint builder to generated checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].content",
          "text": "Parse mini-DSL constraints into deterministic AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].hints[0]",
          "text": "Parse mini DSL lines into typed AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].content",
          "text": "Generate stable pseudo-code from parsed constraint AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[0]",
          "text": "Generate stable pseudo-code output from AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[1]",
          "text": "One deterministic line per constraint node."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].title",
          "text": "Challenge: deterministic golden-file checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].content",
          "text": "Compare generated check output against deterministic golden strings."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[0]",
          "text": "Golden tests compare generated output strings exactly."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[1]",
          "text": "Keep check output deterministic to make golden tests meaningful."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].content",
          "text": "Execute generated constraints on deterministic sample input."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].hints[1]",
          "text": "Return deterministic failure reasons."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].title",
          "text": "Checkpoint: generated safety report"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].content",
          "text": "Export deterministic markdown safety report from generated checks."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].hints[0]",
          "text": "Render a deterministic markdown report from generated check results."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].title",
          "text": "Upgrade authority lifecycle in Anchor programs"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Compare approved build hash to expected programdata hash policy input"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Rely on signer memory without written report"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is release communication part of upgrade safety?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Because Anchor automatically writes support tickets"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because all upgrades are backward compatible"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].title",
          "text": "Explorer: upgrade risk matrix"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].title",
          "text": "Challenge: implement migration step planner"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].hints[1]",
          "text": "requiresMigration should be true only when toVersion > fromVersion."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].title",
          "text": "Challenge: implement upgrade safety gate checks"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[1]",
          "text": "Return issueCount plus ordered issue code array."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[2]",
          "text": "Keep order stable to make report diffs deterministic."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What should happen first when rollback trigger thresholds are hit?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Continue migration batches to avoid confusion"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Delete all historical reports"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Trigger conditions should map to immediate deterministic response actions."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add deterministic fixtures after an incident?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "To prove policy changes prevent the same failure path"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To increase deploy complexity without benefit"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "To replace all code reviews"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].title",
          "text": "Challenge: build stable upgrade markdown summary"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].hints[2]",
          "text": "Return plain markdown string without trailing spaces."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].title",
          "text": "Checkpoint: upgrade readiness artifact"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[0]",
          "text": "ready is true only when issueCount equals 0."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[1]",
          "text": "Return stable keys in releaseTag, ready, migrationBatches order."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[2]",
          "text": "Checkpoint output should be machine-readable deterministic JSON."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[0]",
          "text": "Use match on the BackoffStrategy enum to handle each case"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[2]",
          "text": "should_retry simply checks if attempt is less than max_attempts"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].content",
          "text": "Implement a deadline management system to enforce time limits on operations."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].hints[0]",
          "text": "Store the absolute expiration timestamp in the Deadline struct"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].content",
          "text": "Implement a fallback mechanism that provides alternative execution paths when primary operations fail."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].hints[1]",
          "text": "Only call fallback if primary returns None"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].hints[1]",
          "text": "record_success should reset everything to Closed state"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[0]",
          "text": "Always refill before checking if consumption is possible"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[2]",
          "text": "Use min() to ensure tokens don't exceed capacity"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].content",
          "text": "Implement an error classification system to determine if errors are retryable."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[1]",
          "text": "should_retry can use matches! macro or match on classify result"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[2]",
          "text": "batch_classify can use iter().map().collect() pattern"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].title",
          "text": "Test Assertion Framework Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].hints[1]",
          "text": "Use format! to create descriptive error messages"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[2].hints[0]",
          "text": "Use vec![0; size] to create zero-filled data of specified size"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].title",
          "text": "Test Scenario Builder Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].hints[1]",
          "text": "Push strings into vectors (use to_string() to convert &str)"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].title",
          "text": "Fuzz Input Generator Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].hints[1]",
          "text": "Generate bytes by taking random % 256"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[2].content",
          "text": "Implement a property verifier that checks invariants hold across operations."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].title",
          "text": "Boundary Value Analyzer Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[1]",
          "text": "Typical value is the midpoint of the range"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[2]",
          "text": "Return all 7 boundary values as test cases"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].content",
          "text": "Implement a compute unit counter to estimate operation costs."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[0]",
          "text": "Loop cost is overhead plus iterations times per-iteration cost"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[2]",
          "text": "Apply safety margin by multiplying budget by the percentage"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].title",
          "text": "Data Structure Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[0]",
          "text": "Use copy_from_slice to write data efficiently"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[1]",
          "text": "Track the highest written position as 'used'"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[2]",
          "text": "Always check bounds before read/write operations"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].title",
          "text": "Batch Operation Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].content",
          "text": "Optimize batch operations to minimize compute units."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[0]",
          "text": "Use to_le_bytes() to convert integers to bytes"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[1]",
          "text": "Use from_le_bytes() to convert bytes back to integers"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[2]",
          "text": "Alignment formula: if remainder, add (alignment - remainder)"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[0]",
          "text": "Annual rent is data size times lamports per byte per year"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[1]",
          "text": "Exemption threshold is annual rent times threshold years"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[2]",
          "text": "Check if balance is greater than or equal to minimum"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].title",
          "text": "Zero-Copy Deserializer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[0]",
          "text": "Use copy_from_slice to read fixed-size data into stack arrays"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[2]",
          "text": "Always advance offset after reading"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].title",
          "text": "Vesting Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[0]",
          "text": "Use saturating_sub to avoid underflow when calculating elapsed time"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[2]",
          "text": "Releasable is simply vested minus already released"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].title",
          "text": "Token Allocation Distributor Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[0]",
          "text": "Use iter().map().sum() to calculate total percentage"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[2]",
          "text": "Use find() to locate allocation by recipient"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].title",
          "text": "Release Schedule Generator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].hints[0]",
          "text": "Divide duration by intervals to get interval duration"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[0]",
          "text": "Use compound interest formula: A = P(1 + r/n)^(nt)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[1]",
          "text": "Convert basis points to decimal by dividing by 10000"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[0]",
          "text": "If delegated_to is Some, voting power is 0 (they gave it away)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[1]",
          "text": "Use filter to find voters who delegated to a specific address"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[2]",
          "text": "Sum staked amounts to calculate delegated power"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].title",
          "text": "Proposal Threshold Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].hints[0]",
          "text": "Convert basis points to amount: (supply * bps) / 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[1].title",
          "text": "Constant Product AMM Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].title",
          "text": "Liquidity Provider Calculator Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].hints[2]",
          "text": "Rewards are proportional to LP token holdings"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].content",
          "text": "Implement a time-weighted average price oracle."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[0]",
          "text": "Use retain() to filter out old observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[1]",
          "text": "Calculate duration between consecutive observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[2]",
          "text": "TWAP is weighted sum divided by total duration"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[0]",
          "text": "Max borrow is collateral value times LTV ratio"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[1]",
          "text": "Position is liquidatable when borrowed exceeds threshold * value"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[2]",
          "text": "Health factor shows how close to liquidation (higher is safer)"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].title",
          "text": "Interest Rate Model Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].content",
          "text": "Implement a utilization-based interest rate model."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].hints[0]",
          "text": "Utilization is borrowed divided by supplied"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].title",
          "text": "Flash Loan Validator Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].content",
          "text": "Implement flash loan validation logic."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[0]",
          "text": "Fee is amount times fee_bps divided by 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[1]",
          "text": "Total repay is principal plus fee"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[1].title",
          "text": "NFT Metadata Parser Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[2].hints[2]",
          "text": "Only verify if collection is complete"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].title",
          "text": "Attribute Rarity Calculator Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].content",
          "text": "Calculate NFT attribute rarity scores."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[0]",
          "text": "Rarity percentage is (count / total) * 100"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[1]",
          "text": "Rarity score is inverse of rarity (1 / rarity)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[1].title",
          "text": "Soulbound Token Validator Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[1].hints[2]",
          "text": "Use any() to check if address is in restrictions list"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].title",
          "text": "Dynamic NFT Updater Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].content",
          "text": "Implement dynamic NFT attributes that can evolve over time."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[1]",
          "text": "Update last_updated timestamp after successful update"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[2]",
          "text": "Time until update is max(0, next_update - current_time)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[3].hints[2]",
          "text": "Filter equipped items by matching type in items list"
        },
        {
          "path": "courses.solana-cpi-patterns.title",
          "text": "Cross-Program Invocation Patterns"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[1].hints[2]",
          "text": "Privilege extension: if caller is signer, child can sign too"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[0]",
          "text": "Convert string seeds to bytes using as_bytes()"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[1]",
          "text": "Simulate PDA finding by trying different bump values"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[0]",
          "text": "Use HashMap insert to register handlers"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[1]",
          "text": "Route by looking up instruction_type in handlers map"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].title",
          "text": "Atomic Swap Orchestrator Challenge"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].content",
          "text": "Implement an atomic swap across multiple programs."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].hints[1]",
          "text": "Atomicity requires output_token of step N equals input_token of step N+1"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[2].title",
          "text": "State Consistency Validator Challenge"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[2].content",
          "text": "Validate state consistency across multiple CPI calls."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[0]",
          "text": "Push permission into vector to register"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[2]",
          "text": "Use retain() to remove caller from allowed list"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].title",
          "text": "Arbitrage Opportunity Detector Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].content",
          "text": "Detect arbitrage opportunities across DEXes."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[1]",
          "text": "Profit percent is (sell - buy) / buy * 100"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[2]",
          "text": "Use max_by to find best opportunity"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].title",
          "text": "Liquidation Opportunity Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[0]",
          "text": "Position is liquidatable when borrowed > threshold * collateral_value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[2]",
          "text": "Liquidation profit is bonus percentage of collateral value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].title",
          "text": "Priority Fee Calculator Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[0]",
          "text": "Urgency factor scales the base fee"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[1]",
          "text": "Execution probability decreases as more fees are higher"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[0]",
          "text": "Tip is percentage of total profit"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[1]",
          "text": "Bundle is profitable if profit exceeds tip"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].title",
          "text": "Multi-Hop Arbitrage Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].content",
          "text": "Find multi-hop arbitrage paths across token pairs."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[1]",
          "text": "Two-hop arbitrage goes A -> B -> A through different pools"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[2]",
          "text": "Profit is final output minus initial input"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].title",
          "text": "MEV Simulation Engine Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].content",
          "text": "Simulate MEV extraction to estimate profitability."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].hints[2]",
          "text": "Expected value weights profit by success probability"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[0]",
          "text": "Push config into vector to add"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[1]",
          "text": "Use find() to locate config by environment name"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].title",
          "text": "Program Size Validator Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[0]",
          "text": "Compare binary length against MAX_PROGRAM_SIZE"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[2]",
          "text": "Compression ratio shows percentage size reduction"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].title",
          "text": "Upgrade Authority Manager Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[0]",
          "text": "Push metadata into vector to register"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[1]",
          "text": "can_upgrade checks if authority matches stored authority"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].title",
          "text": "Build Pipeline Validator Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[0]",
          "text": "Track seen stages to enforce ordering constraints"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[2]",
          "text": "Can skip build/test if only documentation files changed"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].title",
          "text": "Version Compatibility Checker Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[1]",
          "text": "Compatibility requires same major, actual >= required"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[2]",
          "text": "Use min_by to find smallest compatible version"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].title",
          "text": "Cross-Chain Messaging Architecture"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].content",
          "text": "Implement VAA (Verified Action Approval) signature verification."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[0]",
          "text": "Check signatures length against MIN_SIGNERS first"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[2]",
          "text": "Quorum is 2/3 of total guardians rounded up"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[0]",
          "text": "Increment sequence before creating message"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[2]",
          "text": "Verify message sequence is within emitted range"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[0]",
          "text": "Use contains() to check if sequence was processed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[1]",
          "text": "Return error if trying to mark already-processed sequence"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[2]",
          "text": "Use retain() to filter out old sequences"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[1].hints[1]",
          "text": "Verify requester matches owner before unlocking"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].title",
          "text": "Wrapped Token Mint Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].hints[1]",
          "text": "Check bounds before minting/burning"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].title",
          "text": "Bridge Rate Limiter Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[0]",
          "text": "Reset window before checking if duration passed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[1]",
          "text": "Only consume if total won't exceed max"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[1].hints[1]",
          "text": "Confidence ratio: conf / |price| < threshold"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[0]",
          "text": "Multiplier formula: smoothing / (period + 1)"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[1]",
          "text": "First EMA equals first price"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[2]",
          "text": "Subsequent EMAs use weighted average formula"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].title",
          "text": "Median Price Calculator Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].content",
          "text": "Calculate median price from multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].hints[2]",
          "text": "Use retain() to filter out outliers"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].content",
          "text": "Implement consensus checking across multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[0]",
          "text": "Check minimum sources first"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[2]",
          "text": "Agreement percent is (agreeing / total) * 100"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].title",
          "text": "Fallback Oracle Manager Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[0]",
          "text": "Store sources in priority order"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[1]",
          "text": "current_source index tracks which is active"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[2]",
          "text": "Fallback if index > 0 (not primary)"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].title",
          "text": "Proposal Lifecycle Manager Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].hints[1]",
          "text": "Voting active only during time window in Active state"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[0]",
          "text": "Delegated voters have 0 voting power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[1]",
          "text": "Quadratic voting uses square root of balance"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[2]",
          "text": "Apply cap after calculating base power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].content",
          "text": "Manage vote delegation between DAO members."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].hints[0]",
          "text": "Remove existing delegation before creating new one"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].title",
          "text": "Treasury Spending Limit Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].hints[1]",
          "text": "Reset period if duration has passed"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[2].hints[2]",
          "text": "Remove operation from list to cancel"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].title",
          "text": "Automated Action Trigger Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[1]",
          "text": "Match on condition type to evaluate"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[2]",
          "text": "Only return non-triggered actions that meet conditions"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[1].hints[1]",
          "text": "Turn complete when all players submitted"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].title",
          "text": "Game State Compressor Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[0]",
          "text": "Use bit shifting to pack x in high 4 bits, y in low 4 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[2]",
          "text": "Health stored as percentage (0-100) fits in 7 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].title",
          "text": "Player Progression Tracker Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[0]",
          "text": "XP formula: base * multiplier^(level-1)"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[1]",
          "text": "Keep leveling up while XP exceeds requirement"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[2]",
          "text": "Check contains() before adding achievement"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[1].hints[1]",
          "text": "Verify by recomputing hash from reveal"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[2].hints[2]",
          "text": "4d6 drop lowest: roll 4, sum all, subtract minimum"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[1]",
          "text": "Generate random number in range [0, total)"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[2]",
          "text": "Find item where cumulative weight exceeds roll"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].title",
          "text": "Storage Cost Estimator Challenge"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].content",
          "text": "Estimate Arweave storage costs based on data size."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].hints[0]",
          "text": "Calculate winston cost then convert to USD"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[3].hints[0]",
          "text": "Sort items by priority before bundling"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[0]",
          "text": "Validate tx_id length before adding"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[1]",
          "text": "Resolve in order: exact, index, fallback"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[0]",
          "text": "Push item to vector to add"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[1]",
          "text": "Filter items where any tag matches"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].title",
          "text": "Staking Rewards Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].hints[0]",
          "text": "Apply commission as (1 - commission) multiplier"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[2].hints[0]",
          "text": "Weight factors: commission 40%, uptime 40%, skip rate 20%"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[2].hints[2]",
          "text": "Check each validator's percentage of total stake"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[0]",
          "text": "Target is total divided by count, clamped to min/max"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[2]",
          "text": "Check all allocations within tolerance percentage"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[1].title",
          "text": "Validator Profit Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[1].hints[0]",
          "text": "Sum all cost components"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[2].title",
          "text": "Epoch Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[0]",
          "text": "Only inactive stakes can be activated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[1]",
          "text": "Only active stakes can be deactivated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[2]",
          "text": "Fully active after warmup_epochs from activation"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[1].title",
          "text": "Multi-Signature Wallet Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[1].content",
          "text": "Implement M-of-N multi-signature wallet."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[1].hints[0]",
          "text": "Use contains() to check ownership"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[2].hints[1]",
          "text": "Check guardian status before approving"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].title",
          "text": "Session Key Manager Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[0]",
          "text": "Valid if current time before expiration"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[2]",
          "text": "Remaining is max minus used"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].title",
          "text": "Spending Limit Enforcer Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[0]",
          "text": "Reset counters before checking"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[1]",
          "text": "Check all three limits: per-tx, daily, weekly"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[2]",
          "text": "Reset daily if new day, weekly if 7+ days passed"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[2].hints[1]",
          "text": "Check contains() before adding"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[3].title",
          "text": "Time Lock Enforcer Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.title",
          "text": "Program Derived Address Mastery"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[0]",
          "text": "Try bumps from 255 down to 0"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[2]",
          "text": "Check if derived address matches expected"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[2].hints[2]",
          "text": "Collect into Vec<Vec<u8>>"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[3].hints[1]",
          "text": "Signer seeds include all seeds plus bump"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].title",
          "text": "Nested PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].content",
          "text": "Generate PDAs derived from other PDA addresses."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].hints[0]",
          "text": "Include parent address in child seeds"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].title",
          "text": "Counter PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].content",
          "text": "Generate unique PDAs using incrementing counters."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[0]",
          "text": "Increment counter after each generation"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[2]",
          "text": "Batch generation calls generate_next multiple times"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].title",
          "text": "PDA Collision Detector Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[0]",
          "text": "Check if seeds match any existing entry"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[1]",
          "text": "Return error if collision detected"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[1]",
          "text": "Compound inflation year over year"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[2]",
          "text": "APY is inflation divided by staked percentage"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].title",
          "text": "Fee Burn Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].hints[1]",
          "text": "Burn is percentage of total fee"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].title",
          "text": "Rent Economics Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[0]",
          "text": "Annual rent is bytes times rate"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[1]",
          "text": "Exemption is annual times threshold years"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[2]",
          "text": "Rent due is annual times period"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].title",
          "text": "Supply Flow Tracker Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[0]",
          "text": "Total excludes burned tokens"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[1]",
          "text": "Apply flow by subtracting from source, adding to destination"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[2]",
          "text": "Net flow is inflow minus outflow"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].title",
          "text": "Vesting Schedule Impact Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].content",
          "text": "Calculate token unlock impact on supply."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[0]",
          "text": "0 before cliff, linear after, full at end"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[1]",
          "text": "Monthly unlock is difference between consecutive months"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[2]",
          "text": "Check multiple months to find peak"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].title",
          "text": "Protocol Sustainability Score Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[0]",
          "text": "Net issuance is inflation minus burn"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[1]",
          "text": "Burn ratio is burn divided by inflation"
        }
      ],
      "englishLikeMatches": [
        {
          "path": "courses.solana-fundamentals.description",
          "englishWordCount": 19,
          "excerpt": "Produktionsnahe Einfuehrung fuer Einsteiger, die klare Solana-Denkmodelle, staerkere Transaction-Debugging-Skills und deterministische Wallet-Manager-Workflows aufbauen wollen."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Core execution model, konto semantics, und transaktion construction patterns you need before writing programs or complex clients."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].content",
          "englishWordCount": 278,
          "excerpt": "# Solana mentales modell Solana development gets much easier once you stop thinking in terms of \"contracts that own state\" und start thinking in terms of \"programs that operate on konten.\" On Solana, the durable state of..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 18,
          "excerpt": "On Solana, mutable app state is konto data. Programs validate und mutate those konten but do not hold mutable state internally."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 18,
          "excerpt": "The runtime checks the message envelope und authorization: fee payer, freshness via blockhash, required signatures, und anweisung payloads."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].explanation",
          "englishWordCount": 13,
          "excerpt": "Read/write sets let the runtime detect conflicts und parallelize independent work deterministically."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].content",
          "englishWordCount": 252,
          "excerpt": "# Konten model tiefenanalyse Every on-chain object on Solana is an konto mit a standard envelope. You can reason about any konto using a small set of fields: address, lamports, owner, executable flag, und data bytes leng..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Owner identifies the controlling program fuer state mutation und many lamport operations."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Executable konten are code containers; they are not ordinary mutable data konten."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].explanation",
          "englishWordCount": 14,
          "excerpt": "SPL token state uses dedicated konto layouts und authorization rules enforced by the token program."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].content",
          "englishWordCount": 318,
          "excerpt": "# Transaktionen & anweisungen An anweisung is the smallest executable unit on Solana: `programId + account metas + opaque data bytes`. A transaktion wraps one or more anweisungen plus signatures und message metadata. Thi..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].content",
          "englishWordCount": 62,
          "excerpt": "# Build a SOL transfer transaktion Implement a deterministic `buildTransferTx(params)` helper in the project file: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` - Use `@solana/web3.js` - Return a trans..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[2]",
          "englishWordCount": 14,
          "excerpt": "Mirror this logic in the real project helper in src/lib/kurse/solana-fundamentals/project/walletManager.ts."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Program behavior, deterministic PDA design, und SPL token mentales modells mit praktisch safety checks."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].content",
          "englishWordCount": 252,
          "excerpt": "# Programs: what they are (und aren’t) A Solana program is executable konto code, not an object that secretly owns mutable storage. Your program receives konten from the transaktion, verifies constraints, und writes only..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Konto lists are part of the anweisung contract; hidden discovery would break determinism und scheduling assumptions."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].content",
          "englishWordCount": 245,
          "excerpt": "# Programmabgeleitete Adressen (PDAs) A Programmabgeleitete Adresse (PDA) is a deterministic konto address derived from seeds plus a program ID, mit one key property: it is intentionally off-curve, so no private key exis..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "invoke_signed proves seed derivation to runtime, which grants PDA signer semantics fuer that invocation."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].content",
          "englishWordCount": 237,
          "excerpt": "# SPL Tokens grundlagen SPL Token is Solana’s standard token program family fuer fungible assets. A token mint konto defines token-level configuration: decimals, total supply accounting, und authorities such as mint auth..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "Associated Token Konten standardize where fungible token balances are stored fuer each owner/mint."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "englishWordCount": 13,
          "excerpt": "Wallets can only hold SOL while token balances are separate program-owned konten"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "SPL balances are state in token konten, not direct fields on wallet system konten."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].content",
          "englishWordCount": 53,
          "excerpt": "# Wallet Manager CLI-sim Implement a deterministic CLI parser + command executor in: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` Required behavior: - `address` prints the active pubkey - `build-trans..."
        },
        {
          "path": "courses.anchor-development.description",
          "englishWordCount": 21,
          "excerpt": "Projektorientierter Kurs fuer den Weg von den Grundlagen zur echten Anchor-Entwicklung: deterministisches Account-Modelling, Instruction-Builder, Testdisziplin und zuverlaessige Client-UX."
        },
        {
          "path": "courses.anchor-development.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Anchor architecture, konto constraints, und PDA foundations mit explicit ownership of sicherheit-critical decisions."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].content",
          "englishWordCount": 365,
          "excerpt": "# Anchor mentales modell Anchor is best understood as a contract between three layers that must agree on shape: your Rust handlers, generated interface metadata (IDL), und client-side anweisung builders. In raw Solana pr..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Anchor generates serialization/validation scaffolding und IDL contracts, not validator-level behavior."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].content",
          "englishWordCount": 273,
          "excerpt": "# Konten, constraints, und safety Most serious Solana vulnerabilities come from konto validation mistakes, not from arithmetic. Anchor’s constraint system exists to turn those checks into declarative, auditable rules. Yo..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].content",
          "englishWordCount": 253,
          "excerpt": "# PDAs in Anchor Programmabgeleitete Adressen are the backbone of predictable konto topology in Anchor applications. A PDA is derived from seed bytes plus program ID und intentionally lives off the ed25519 curve, so no p..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].content",
          "englishWordCount": 68,
          "excerpt": "# Initialize Counter PDA (deterministic) Implement deterministic helper functions fuer a Counter project: - `deriveCounterPda(programId, authorityPubkey)` - `buildInitCounterIx(params)` This lektion validates client-side..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[1]",
          "englishWordCount": 15,
          "excerpt": "The init anweisung must include four keys in fixed order: counter PDA, authority, payer, system program."
        },
        {
          "path": "courses.anchor-development.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Deterministic anweisung builders, stable state emulation, und tests strategy that separates pure logic from network integration."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].content",
          "englishWordCount": 40,
          "excerpt": "# Increment anweisung builder + state layout Implement deterministic increment behavior in pure TypeScript: - Build a reusable state representation fuer counter data. - Implement `applyIncrement` as a pure transition fun..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].content",
          "englishWordCount": 256,
          "excerpt": "# Tests strategy without flakiness A reliable Solana curriculum should teach deterministic engineering first, then optional network integration. Flaky tests are usually caused by external dependencies: RPC latency, fauce..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].content",
          "englishWordCount": 262,
          "excerpt": "# Client composition & UX Once anweisung layouts und PDA logic are deterministic, client integration becomes a composition exercise: wallet adapter fuer signing, provider/connection fuer transport, transaktion builder fu..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].content",
          "englishWordCount": 49,
          "excerpt": "# Counter project checkpoint Compose the full deterministic flow: 1. Derive counter PDA from authority + program ID. 2. Build init anweisung metadata. 3. Build increment anweisung metadata. 4. Emulate state transitions: ..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[1]",
          "englishWordCount": 14,
          "excerpt": "Use fixed key order und fixed JSON key order to satisfy strict expected output matching."
        },
        {
          "path": "courses.solana-frontend.description",
          "englishWordCount": 19,
          "excerpt": "Projektorientierter Kurs fuer Frontend-Ingenieure, die produktionsreife Solana-Dashboards bauen wollen: deterministische Reducer, replaybare Event-Pipelines und vertrauenswuerdige Transaction-UX."
        },
        {
          "path": "courses.solana-frontend.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Wallet/Account-State korrekt modellieren, Transaction-Lifecycle-UX gestalten und deterministische Regeln fuer replaybares Debugging durchsetzen."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].content",
          "englishWordCount": 484,
          "excerpt": "# Wallet state + konten mentales modell fuer UI devs Most Solana frontend bugs are not visual bugs. They are model bugs. A dashboard can look polished while silently computing balances from the wrong konto class, mixing ..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].content",
          "englishWordCount": 367,
          "excerpt": "# Transaktion lifecycle fuer UI: pending/confirmed/finalized, optimistic UI Frontend transaktion UX is a state machine problem. Users press one button, but your app traverses multiple phases: intent creation, transaktion..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].content",
          "englishWordCount": 371,
          "excerpt": "# Data correctness: dedupe, ordering, idempotency, correction events Frontend teams frequently assume event streams are perfectly ordered und unique. Production systems rarely behave that way. You can receive duplicate e..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].content",
          "englishWordCount": 35,
          "excerpt": "# Build core state model + reducer from events Implement a deterministic reducer fuer dashboard state: - apply event stream transitions fuer balances und mint metadata - enforce idempotency by event id - support correcti..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[2]",
          "englishWordCount": 13,
          "excerpt": "Corrections should mark replaced event ids und remove their effects from state transitions."
        },
        {
          "path": "courses.solana-frontend.modules[1].description",
          "englishWordCount": 18,
          "excerpt": "Reducer, Replay-Snapshots, Query-Metriken und deterministische Dashboard-Outputs bauen, die unter teilweisen oder verzoegerten Daten stabil bleiben."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].content",
          "englishWordCount": 28,
          "excerpt": "# Implement event stream simulator + replay timeline + snapshots Build deterministic replay tooling: - replay sorted events by (ts, id) - snapshot every N applied events - compute stable checksum fuer replay output - ret..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].content",
          "englishWordCount": 31,
          "excerpt": "# Implement query layer + computed metrics Implement dashboard query/view logic: - search/filter/sort rows deterministically - compute total und row valueUsd mit fixed-scale integer math - expose stable view model fuer U..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].content",
          "englishWordCount": 407,
          "excerpt": "# Production UX: caching, pagination, error banners, skeletons, rate limits After model correctness, frontend quality is mostly about user trust under imperfect conditions. Users do not evaluate your dashboard by clean d..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "englishWordCount": 12,
          "excerpt": "Why should live mode und replay mode share the same reducer pipeline?"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[3].content",
          "englishWordCount": 28,
          "excerpt": "# Emit stable DashboardSummary from fixtures Compose deterministic checkpoint output: - owner, token count, totalValueUsd - top tokens sorted deterministically - recent activity rows - invariants und determinism metadata..."
        },
        {
          "path": "courses.defi-solana.description",
          "englishWordCount": 20,
          "excerpt": "Fortgeschrittener Projektkurs fuer Ingenieure, die Swap-Systeme bauen: deterministische Offline-Planung im Jupiter-Stil, Routen-Ranking, minOut-Sicherheit und reproduzierbare Diagnosen."
        },
        {
          "path": "courses.defi-solana.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "CPMM-Mathematik, Quote-Anatomie und Tradeoffs beim deterministischen Routing mit sicherheitsorientierten Nutzerschutzmechanismen verstehen."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].content",
          "englishWordCount": 534,
          "excerpt": "# AMM grundlagen on Solana: pools, fees, slippage, und preiseinfluss When users click “Swap,” they usually assume there is one objective truth: the current price. In practice, frontend swap systems compute an estimate fr..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].content",
          "englishWordCount": 414,
          "excerpt": "# Quote anatomy: in/out, fees, minOut, und worst-case execution A production quote is not one number. It is a structured object that must tell users what they send, what they likely receive, how much they pay in fees, un..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].content",
          "englishWordCount": 424,
          "excerpt": "# Routing: why two-hop can beat one-hop Users often assume direct pair routes are always best because they are simpler. In fragmented liquidity systems, that assumption fails frequently. A direct SOL -> JUP pool might ha..."
        },
        {
          "path": "courses.defi-solana.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Deterministisches Quoting, Routenauswahl und minOut-Sicherheitschecks bauen und stabile Checkpoint-Artefakte fuer reproduzierbare Reviews bereitstellen."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].content",
          "englishWordCount": 31,
          "excerpt": "# Implement route enumeration und best-route selection Implement deterministic route planner: - enumerate one-hop und two-hop candidates - quote each candidate at exact input size - select best route using stable tie-bre..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].content",
          "englishWordCount": 37,
          "excerpt": "# Implement slippage/minOut, fee breakdown, und safety invariants Implement deterministic safety layer: - apply slippage to compute minOut - simulate route mit virtual reserve updates - return structured errors fuer inva..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].content",
          "englishWordCount": 422,
          "excerpt": "# Production swap UX: stale quotes, protection, und simulation A deterministic route engine is necessary but not sufficient fuer production. Users experience DeFi through timing, messaging, und safety affordances. A math..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].content",
          "englishWordCount": 31,
          "excerpt": "# Produce stable SwapPlan + SwapSummary checkpoint Compose deterministic checkpoint artifacts: - build swap plan from selected route quote - include fixtureHash und modelVersion - emit stable summary mit path, minOut, fe..."
        },
        {
          "path": "courses.solana-security.description",
          "englishWordCount": 17,
          "excerpt": "Produktionsnahes deterministisches Vulnerability-Lab fuer Solana-Auditoren mit wiederholbarer Exploit-Evidenz, praeziser Remediation und aussagekraeftigen Audit-Artefakten."
        },
        {
          "path": "courses.solana-security.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Account-zentriertes Threat Modeling, deterministische Exploit-Reproduktion und Evidenzdisziplin fuer glaubwuerdige Audit Findings."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].content",
          "englishWordCount": 584,
          "excerpt": "# Solana threat model fuer auditors: konten, owners, signers, writable, PDAs Sicherheit work on Solana starts mit one non-negotiable fact: anweisung callers choose the konto list. Programs do not receive trusted implicit..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Without owner checks, konto substitution allows attacker-controlled bytes to be parsed as trusted state."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].content",
          "englishWordCount": 462,
          "excerpt": "# Evidence chain: reproduce, trace, impact, fix, verify Strong sicherheit reports are built on evidence chains, not opinions. In the Solana context, that means moving from a claim such as “missing signer check exists” to..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].content",
          "englishWordCount": 496,
          "excerpt": "# Common Solana bug classes und mitigations Auditors on Solana repeatedly encounter the same core bug families. The implementation details differ across protocols, but exploit mechanics are surprisingly consistent: ident..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "Sicherheit failures are usually adversarial edge cases, so tests must target those edges directly."
        },
        {
          "path": "courses.solana-security.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Exploiten, patchen, verifizieren und audit-reife Artefakte mit deterministischen Traces und invariantenbasierten Schlussfolgerungen liefern."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].content",
          "englishWordCount": 43,
          "excerpt": "# Break it: exploit missing signer + owner checks Implement a deterministic exploit-proof formatter fuer signer/owner vulnerabilities. Expected output fields: - scenario - before/after vault balance - before/after recipi..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].content",
          "englishWordCount": 30,
          "excerpt": "# Break it: exploit PDA spoof mismatch Implement a deterministic PDA spoof proof output. You must show: - expected PDA - accepted PDA - mismatch boolean - trace hash This lektion validates evidence generation fuer deriva..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].content",
          "englishWordCount": 30,
          "excerpt": "# Fix it: validations + invariant suite Implement patch validation output that confirms: - signer check - owner check - PDA check - safe u64 arithmetic - exploit blocked state mit error code Keep output deterministic fue..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].content",
          "englishWordCount": 473,
          "excerpt": "# Writing audit reports: severity, likelihood, blast radius, remediation A strong audit report is an engineering document, not a narrative essay. It should allow a reader to answer four questions quickly: what failed, ho..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].content",
          "englishWordCount": 29,
          "excerpt": "# Checkpoint: deterministic AuditReport JSON + markdown Create the final deterministic checkpoint payload: - kurs + version - scenario IDs - finding count This checkpoint mirrors the final kurs artifact produced by the s..."
        },
        {
          "path": "courses.token-engineering.description",
          "englishWordCount": 19,
          "excerpt": "Projektkurs fuer Teams, die reale Solana-Token launchen: deterministische Token-2022-Planung, Authority-Design, Supply-Simulation und operative Launch-Disziplin."
        },
        {
          "path": "courses.token-engineering.modules[0].description",
          "englishWordCount": 17,
          "excerpt": "Verstehe Token-Primitives, Mint-Policy-Anatomie und Token-2022-Extension-Kontrollen mit explizitem Governance- und Threat-Model-Rahmen."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].content",
          "englishWordCount": 413,
          "excerpt": "# SPL tokens vs Token-2022: what extensions change Token engineering starts mit a clean boundary between base token semantics und configurable policy. Legacy SPL Token gives you a stable fungible primitive: mint metadata..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].content",
          "englishWordCount": 381,
          "excerpt": "# Mint anatomy: authorities, decimals, supply, freeze, mint A production token launch succeeds or fails on parameter discipline. The mint konto is a compact policy object: it defines decimal precision, minting authority,..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].content",
          "englishWordCount": 375,
          "excerpt": "# Extension safety pitfalls: fee configs, delegate abuse, default konto state Token-2022 extensions let teams express policy in a standard token framework, but policy power is exactly where operational failures happen. S..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Fee cap interacts mit basis points und can distort economic behavior if misconfigured."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].content",
          "englishWordCount": 37,
          "excerpt": "# Validate token config + derive deterministic addresses offline Implement strict config validation und deterministic pseudo-derivation: - validate decimals, u64 strings, recipient totals, extension fields - derive stabl..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].hints[1]",
          "englishWordCount": 12,
          "excerpt": "Use one deterministic seed format fuer mint und one fuer ATA derivation."
        },
        {
          "path": "courses.token-engineering.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Baue deterministische Validierungs-, Planungs- und Simulations-Workflows, die reviewbare Launch-Artefakte und klare Go/No-Go-Kriterien liefern."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].content",
          "englishWordCount": 32,
          "excerpt": "# Build Token-2022 initialization anweisung plan Create a deterministic offline initialization plan: - create mint konto step - init mint step mit decimals - append selected extension steps in stable order - base64 encod..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].hints[0]",
          "englishWordCount": 12,
          "excerpt": "Add base steps first: create mint konto, then initialize mint mit decimals."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].content",
          "englishWordCount": 30,
          "excerpt": "# Build mint-to + transfer-fee math + simulation Implement pure simulation fuer transfer fees und launch distribution: - fee = min(maxFee, floor(amount * feeBps / 10000)) - aggregate distribution totals deterministically..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].content",
          "englishWordCount": 378,
          "excerpt": "# Launch checklist: params, upgrade/authority strategy, airdrop/tests plan A successful token launch is an operations exercise as much as a programming task. By the time users see your token in wallets, dozens of choices..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].content",
          "englishWordCount": 30,
          "excerpt": "# Emit stable LaunchPackSummary Compose full project output as stable JSON: - normalized authorities und extensions - supply totals und optional fee model examples - deterministic plan metadata und invariants - fixtures ..."
        },
        {
          "path": "courses.solana-mobile.description",
          "englishWordCount": 16,
          "excerpt": "Baue produktionsreife mobile Solana-dApps mit MWA, robuster Wallet-Session-Architektur, expliziter Signing-UX und disziplinierten Distributionsprozessen."
        },
        {
          "path": "courses.solana-mobile.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Kern-MWA-Protokoll, Session-Lifecycle-Kontrolle und resiliente Wallet-Handoff-Patterns fuer produktionsreife Mobile-Apps."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[0].content",
          "englishWordCount": 359,
          "excerpt": "# Mobile Wallet Ueberblick Solana Mobile development is built around the Solana Mobile Stack (SMS), a set of standards und tooling designed fuer secure, high-quality crypto-native mobile experiences. SMS is more than a h..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[1].content",
          "englishWordCount": 245,
          "excerpt": "# MWA Integration Integrating Mobile Wallet Adapter typically starts mit `@solana-mobile/mobile-wallet-adapter` APIs und an interaction pattern built around `transact()`. Within a transaktion session, the app can authori..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].content",
          "englishWordCount": 26,
          "excerpt": "# Build a Mobile Transaktion Function Implement a helper that formats a deterministic MWA transaktion request summary string. Expected output format: `<cluster>|<payer>|<instructionCount>` Use this exact order und delimi..."
        },
        {
          "path": "courses.solana-mobile.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Publikation, operative Readiness und vertrauenszentrierte Mobile-UX-Praktiken fuer die Verteilung von Solana-Apps."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[0].content",
          "englishWordCount": 277,
          "excerpt": "# dApp Store Submission Publishing to the Solana dApp Store requires more than packaging binaries. Teams should treat submission as a product, compliance, und sicherheit review process. A strong submission demonstrates s..."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[1].content",
          "englishWordCount": 297,
          "excerpt": "# Mobile Best practices Mobile crypto UX requires balancing speed, safety, und trust. Users make high-stakes decisions on small screens, often on unstable networks. Solana mobile apps should therefore optimize fuer expli..."
        },
        {
          "path": "courses.solana-testing.description",
          "englishWordCount": 18,
          "excerpt": "Baue robuste Solana-Testsysteme ueber lokale, simulierte und Netzwerk-Umgebungen mit expliziten Sicherheitsinvarianten und release-tauglichen Confidence-Gates."
        },
        {
          "path": "courses.solana-testing.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Kern-Teststrategie ueber Unit/Integration-Ebenen mit deterministischen Workflows und Abdeckung adversarialer Faelle."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[0].content",
          "englishWordCount": 332,
          "excerpt": "# Tests Approaches Tests Solana programs requires multiple layers because failures can occur in logic, konto validation, transaktion composition, or network behavior. A production tests strategy usually combines unit tes..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[1].content",
          "englishWordCount": 251,
          "excerpt": "# Bankrun Tests Solana Bankrun provides deterministic, high-speed test execution fuer Solana programs from TypeScript environments. It emulates a local bank-like runtime where transaktionen can be processed predictably, ..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[0].content",
          "englishWordCount": 259,
          "excerpt": "# Fuzzing mit Trident Fuzzing explores large input spaces automatically to find bugs that handcrafted tests miss. Fuer Solana und Anchor programs, Trident-style fuzzing workflows generate randomized anweisung sequences u..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[1].content",
          "englishWordCount": 232,
          "excerpt": "# Devnet Tests Devnet tests bridges the gap between deterministic local tests und real-world network conditions. While local validatoren und Bankrun are ideal fuer speed und reproducibility, devnet reveals behavior under..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[2].content",
          "englishWordCount": 225,
          "excerpt": "# CI/CD Pipeline fuer Solana A mature Solana CI/CD pipeline enforces quality gates across code, tests, sicherheit checks, und bereitstellung workflows. Fuer program teams, CI is not just linting Rust und TypeScript; it i..."
        },
        {
          "path": "courses.solana-indexing.description",
          "englishWordCount": 18,
          "excerpt": "Baue einen produktionsreifen Solana-Event-Indexer mit deterministischem Decoding, resilienten Ingestion-Vertraegen, Checkpoint-Recovery und verlaesslichen Analytics-Outputs."
        },
        {
          "path": "courses.solana-indexing.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Event-Modell, Token-Account-Decoding und Transaction-Meta-Parsing fuer zuverlaessige Indexing-Pipelines."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].content",
          "englishWordCount": 328,
          "excerpt": "# Events model: transaktionen, logs, und program anweisungen Indexing Solana starts mit understanding where data lives und how to extract structured events from raw chain data. Unlike EVM chains where events are explicit..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 13,
          "excerpt": "Solana programs emit events via logs und state changes, not explicit event topics."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Idempotent ingestion ensures the same transaktion processed twice creates only one event."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].content",
          "englishWordCount": 227,
          "excerpt": "# Token konto decoding und SPL layout SPL Token konten follow a standardized binary layout that indexers must parse to track balances und mint operations. Understanding this layout enables you to extract meaningful data ..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "englishWordCount": 13,
          "excerpt": "Standard SPL Token konten are 165 bytes, containing mint, owner, amount, und optional fields."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "Amounts are stored as little-endian u64 und must be converted using the mint's decimal places."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[2].content",
          "englishWordCount": 54,
          "excerpt": "# Challenge: Decode token konto + diff token balances Implement deterministic token konto decoding und balance diffing: - Parse a 165-byte SPL Token konto layout - Extract mint, owner, und amount fields - Compute balance..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].content",
          "englishWordCount": 247,
          "excerpt": "# Transaktion meta parsing: logs, errors, und inner anweisungen Transaktion metadata provides the context needed to index complex operations. Understanding how to parse logs, handle errors, und traverse inner anweisungen..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].content",
          "englishWordCount": 45,
          "excerpt": "# Challenge: Index transaktionen to normalized events Implement a transaktion indexer that produces normalized Event objects: - Parse anweisung logs und identify event types - Extract transfer events mit from/to/amount/m..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].content",
          "englishWordCount": 232,
          "excerpt": "# Pagination, checkpointing, und caching semantics Production indexers must handle large datasets efficiently while maintaining consistency. Pagination, checkpointing, und caching form the backbone of scalable indexing i..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[2].content",
          "englishWordCount": 222,
          "excerpt": "# Analytics aggregation: per wallet, per token metrics Raw event data becomes valuable through aggregation. Building analytics pipelines enables insights into user behavior, token flows, und protocol usage patterns. Per-..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].content",
          "englishWordCount": 52,
          "excerpt": "# Checkpoint: Produce stable JSON analytics summary Implement the final analytics checkpoint that produces a deterministic summary: - Aggregate events into per-wallet und per-token metrics - Generate sorted, stable JSON ..."
        },
        {
          "path": "courses.solana-payments.description",
          "englishWordCount": 18,
          "excerpt": "Baue produktionsreife Solana-Zahlungsfluesse mit robuster Validierung, replay-sicherer Idempotenz, sicheren Webhooks und deterministischen Receipts fuer die Reconciliation."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].content",
          "englishWordCount": 276,
          "excerpt": "# Address validation und memo strategies Payment flows on Solana require robust address validation und thoughtful memo strategies. Unlike traditional payment systems mit konto numbers, Solana uses base58-encoded public k..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[1].content",
          "englishWordCount": 227,
          "excerpt": "# Idempotency keys und replay protection Payment systems must handle network failures gracefully. Idempotency ensures that retrying a failed request produces the same outcome as the original, preventing duplicate charges..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].content",
          "englishWordCount": 49,
          "excerpt": "# Challenge: Create payment intent mit validation Implement a payment intent creator mit full validation: - Validate recipient address format (base58, 32 bytes) - Validate amount (positive, within limits) - Generate dete..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[3].content",
          "englishWordCount": 222,
          "excerpt": "# Transaktion building und key metadata Building payment transaktionen requires careful attention to anweisung construction, konto metadata, und program interactions. The goal is creating valid, efficient transaktionen t..."
        },
        {
          "path": "courses.solana-payments.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Transaction-Building, Webhook-Authentizitaetspruefung und deterministische Receipt-Generierung mit klarem Error-State-Handling."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].content",
          "englishWordCount": 37,
          "excerpt": "# Challenge: Build transfer transaktion Implement a transfer transaktion builder: - Build SystemProgram.transfer fuer SOL transfers - Build TokenProgram.transfer fuer SPL transfers - Return anweisung bundle mit correct k..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].content",
          "englishWordCount": 197,
          "excerpt": "# Webhook signing und verification Webhooks enable asynchronous payment notifications. Sicherheit requires cryptographic signing so recipients can verify webhook authenticity und detect tampering. Webhook signing uses HM..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].content",
          "englishWordCount": 205,
          "excerpt": "# Error state machine und receipt format Payment flows require well-defined state machines to handle the complexity of asynchronous confirmations, failures, und retries. Clear state transitions und receipt formats ensure..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].content",
          "englishWordCount": 45,
          "excerpt": "# Challenge: Verify webhook und produce receipt Implement the final payment flow checkpoint: - Verify signed webhook signature (HMAC-SHA256) - Extract payment details from payload - Generate standardized receipt JSON - I..."
        },
        {
          "path": "courses.solana-nft-compression.description",
          "englishWordCount": 17,
          "excerpt": "Beherrsche komprimierte NFT-Engineering-Patterns auf Solana: Merkle-Commitments, Proof-Systeme, Collection-Modellierung und Sicherheitschecks auf Produktionsniveau."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Baumkonstruktion, Leaf-Hashing, Insert-Mechanik und das On-chain/Off-chain-Commitment-Modell hinter komprimierten Assets."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].content",
          "englishWordCount": 286,
          "excerpt": "# Merkle trees fuer state compression Compressed NFTs (cNFTs) on Solana use Merkle trees to dramatically reduce storage costs. Understanding Merkle trees is essential fuer working mit compressed NFTs und building compres..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[1].content",
          "englishWordCount": 218,
          "excerpt": "# Leaf hashing conventions und metadata Leaf hashing determines how NFT metadata is committed to the Merkle tree. Understanding these conventions ensures compatibility mit compression standards und proper proof generatio..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].content",
          "englishWordCount": 44,
          "excerpt": "# Challenge: Implement Merkle tree insert + root updates Build a Merkle tree implementation mit insertions: - Insert leaves und compute new root - Update parent hashes up the tree - Handle tree growth und depth limits - ..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].content",
          "englishWordCount": 231,
          "excerpt": "# Proof generation und path computation Merkle proofs enable verification of leaf inclusion without accessing the entire tree. Understanding proof generation is essential fuer working mit compressed NFTs und building ver..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Proof-Generierung, Verifikation, Collection-Integritaet und Security-Hardening gegen Replay und Metadata-Spoofing."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].content",
          "englishWordCount": 43,
          "excerpt": "# Challenge: Implement proof generation + verifier Build a complete proof system: - Generate proofs from a Merkle tree und leaf index - Verify proofs against a root hash - Handle invalid proofs (wrong siblings, wrong ind..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[2]",
          "englishWordCount": 12,
          "excerpt": "To verify, start mit the leaf hash und combine mit each proof element."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[1].content",
          "englishWordCount": 222,
          "excerpt": "# Collection mints und metadata simulation Compressed NFT collections use a collection mint as the parent NFT, enabling grouping und verification of related assets. Understanding this hierarchy is essential fuer building..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].content",
          "englishWordCount": 262,
          "excerpt": "# Attack surface: invalid proofs und replay Compressed NFTs introduce unique sicherheit considerations. Understanding attack vectors und mitigations is critical fuer building secure compression-aware applications. Invali..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].content",
          "englishWordCount": 54,
          "excerpt": "# Checkpoint: Simulate mint + verify ownership proof Complete the compression lab checkpoint: - Simulate minting a cNFT (insert leaf, update root) - Generate ownership proof fuer the minted NFT - Verify the proof against..."
        },
        {
          "path": "courses.solana-governance-multisig.description",
          "englishWordCount": 17,
          "excerpt": "Baue produktionsreife DAO-Governance- und Multisig-Treasury-Systeme mit deterministischer Vote-Abrechnung, Timelock-Sicherheit und sicheren Ausfuehrungskontrollen."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Proposal-Lifecycle, deterministische Voting-Mechaniken, Quorum-Policy und Timelock-Sicherheit fuer glaubwuerdige DAO-Governance."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].content",
          "englishWordCount": 258,
          "excerpt": "# DAO model: proposals, voting, und execution Decentralized governance on Solana follows a proposal-based model where token holders vote on changes und the DAO treasury executes approved decisions. Understanding this flo..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[1].content",
          "englishWordCount": 190,
          "excerpt": "# Quorum math und vote weight calculation Accurate vote counting is critical fuer legitimate governance outcomes. Understanding quorum requirements, vote weight calculation, und edge cases ensures fair decision-making. Q..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].content",
          "englishWordCount": 176,
          "excerpt": "# Timelock states und execution scheduling Timelocks provide a critical safety layer between governance approval und execution. Understanding timelock states und transitions ensures reliable proposal execution. Timelock ..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Multisig-Transaction-Aufbau, Approval-Kontrollen, Replay-Abwehr und sichere Treasury-Execution-Patterns."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].content",
          "englishWordCount": 184,
          "excerpt": "# Multisig transaktion building und approvals Multisig wallets provide collective control over treasury funds. Understanding multisig construction, approval flows, und sicherheit patterns is essential fuer treasury opera..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].content",
          "englishWordCount": 35,
          "excerpt": "# Challenge: Implement multisig tx builder + approval rules Build a multisig transaktion system: - Create transaktionen mit anweisungen - Record signer approvals - Enforce threshold requirements - Handle approval revocat..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].content",
          "englishWordCount": 196,
          "excerpt": "# Safe defaults: owner checks und replay guards Governance und multisig systems require robust sicherheit defaults. Understanding common vulnerabilities und their mitigations protects treasury funds. Owner checks validat..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].content",
          "englishWordCount": 49,
          "excerpt": "# Challenge: Execute proposal und produce treasury diff Complete the governance simulator checkpoint: - Execute approved proposals mit timelock validation - Apply treasury state changes atomically - Generate execution tr..."
        },
        {
          "path": "courses.solana-performance.description",
          "englishWordCount": 16,
          "excerpt": "Beherrsche Solana-Performance-Engineering mit messbaren Optimierungs-Workflows: Compute-Budgets, Datenlayouts, Encoding-Effizienz und deterministische Kostenmodellierung."
        },
        {
          "path": "courses.solana-performance.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Compute-Modell, Account/Daten-Layout-Entscheidungen und deterministische Kostenschaetzung fuer Performance-Reasoning auf Transaktionsebene."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].content",
          "englishWordCount": 242,
          "excerpt": "# Compute model: budgets, costs, und limits Solana's compute model enforces deterministic execution limits through compute budgets. Understanding this model is essential fuer building efficient programs that stay within ..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[1].content",
          "englishWordCount": 204,
          "excerpt": "# Konto layout design und serialization cost Konto data layout significantly impacts compute costs. Well-designed layouts minimize serialization overhead und reduce konto access costs. Serialization formats affect cost. ..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement estimateCost(op) model Build a compute cost estimation system: - Model costs fuer different operation types - Konto fuer anweisung complexity - Include memory access costs - Return baseline measure..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].content",
          "englishWordCount": 177,
          "excerpt": "# Anweisung data size und encoding optimization Anweisung data size directly impacts transaktion cost und throughput. Optimizing encoding reduces fees und increases the operations possible within compute limits. Compact ..."
        },
        {
          "path": "courses.solana-performance.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Layout-Optimierung, Compute-Budget-Tuning und Before/After-Performance-Analyse mit Korrektheits-Schutzmechanismen."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].content",
          "englishWordCount": 43,
          "excerpt": "# Challenge: Implement optimized layout/codec Optimize an konto data layout while preserving semantics: - Reduce data size through compact encoding - Maintain all original functionality - Preserve backward compatibility ..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].content",
          "englishWordCount": 178,
          "excerpt": "# Compute budget anweisung grundlagen Compute budget anweisungen give developers control over resource allocation und transaktion prioritization. Understanding these tools enables precise optimization. setComputeUnitLimi..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "Specific limits optimize costs - you pay fuer the limit requested, not actual usage."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].content",
          "englishWordCount": 179,
          "excerpt": "# Micro-optimizations und tradeoffs Leistung optimization involves balancing competing concerns. Understanding tradeoffs helps make informed decisions about when und what to optimize. Readability vs leistung is a constan..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].content",
          "englishWordCount": 40,
          "excerpt": "# Checkpoint: Compare before/after + output perf report Complete the optimization lab checkpoint: - Measure baseline leistung metrics - Apply optimization techniques - Verify correctness is preserved - Generate leistung ..."
        },
        {
          "path": "courses.defi-swap-aggregator.description",
          "englishWordCount": 17,
          "excerpt": "Beherrsche produktionsreife Swap-Aggregation auf Solana: deterministisches Quote-Parsing, Route-Optimierungs-Tradeoffs, Slippage-Sicherheit und zuverlaessigkeitsorientierte Ausfuehrung."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Token-Swap-Mechanik, Slippage-Schutz, Route-Komposition und deterministische SwapPlan-Konstruktion mit transparenten Tradeoffs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].content",
          "englishWordCount": 412,
          "excerpt": "# Swap mentales modell: mints, ATAs, decimals, und routes Token swaps on Solana follow a fundamentally different model than centralized exchanges. Understanding the building blocks — mints, associated token konten (ATAs)..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 20,
          "excerpt": "AMM programs interact mit SPL token konten. Native SOL must be wrapped into the SPL token format so it can be processed by swap programs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].content",
          "englishWordCount": 379,
          "excerpt": "# Slippage und preiseinfluss: protecting swap outcomes Slippage is the difference between the expected output amount at quote time und the actual amount received at execution time. In volatile markets mit active trading,..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Token amounts are integers. Floating-point math can produce off-by-one errors that cause transaktion failures or incorrect minimum amounts."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].content",
          "englishWordCount": 411,
          "excerpt": "# Route visualization: understanding swap legs und fees Swap routes reveal the path your tokens take through DeFi liquidity. Visualizing routes helps users understand why a multi-hop path might yield more output than a d..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].content",
          "englishWordCount": 68,
          "excerpt": "# Challenge: Build a normalized SwapPlan from a quote Parse a raw aggregator quote response und produce a normalized SwapPlan: - Extract input/output mints und amounts from the quote - Calculate minOutAmount using BigInt..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Map each routePlan entry to a normalized leg mit index, ammLabel, mints, und fees."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "State-Machine-Ausfuehrung, Transaction-Anatomie, Retry/Staleness-Reliability-Patterns und aussagekraeftiges Swap-Run-Reporting."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].content",
          "englishWordCount": 70,
          "excerpt": "# Challenge: Implement swap UI state machine Build a deterministic state machine fuer the swap UI flow: - States: idle → quoting → ready → sending → confirming → success | error - Process a sequence of events und track a..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].hints[1]",
          "englishWordCount": 12,
          "excerpt": "If an event is not valid fuer the current state, transition to 'error' mit a descriptive message."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].content",
          "englishWordCount": 428,
          "excerpt": "# Swap transaktion anatomy: anweisungen, konten, und compute A swap transaktion on Solana is a carefully ordered sequence of anweisungen that together achieve an atomic token exchange. Understanding each anweisung's role..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "Compute budget anweisungen configure the transaktion's CU limit und price before any program execution begins."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "ALTs allow transaktionen to reference many konten without exceeding the 1232-byte transaktion size limit."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].content",
          "englishWordCount": 398,
          "excerpt": "# Reliability patterns: retries, stale quotes, und latency Production swap flows must handle the reality of network latency, expired quotes, und transaktion failures. Reliability engineering separates toy swap implementa..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].content",
          "englishWordCount": 70,
          "excerpt": "# Checkpoint: Generate a SwapRunReport Build the final swap run report that combines all kurs concepts: - Summarize the route mit leg details und total fees (using BigInt summation) - Compute the effective price as outAm..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[2]",
          "englishWordCount": 13,
          "excerpt": "Collect errors from both the state machine result und any additional errors array."
        },
        {
          "path": "courses.defi-clmm-liquidity.description",
          "englishWordCount": 18,
          "excerpt": "Beherrsche konzentrierte Liquiditaet auf Solana-DEXs: Tick-Mathematik, Range-Strategie-Design, Fee/IL-Dynamik und deterministisches Reporting von LP-Positionen."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].description",
          "englishWordCount": 17,
          "excerpt": "Konzepte konzentrierter Liquiditaet, Tick/Preis-Mathematik und Verhalten von Range-Positionen fuer belastbares Verstaendnis der CLMM-Ausfuehrung."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].content",
          "englishWordCount": 661,
          "excerpt": "# CLMM vs constant product: why ticks exist Concentrated Liquidity Market Makers (CLMMs) represent a fundamental evolution in automated market maker design. To understand why they exist, we must first understand the limi..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "Ticks provide discrete price points fuer position boundaries, liquidity transitions, und efficient fee tracking at tick crossings."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].content",
          "englishWordCount": 572,
          "excerpt": "# Price, tick, und sqrtPrice: core conversions The mathematical foundation of every CLMM rests on three interrelated representations of price: the human-readable price, the tick index, und the sqrtPriceX64. Understanding..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "Token amounts in a CLMM position are linear functions of sqrtPrice, making on-chain computation simpler und more gas-efficient."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].content",
          "englishWordCount": 650,
          "excerpt": "# Range positions: in-range und out-of-range dynamics A CLMM position is defined by its lower tick und upper tick. These two boundaries determine the price range in which the position is active, earns fees, und holds a m..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].content",
          "englishWordCount": 62,
          "excerpt": "# Challenge: Implement tick/price conversion helpers Implement the core tick math functions used in every CLMM integration: - Convert a tick index to a human-readable price using price = 1.0001^tick - Convert the price t..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].content",
          "englishWordCount": 68,
          "excerpt": "# Challenge: Simulate position fee accrual Implement a fee accrual simulator fuer a CLMM position over a price path: - Convert lower und upper tick boundaries to prices - Walk through each price in the path und determine..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].content",
          "englishWordCount": 656,
          "excerpt": "# Range strategies: tight, wide, und rebalancing rules Choosing the right price range is the most important decision a CLMM liquidity provider makes. The range determines capital efficiency, fee income, impermanent loss ..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 21,
          "excerpt": "Tight ranges concentrate capital fuer higher efficiency und fee share, but the position goes out-of-range more often, requiring active management."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Full-range positions replicate constant product behavior und never go out-of-range, making them suitable fuer highly volatile or unpredictable pairs."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].content",
          "englishWordCount": 684,
          "excerpt": "# CLMM risks: rounding, overflow, und tick spacing errors Building reliable CLMM integrations requires awareness of precision risks that can cause incorrect calculations, failed transaktionen, or lost funds. This lektion..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].content",
          "englishWordCount": 65,
          "excerpt": "# Checkpoint: Generate a Position Report Implement a comprehensive LP position report generator that combines all CLMM concepts: - Convert tick boundaries to human-readable prices - Determine in-range or out-of-range sta..."
        },
        {
          "path": "courses.defi-lending-risk.description",
          "englishWordCount": 17,
          "excerpt": "Beherrsche Solana-Lending-Risk-Engineering: Utilization- und Zinsmechanik, Analyse von Liquidationspfaden, Oracle-Sicherheit und deterministische Szenario-Reports."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Mechanik von Lending-Pools, nutzungsgetriebene Zinsmodelle und Health-Factor-Grundlagen fuer belastbare Risikoanalysen."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].content",
          "englishWordCount": 544,
          "excerpt": "# Lending pool model: supply, borrow, und utilization Lending protocols are the backbone of decentralized finance. They enable users to earn yield on idle assets by supplying them to a shared pool, while borrowers draw f..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].content",
          "englishWordCount": 450,
          "excerpt": "# Interest rate curves und the kink model Interest rates in lending protocols are not fixed. They adjust dynamically based on pool utilization to balance supply und demand fuer liquidity. The piecewise-linear \"kink\" mode..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 16,
          "excerpt": "Above the kink, slope2 (the jump multiplier) applies, causing borrow rates to spike sharply und discourage further borrowing."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "englishWordCount": 12,
          "excerpt": "Suppliers only earn on the borrowed portion, und the reserve factor takes a cut"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 18,
          "excerpt": "Supply rate = borrowRate * utilization * (1 - reserveFactor). Since utilization < 1 und reserveFactor > 0, the supply rate is always less than the borrow rate."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].content",
          "englishWordCount": 452,
          "excerpt": "# Health factor monitoring und liquidation preview The health factor is the single number that determines whether a lending position is safe or subject to liquidation. Monitoring health factors in real time is essential ..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].content",
          "englishWordCount": 89,
          "excerpt": "# Challenge: Compute utilization-based interest rates Implement the kink-based interest rate model used by lending protocols: - Calculate the utilization ratio from total supply und total borrowed - Apply the piecewise-l..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Health-Factor-Berechnung, Liquidationsmechanik, Umgang mit Oracle-Ausfaellen und Multi-Szenario-Risikoreporting fuer Stressmaerkte."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].content",
          "englishWordCount": 78,
          "excerpt": "# Challenge: Compute health factor und liquidation status Implement the health factor computation fuer a multi-asset lending position: - Sum collateral und borrow values from an array of position objects - Compute weight..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].content",
          "englishWordCount": 538,
          "excerpt": "# Liquidation mechanics: bonus, close factor, und bad debt Liquidation is the enforcement mechanism that keeps lending protocols solvent. When a borrower's health factor falls below 1.0, external actors called liquidator..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 18,
          "excerpt": "The liquidation bonus compensates liquidators fuer gas costs und risk, ensuring positions are liquidated promptly to protect the protocol."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 20,
          "excerpt": "Bad debt materializes when rapid price drops make collateral worth less than the debt, leaving the protocol mit unrecoverable losses."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].content",
          "englishWordCount": 590,
          "excerpt": "# Oracle risk und stale pricing in lending Lending protocols depend entirely on accurate, timely price feeds to compute collateral values, health factors, und liquidation eligibility. Oracles — the services that bring of..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "Using price minus confidence fuer collateral gives a conservative valuation, protecting the protocol when oracle publishers disagree or markets are volatile."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "Operating on stale prices is dangerous. Pausing operations prevents incorrect liquidations und under-collateralized borrows during oracle outages."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].content",
          "englishWordCount": 79,
          "excerpt": "# Checkpoint: Generate a multi-scenario risk report Build the final risk report that combines all kurs concepts: - Evaluate a base case using current position prices - Apply price overrides from multiple named scenarios ..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[0]",
          "englishWordCount": 12,
          "excerpt": "Create a reusable evalScenario function that takes price overrides und computes health factor."
        },
        {
          "path": "courses.defi-perps-risk-console.description",
          "englishWordCount": 17,
          "excerpt": "Beherrsche Perps-Risk-Engineering auf Solana: praezise PnL/Funding-Abrechnung, Margin-Monitoring, Liquidationssimulation und deterministisches Console-Reporting."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Mechanik von Perpetual Futures, Funding-Akkumulationslogik und PnL-Modellierungsgrundlagen fuer praezise Positionsdiagnosen."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].content",
          "englishWordCount": 626,
          "excerpt": "# Perpetual futures: base positions, entry price, und mark vs oracle Perpetual futures (perps) are synthetic derivatives that let traders gain exposure to an asset's price movement without holding the underlying token. U..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "englishWordCount": 12,
          "excerpt": "If you hold 8 SOL-PERP at $20 und buy 2 more at $30, what is your new entry price?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].content",
          "englishWordCount": 615,
          "excerpt": "# Funding rates: why they exist und how they accrue Funding rates are the mechanism that tethers a perpetual contract's price to the underlying spot price. Without funding, the perp price could drift arbitrarily far from..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 24,
          "excerpt": "A positive premium (mark > oracle) produces a positive funding rate. Longs pay shorts, which discourages excessive long demand und pushes the perp price back toward spot."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].content",
          "englishWordCount": 573,
          "excerpt": "# PnL visualization: tracking profit over time Profit und loss (PnL) tracking in perpetual futures requires careful accounting across multiple dimensions: unrealized PnL from price movement, realized PnL from closed port..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].content",
          "englishWordCount": 57,
          "excerpt": "# Challenge: Calculate perpetual futures PnL Implement a PnL calculator fuer perpetual futures positions: - Compute unrealized PnL based on entry price vs mark price - Handle both long und short positions correctly - Cal..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].content",
          "englishWordCount": 73,
          "excerpt": "# Challenge: Simulate funding rate accrual Build a funding accrual simulator that processes discrete funding intervals: - Iterate through an array of funding rates und compute the payment fuer each period - Longs pay (su..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Margin- und Liquidationsmonitoring, typische Implementierungsfehler und deterministische Risk-Console-Ausgaben fuer Production-Observability."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].content",
          "englishWordCount": 613,
          "excerpt": "# Margin ratio und liquidation thresholds Margin is the collateral that backs a leveraged position. When the margin falls below a critical threshold relative to the position's notional value, the protocol forcibly closes..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 28,
          "excerpt": "The maintenance buffer ensures that when a position is liquidated, there is still margin left to pay liquidation fees und absorb slippage during the close. Without it, positions could go underwater, creating bad debt."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].content",
          "englishWordCount": 767,
          "excerpt": "# Common bugs: sign errors, units, und funding direction Perpetual futures implementations are mathematically straightforward — the formulas are basic arithmetic. Yet sign errors, unit mismatches, und funding direction b..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "englishWordCount": 12,
          "excerpt": "Negative size creates sign-convention bugs in notional, funding, margin, und liquidation calculations"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 40,
          "excerpt": "When size carries the direction sign, every formula that uses size must konto fuer the sign — not just PnL, but also notional value, funding payments, und liquidation price. Keeping size positive und branching on a separ..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].content",
          "englishWordCount": 78,
          "excerpt": "# Checkpoint: Generate a Risk Console Report Build the comprehensive risk console report that integrates all kurs concepts: - Calculate unrealized PnL und ROE fuer the position - Accumulate funding payments across all pr..."
        },
        {
          "path": "courses.defi-tx-optimizer.description",
          "englishWordCount": 16,
          "excerpt": "Beherrsche Solana-DeFi-Transaktionsoptimierung: Compute/Fee-Tuning, ALT-Strategie, Reliability-Patterns und deterministische Planung von Sendestrategien."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Diagnose von Transaction-Fehlschlaegen, Compute-Budget-Mechanik, Priority-Fee-Strategie und Grundlagen der Fee-Schaetzung."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].content",
          "englishWordCount": 585,
          "excerpt": "# Why DeFi transaktionen fail: CU limits, size, und blockhash expiry DeFi transaktionen on Solana fail fuer three primary reasons: compute budget exhaustion, transaktion size overflow, und blockhash expiry. Understanding..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "Solana allocates 200,000 CUs by default. DeFi transaktionen almost always need more, requiring an explicit SetComputeUnitLimit anweisung."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 21,
          "excerpt": "Expired blockhash transaktionen are never processed und produce no on-chain record. The client must detect the timeout und resubmit mit a fresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].content",
          "englishWordCount": 476,
          "excerpt": "# Compute budget anweisungen und priority fee strategy The Compute Budget Program provides two critical anweisungen that every serious DeFi transaktion should include: `SetComputeUnitLimit` und `SetComputeUnitPrice`. Tog..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Konto state may change between simulation und execution, causing minor CU variations. A 10% margin absorbs these differences."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].content",
          "englishWordCount": 474,
          "excerpt": "# Transaktion cost estimation und fee planning Accurate fee estimation is the foundation of a good DeFi user experience. Users need to know what a transaktion will cost before they sign it. Validatoren need sufficient fe..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].content",
          "englishWordCount": 82,
          "excerpt": "# Challenge: Build a transaktion plan mit compute budgeting Build a transaktion planning function that analyzes a set of anweisungen und produces a complete transaktion plan: - Sum estimatedCU from all anweisungen und ad..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Address-Lookup-Table-Planung, Reliability/Retry-Patterns, actionable Error-UX und vollstaendiges Send-Strategy-Reporting."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].content",
          "englishWordCount": 97,
          "excerpt": "# Challenge: Plan Address Lookup Table usage Build a function that determines the optimal Address Lookup Table strategy fuer a transaktion: - Collect all unique konto keys across anweisungen - Check which keys exist in a..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].content",
          "englishWordCount": 562,
          "excerpt": "# Reliability patterns: retry, re-quote, resend vs rebuild Production DeFi applications must handle transaktion failures gracefully. The difference between a frustrating und a reliable experience comes down to retry stra..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "Rebuilding is necessary when the transaktion's blockhash is stale or when on-chain state has changed (e.g., slippage exceeded). Simple network issues only require resending the same bytes."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "englishWordCount": 13,
          "excerpt": "To prevent many clients from retrying at the exact same moment und overwhelming the network"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].content",
          "englishWordCount": 596,
          "excerpt": "# UX: actionable error messages fuer transaktion failures Raw Solana error messages are cryptic. \"Transaktion simulation failed: Error processing Anweisung 2: custom program error: 0x1771\" tells a developer something but..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].content",
          "englishWordCount": 91,
          "excerpt": "# Checkpoint: Generate a send strategy report Build the final send strategy report that combines all kurs concepts into a comprehensive transaktion optimization plan: - Build a tx plan: sum CU estimates mit 10% margin (c..."
        },
        {
          "path": "courses.solana-mobile-signing.description",
          "englishWordCount": 20,
          "excerpt": "Beherrsche produktionsreifes mobiles Wallet-Signing auf Solana: Android-MWA-Sessions, iOS-Deep-Link-Constraints, resiliente Retries und deterministische Session-Telemetrie."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Plattform-Constraints, Connection-UX-Patterns, Signing-Timeline-Verhalten und typisierte Request-Konstruktion ueber Android/iOS."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].content",
          "englishWordCount": 730,
          "excerpt": "# Mobile signing reality check: Android vs iOS constraints Mobile wallet signing on Solana is fundamentally different from browser-based wallet interactions. The constraints imposed by Android und iOS operating systems s..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 21,
          "excerpt": "Android MWA uses foreground services to maintain a persistent communication channel between the dApp und wallet, enabling multi-request sessions without app switching."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].content",
          "englishWordCount": 736,
          "excerpt": "# Wallet connection UX patterns: connect, reconnect, und recovery Wallet connection on mobile is the first interaction users have mit your dApp. A smooth connection flow builds trust; a broken one drives users away. This..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "Network mismatches should be communicated clearly to the user mit anweisungen on how to resolve them, avoiding confusing silent failures."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].content",
          "englishWordCount": 683,
          "excerpt": "# Signing session timeline: request, wallet, und response flow Understanding the complete lifecycle of a mobile signing request is essential fuer building reliable dApps. Every sign request passes through multiple stages..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].content",
          "englishWordCount": 72,
          "excerpt": "# Challenge: Build a typed sign request Implement a sign request builder fuer Mobile Wallet Adapter: - Validate the payload type (transaktion or message) - Validate payload data (base64 fuer transaktionen, non-empty stri..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[2]",
          "englishWordCount": 14,
          "excerpt": "App identity requires at least name und URI. Icon is optional but should default to empty string."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].description",
          "englishWordCount": 17,
          "excerpt": "Session-Persistenz, Safety bei Transaction-Review-Screens, Retry-Statusmaschinen und deterministisches Session-Reporting fuer produktive Mobile-Apps."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].content",
          "englishWordCount": 64,
          "excerpt": "# Challenge: Session persistence und restoration Implement a session persistence manager fuer mobile wallet sessions: - Process a sequence of actions: save, restore, clear, und expire_check - Track wallet address und las..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].content",
          "englishWordCount": 654,
          "excerpt": "# Mobile transaktion review: what users need to see Transaktion review screens are the last line of defense between a user und a potentially harmful transaktion. On mobile, screen real estate is limited und user attentio..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 18,
          "excerpt": "Token amounts must be converted to human-readable format using the token's decimal configuration und include the symbol fuer clarity."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Balance change summaries (e.g., -1.5 SOL, +150 USDC) are the most user-friendly way to communicate what a transaktion will do."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].content",
          "englishWordCount": 731,
          "excerpt": "# One-tap retry: handling offline, rejected, und timeout states Mobile environments are inherently unreliable. Users move between WiFi und cellular, enter tunnels, close apps mid-transaktion, und wallets crash. A robust ..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].content",
          "englishWordCount": 62,
          "excerpt": "# Checkpoint: Generate a session report Implement a session report generator that summarizes a complete mobile signing session: - Count total requests, successful signs, und failed signs - Sum retry attempts across all r..."
        },
        {
          "path": "courses.solana-pay-commerce.description",
          "englishWordCount": 17,
          "excerpt": "Beherrsche Solana-Pay-Commerce-Integration: robustes URL-Encoding, QR-/Payment-Tracking-Workflows, Confirmation-UX und deterministische POS-Reconciliation-Artefakte."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Solana-Pay-Spezifikation, striktes URL-Encoding, Anatomie von Transfer Requests und deterministische Builder/Encoder-Patterns."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].content",
          "englishWordCount": 600,
          "excerpt": "# Solana Pay mentales modell und URL encoding rules Solana Pay is an open specification fuer encoding payment requests into URLs that wallets can parse und execute. Unlike traditional payment processors that rely on cent..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "The Solana Pay specification uses the 'solana:' scheme followed immediately by the recipient address mit no slashes."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Transaktion requests allow the server to build arbitrarily complex transaktionen. Transfer requests only support simple single-token transfers."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].content",
          "englishWordCount": 645,
          "excerpt": "# Transfer request anatomy: recipient, amount, reference, und labels A Solana Pay transfer request URL contains everything a wallet needs to construct und submit a payment transaktion. Each component of the URL serves a ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 22,
          "excerpt": "The reference public key is included as a non-signer konto in the transfer anweisung. The merchant polls getSignaturesForAddress(reference) to detect when the payment transaktion confirms."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].content",
          "englishWordCount": 485,
          "excerpt": "# URL builder: live preview of Solana Pay URLs Building Solana Pay URLs correctly requires understanding how each parameter contributes to the final encoded string. In this lektion, we walk through the construction proce..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].content",
          "englishWordCount": 76,
          "excerpt": "# Challenge: Encode a Solana Pay transfer request URL Build a function that encodes a Solana Pay transfer request URL from input parameters: - Validate the recipient address (must be 32-44 characters of valid base58) - V..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].content",
          "englishWordCount": 87,
          "excerpt": "# Challenge: Track payment references through confirmation states Build a reference tracking state machine that processes payment events: - States flow: pending -> found -> confirmed -> finalized (or pending -> expired) ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].content",
          "englishWordCount": 661,
          "excerpt": "# Confirmation UX: pending, confirmed, und expired states The user experience during payment confirmation is the most critical moment in any Solana Pay integration. Between the customer scanning the QR code und the merch..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "englishWordCount": 13,
          "excerpt": "Confirmed is sufficient fuer low-value POS transaktionen; finalized is needed fuer irreversible digital fulfillment"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 21,
          "excerpt": "Fuer coffee-shop-scale payments, confirmed commitment provides a strong enough guarantee. Finalized adds 6-12 seconds of latency und is only necessary when fulfillment is irreversible."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 23,
          "excerpt": "Expired requests should be clearly communicated. The customer may have been in the middle of approving — they need to know the request expired und can try again."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].content",
          "englishWordCount": 709,
          "excerpt": "# Error handling und edge cases in payment flows Production payment systems encounter a wide range of failure modes that must be handled gracefully. Solana Pay integrations face challenges unique to blockchain payments: ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].content",
          "englishWordCount": 79,
          "excerpt": "# Checkpoint: Generate a POS receipt Build the final POS receipt generator that combines all kurs concepts: - Reconstruct the Solana Pay URL from payment data (recipient, amount, spl-token, reference, label) - Generate a..."
        },
        {
          "path": "courses.wallet-ux-engineering.description",
          "englishWordCount": 15,
          "excerpt": "Beherrsche produktionsreifes Wallet-UX-Engineering auf Solana: deterministischer Verbindungszustand, Netzwerksicherheit, RPC-Resilienz und messbare Reliability-Patterns."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Wallet-Connection-Design, Network-Gating und deterministische State-Machine-Architektur fuer vorhersehbares Onboarding und Reconnect-Pfade."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].content",
          "englishWordCount": 715,
          "excerpt": "# Connection UX that doesn't suck: a design checklist Wallet connection is the first interaction a user has mit any Solana dApp. If this experience is slow, confusing, or error-prone, most users will leave before they ev..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Skeleton UI reserves the layout space fuer wallet-dependent content, preventing jarring shifts when the connection resolves und data loads."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].content",
          "englishWordCount": 731,
          "excerpt": "# Network gating und wrong-network recovery Solana has multiple clusters: mainnet-beta, devnet, testnet, und localnet. Unlike EVM chains where the wallet controls the network und emits chain-change events, Solana's netwo..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 32,
          "excerpt": "Each Solana cluster has a unique genesis hash. Comparing the RPC's genesis hash against known values is the only reliable detection method, since URL strings can be misleading und wallets don't always expose network info..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "While konto addresses are identical across clusters, the konto states (balances, data, existence) are completely different. All cached RPC data must be cleared on network switch."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].content",
          "englishWordCount": 631,
          "excerpt": "# Connection state machine: states, events, und transitions Wallet connection logic in most dApps is implemented as a tangle of boolean flags, useEffect hooks, und conditional renders. This approach leads to impossible s..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].content",
          "englishWordCount": 76,
          "excerpt": "# Challenge: Implement wallet connection state machine Build a deterministic state machine fuer wallet connection management: - States: disconnected, connecting, connected, error - Process a sequence of events und track ..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Cache-Invalidierung, RPC-Resilienz und Health-Monitoring sowie messbares Wallet-UX-Qualitaetsreporting fuer Produktionsbetrieb."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].content",
          "englishWordCount": 88,
          "excerpt": "# Challenge: Cache invalidation on wallet events Build a cache invalidation engine that processes wallet events und invalidates the correct cache entries: - Cache entries have tags: \"konto\" (wallet-specific data), \"netwo..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].content",
          "englishWordCount": 711,
          "excerpt": "# RPC reads und caching strategy fuer wallet apps Every interaction in a Solana wallet application ultimately depends on RPC calls: fetching balances, loading token konten, reading program state, und confirming transakti..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "englishWordCount": 12,
          "excerpt": "Konto states differ across clusters, so cached devnet data would be wrong fuer mainnet"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 26,
          "excerpt": "The same konto address can have completely different state on mainnet vs devnet. Without the network in the key, switching clusters would return stale data from the previous cluster."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "SWR prioritizes responsiveness by serving stale data instantly while refreshing in the background. This eliminates loading states fuer data that has only slightly exceeded its TTL."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].content",
          "englishWordCount": 888,
          "excerpt": "# RPC health monitoring und graceful degradation RPC endpoints are the lifeline of every Solana wallet application. When they go down, become slow, or return stale data, your app becomes unusable. Production wallet apps ..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].content",
          "englishWordCount": 76,
          "excerpt": "# Checkpoint: Generate a Wallet UX Report Build the final wallet UX quality report that combines all kurs concepts: - Count connection attempts (CONNECT events) und successful connections (CONNECTED events) - Calculate s..."
        },
        {
          "path": "courses.sign-in-with-solana.description",
          "englishWordCount": 18,
          "excerpt": "Beherrsche produktionsreife SIWS-Authentifizierung auf Solana: standardisierte Inputs, strikte Verifikationsinvarianten, replay-resistenter Nonce-Lifecycle und audit-faehiges Reporting."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "SIWS-Rationale, strikte Input-Feld-Semantik, Wallet-Rendering-Verhalten und deterministische Konstruktion von Sign-in-Inputs."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].content",
          "englishWordCount": 826,
          "excerpt": "# Why SIWS exists: replacing connect-und-signMessage Before Sign-In Mit Solana (SIWS) became a standard, dApps authenticated wallet holders using a two-step pattern: connect the wallet, then call `signMessage` mit an arb..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 26,
          "excerpt": "Without structured format, wallets treat signMessage payloads as opaque bytes und cannot validate or warn about the content, making it easy fuer malicious dApps to disguise harmful payloads as sign-in requests."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 24,
          "excerpt": "The server generates a unique nonce fuer each sign-in attempt. After successful verification, the nonce is marked as consumed. Any reuse of the same nonce is rejected as a replay attack."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].content",
          "englishWordCount": 842,
          "excerpt": "# SIWS input fields und sicherheit rules The Sign-In Mit Solana input is a structured object that defines every parameter of an authentication request. Each field has specific validation rules, sicherheit implications, u..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 24,
          "excerpt": "If the client generates nonces, an attacker can replay a previously captured nonce-signature pair. Server-generated nonces ensure each authentication attempt is unique und controlled by the server."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 20,
          "excerpt": "The domain field must be a plain domain name. Protocol prefixes, paths, ports, und query strings must be rejected to ensure consistent domain matching."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[2].content",
          "englishWordCount": 835,
          "excerpt": "# Message preview: how wallets render SIWS requests When a dApp sends a SIWS sign-in request to a wallet, the wallet transforms the structured input into a human-readable message that the user sees on the approval screen..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].content",
          "englishWordCount": 71,
          "excerpt": "# Challenge: Build a validated SIWS sign-in input Implement a function that creates a validated Sign-In Mit Solana input: - Validate domain (non-empty, must not include protocol prefix) - Validate nonce (at least 8 chara..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Server-seitige Verifikationsinvarianten, Nonce-Replay-Abwehr, Session-Management und deterministisches Auth-Audit-Reporting."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].content",
          "englishWordCount": 60,
          "excerpt": "# Challenge: Verify a SIWS sign-in response Implement server-side verification of a SIWS sign-in output: - Check domain matches expected domain - Check nonce matches expected nonce - Check issuedAt is not in the future r..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].content",
          "englishWordCount": 815,
          "excerpt": "# Sessions und logout: what to store und what not to store After a successful SIWS sign-in verification, the server must establish a session so the user does not need to re-authenticate on every request. Session manageme..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].content",
          "englishWordCount": 904,
          "excerpt": "# Replay protection und nonce registry design Replay attacks are the most critical threat to any signature-based authentication system. In a replay attack, an adversary captures a valid signed message und submits it agai..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].content",
          "englishWordCount": 84,
          "excerpt": "# Checkpoint: Generate an auth audit report Build the final auth audit report that combines all kurs concepts: - Process an array of authentication attempts mit address, nonce, und verified status - Track used nonces to ..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[1]",
          "englishWordCount": 12,
          "excerpt": "Count successful (verified + new nonce), failed (not verified), und replay-blocked separately."
        },
        {
          "path": "courses.priority-fees-compute-budget.description",
          "englishWordCount": 15,
          "excerpt": "Defensive Solana-Fee-Engineering mit deterministischer Compute-Planung, adaptiver Priority-Policy und bestaetigungsorientierten UX-Reliability-Vertraegen."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Inclusion-Mechanik, Compute/Fee-Kopplung und explorer-getriebenes Policy-Design mit deterministischem Reliability-Fokus."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].content",
          "englishWordCount": 618,
          "excerpt": "# Fee markets on Solana: what actually moves inclusion Priority fees on Solana are often explained as a simple slider, but production systems need a more precise model. Inclusion is influenced by contention fuer compute,..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "A large CU request mit weak price can lose inclusion, while aggressive price on oversized CU can overpay."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Spread growth signals unstable contention und lower reliability fuer naive median pricing."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].content",
          "englishWordCount": 567,
          "excerpt": "# Compute budget grundlagen und common failure modes Most transaktion failures blamed on \"network issues\" are actually planning errors in compute budget und payload sizing. A defensive client treats compute planning as a..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[2].content",
          "englishWordCount": 491,
          "excerpt": "# Explorer: compute budget planner inputs to plan Explorers are useful only when they expose policy tradeoffs clearly. Fuer a fee und compute planner, that means visualizing how input estimates, percentile targets, und c..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Deterministische Planer, Confirmation-Policy-Engines und stabile Fee-Strategie-Artefakte fuer Release-Review implementieren."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].content",
          "englishWordCount": 13,
          "excerpt": "Implement policy-based priority fee estimation using synthetic sample arrays und deterministic warnings."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[2].content",
          "englishWordCount": 13,
          "excerpt": "Encode confirmation UX policy fuer processed, confirmed, und finalized states using deterministic risk bands."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].content",
          "englishWordCount": 16,
          "excerpt": "Build stable markdown output fuer a fee strategy summary that users und support teams can review quickly."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[4].content",
          "englishWordCount": 12,
          "excerpt": "Produce a deterministic checkpoint report JSON fuer the Fee Optimizer final project artifact."
        },
        {
          "path": "courses.bundles-atomicity.description",
          "englishWordCount": 15,
          "excerpt": "Entwirf defensive Multi-Transaction-Solana-Flows mit deterministischer Atomicity-Validierung, Kompensationsmodellierung und audit-faehigem Sicherheitsreporting."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Atomicity-Modell, Risiken in Multi-Transaction-Flows und defensive Sicherheitsvalidierung zum Schutz von Nutzererwartungen."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].content",
          "englishWordCount": 554,
          "excerpt": "# Atomicity concepts und why users assume all-or-nothing Users rarely think in transaktion graphs. They think in intents: \"swap my token\" or \"close my position.\" When a workflow spans multiple transaktionen, user expecta..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].content",
          "englishWordCount": 531,
          "excerpt": "# Multi-transaktion flows: approvals, ATA creation, swaps, refunds A reliable flow simulator must encode where partial execution risk lives. In practice, risk points cluster at boundaries: before value transfer, during v..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[2].content",
          "englishWordCount": 490,
          "excerpt": "# Explorer: flow graph steps und risk points Flow graph explorers are most valuable when they highlight risk semantics, not just sequence order. A defensive explorer should display each step mit dependency context, idemp..."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Deterministische Atomicity-Validatoren, Failure-Handling-Patterns und stabile Bundle-Komposition fuer Release-Reviews implementieren."
        },
        {
          "path": "courses.mempool-ux-defense.description",
          "englishWordCount": 13,
          "excerpt": "Defensives Swap-UX-Engineering mit deterministischer Risikoeinstufung, begrenzten Slippage-Policies und incident-ready Sicherheitskommunikation."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Risiken zwischen Quote und Ausfuehrung, Slippage-Guardrails und Freshness-Entscheidungen fuer sicherere Produktions-Swaps."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].content",
          "englishWordCount": 553,
          "excerpt": "# What can go wrong between quote und execution A swap quote is a prediction, not a guarantee. Between quote generation und execution, liquidity changes, competing orders land, und network conditions shift. Users often a..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[1].content",
          "englishWordCount": 506,
          "excerpt": "# Slippage controls und guardrails Slippage settings are a policy surface, not a cosmetic preference. Defensive swap UX defines explicit bounds, context-aware defaults, und clear consequences when users attempt risky ove..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[2].content",
          "englishWordCount": 471,
          "excerpt": "# Explorer: quote freshness timer und decision table A quote freshness explorer should make policy behavior obvious under time pressure. Users und engineers need to see when a quote transitions from safe to warning to bl..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[0].content",
          "englishWordCount": 13,
          "excerpt": "Implement deterministic swap risk grading from quote, slippage, impact, hops, und liquidity inputs."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[0].hints[0]",
          "englishWordCount": 12,
          "excerpt": "Use additive policy scoring from quote freshness, slippage, impact, route, und liquidity."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.description",
          "englishWordCount": 14,
          "excerpt": "Baue produktionsreife deterministische Indexing-Pipelines fuer duplicate-sichere Ingestion, Reorg-Handling und integritaetsorientiertes Reporting."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Indexing-Basics, Reorg/Confirmation-Realitaet und Pipeline-Stufen fuer nachvollziehbare und sichere Ingestion."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].content",
          "englishWordCount": 536,
          "excerpt": "# Indexing 101: logs, konten, und transaktion parsing Reliable indexers are not just fast parsers. They are consistency systems that decide what to trust, when to trust it, und how to recover from changing chain history...."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[1].content",
          "englishWordCount": 479,
          "excerpt": "# Reorgs und fork choice: why confirmed is not finalized Confirmation labels are useful but often misunderstood in indexing pipelines. A confirmed event has stronger confidence than processed, but it is not equivalent to..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[2].content",
          "englishWordCount": 490,
          "excerpt": "# Explorer: ingest to dedupe to confirm to apply A pipeline explorer should explain transformation stages clearly so engineers can inspect where correctness can break. Fuer indexing reliability, the core stages are inges..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Confirmation-Logik, Backfill/Idempotency-Planung und Integrity-Checks fuer stabile Pipeline-Reports implementieren."
        },
        {
          "path": "courses.rpc-reliability-latency.description",
          "englishWordCount": 15,
          "excerpt": "Entwickle produktionsreife Multi-Provider-Solana-RPC-Clients mit deterministischen Retry-, Routing-, Caching- und Observability-Policies."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Real-world RPC failure behavior, endpoint selection strategy, und deterministic retry policy modeling."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].content",
          "englishWordCount": 548,
          "excerpt": "# RPC failures in real life: timeouts, 429s, stale nodes Reliable client infrastructure begins mit realistic failure assumptions. RPC calls fail fuer many reasons: transient network timeouts, provider rate limits, stale ..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].content",
          "englishWordCount": 449,
          "excerpt": "# Multi-endpoint strategies: hedged requests und fallbacks Multi-endpoint design is more than adding a backup URL. It is a scheduling problem where each request should be sent to the most suitable endpoint given recent h..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].content",
          "englishWordCount": 485,
          "excerpt": "# Explorer: retry/backoff simulator Retry und backoff policies determine whether clients recover gracefully or amplify outages. A simulator should make schedule behavior explicit so teams can reason about user latency un..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Build deterministic policy engines fuer routing, retries, metrics reduction, und health report exports."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[2].content",
          "englishWordCount": 12,
          "excerpt": "Emit deterministic cache invalidation actions when konto updates und lag signals arrive."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].content",
          "englishWordCount": 13,
          "excerpt": "Export deterministic JSON und markdown health report artifacts fuer multi-provider reliability review."
        },
        {
          "path": "courses.rust-data-layout-borsh.description",
          "englishWordCount": 15,
          "excerpt": "Rust-first Solana-Data-Layout-Engineering mit deterministischen Byte-Level-Tooling und kompatibilitaetssicheren Schema-Praktiken."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Alignment behavior, Borsh encoding rules, und praktisch parsing safety fuer stable byte-level contracts."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].content",
          "englishWordCount": 579,
          "excerpt": "# Memory layout: alignment, padding, und why Solana konten care Rust layout behavior is deterministic inside one compiled binary but can vary when assumptions are implicit. Fuer Solana konten, this matters because raw by..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].content",
          "englishWordCount": 515,
          "excerpt": "# Struct und enum layout pitfalls plus Borsh rules Borsh is widely used because it gives deterministic serialization across languages, but teams still get tripped up by how enums, vectors, und strings map to bytes. Under..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[2].content",
          "englishWordCount": 467,
          "excerpt": "# Explorer: layout visualizer fuer field offsets A layout visualizer turns abstract alignment rules into concrete numbers engineers can review. Instead of debating whether a struct is \"probably fine,\" teams can inspect e..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement deterministic layout analysis, encoding/decoding, safe parsing, und compatibility-focused reporting helpers."
        },
        {
          "path": "courses.rust-errors-invariants.description",
          "englishWordCount": 16,
          "excerpt": "Baue typisierte Invariant-Guard-Libraries mit deterministischen Evidenz-Artefakten, kompatibilitaetssicheren Error-Vertraegen und audit-faehigem Reporting."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Typed error taxonomy, Result/context propagation patterns, und deterministic invariant design fundamentals."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].content",
          "englishWordCount": 565,
          "excerpt": "# Error taxonomy: recoverable vs fatal Rust encourages explicit error modeling, but teams still produce weak error contracts when they rely on ad hoc strings or inconsistent wrappers. In Solana und Anchor-adjacent system..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[1].content",
          "englishWordCount": 541,
          "excerpt": "# Result<T, E> patterns, ? operator, und context Result-based control flow is one of Rust's strongest tools fuer building robust services und on-chain-adjacent clients. The key is not merely using Result, but designing e..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].content",
          "englishWordCount": 477,
          "excerpt": "# Explorer: invariant decision tree An invariant decision tree helps teams reason about guard ordering und failure priority. Not every invariant should be checked in arbitrary order. Early checks should prevent expensive..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Implement guard helpers, evidence-chain generation, und stable audit reporting fuer reliability und incident response."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.description",
          "englishWordCount": 14,
          "excerpt": "Simuliere und optimiere Compute-Kostenverhalten mit deterministischem Rust-first-Tooling und budgetgetriebener Performance-Governance."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Rust leistung mentales modells, data-structure tradeoffs, und deterministic cost reasoning fuer reliable optimization decisions."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].content",
          "englishWordCount": 519,
          "excerpt": "# Leistung mentales modell: allocations, clones, hashing Rust leistung work in Solana ecosystems is mostly about data movement discipline. Teams often chase micro-optimizations while ignoring dominant costs such as repea..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].content",
          "englishWordCount": 494,
          "excerpt": "# Data structures: Vec, HashMap, BTreeMap tradeoffs Data structure choice is one of the highest leverage leistung decisions in Rust systems. Vec offers compact contiguous storage und predictable iteration speed. HashMap ..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].content",
          "englishWordCount": 470,
          "excerpt": "# Explorer: cost model sandbox A cost sandbox lets teams test optimization hypotheses without waiting fuer full benchmark infrastructure. Provide operation counts, compute weighted costs, und inspect which buckets domina..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Build deterministic profilers, recommendation engines, und report outputs aligned to explicit leistung budgets."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.description",
          "englishWordCount": 15,
          "excerpt": "Rust-first Async-Pipeline-Engineering mit begrenzter Concurrency, replay-sicheren Reducern und deterministischem operativem Reporting."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Async/concurrency fundamentals, backpressure behavior, und deterministic execution modeling fuer indexer reliability."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].content",
          "englishWordCount": 526,
          "excerpt": "# Async fundamentals: futures, tasks, channels Rust async systems are built on explicit scheduling rather than implicit thread-per-task models. Futures represent pending work, executors poll futures, und channels coordin..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[1].content",
          "englishWordCount": 470,
          "excerpt": "# Concurrency limits und backpressure Backpressure is not optional in high-volume pipelines. Without it, producer speed can overwhelm reducers, retries, or storage sinks. A resilient design sets explicit concurrency caps..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[2].content",
          "englishWordCount": 492,
          "excerpt": "# Explorer: pipeline graph und concurrency Pipeline graphs help teams communicate stage boundaries, concurrency budgets, und retry behaviors. A graph that shows ingest, dedupe, retry, und snapshot stages mit explicit cap..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Implement deterministic scheduling, retries, dedupe/reducer stages, und report exports fuer reorg-safe pipeline operations."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.description",
          "englishWordCount": 15,
          "excerpt": "Rust Macro/Codegen-Sicherheit vermittelt durch deterministisches Parser- und Check-Generation-Tooling mit auditfreundlichen Outputs."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Macro mentales modells, constraint DSL design, und safety-driven code generation fundamentals."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].content",
          "englishWordCount": 517,
          "excerpt": "# Macro mentales modell: declarative vs procedural Rust macros come in two broad forms: declarative macros fuer pattern-based expansion und procedural macros fuer syntax-aware transformation. Anchor relies heavily on mac..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].content",
          "englishWordCount": 479,
          "excerpt": "# Safety through codegen: constraint checks Constraint codegen converts compact declarations into explicit runtime guards. Typical constraints include signer presence, konto ownership, has-one relations, und mutability r..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].content",
          "englishWordCount": 478,
          "excerpt": "# Explorer: constraint builder to generated checks A constraint builder explorer helps engineers see how DSL choices affect generated code und runtime safety outcomes. Input one attribute line, observe parsed AST, genera..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Parse DSL constraints, generate checks, run deterministic evaluations, und publish stable safety reports."
        },
        {
          "path": "courses.anchor-upgrades-migrations.description",
          "englishWordCount": 15,
          "excerpt": "Entwirf produktionstaugliche Anchor-Release-Workflows mit deterministischer Migrationsplanung, Upgrade-Gates, Rollback-Playbooks und Readiness-Evidenz."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Authority lifecycle, konto versioning strategy, und deterministic upgrade risk modeling fuer Anchor releases."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].content",
          "englishWordCount": 576,
          "excerpt": "# Upgrade authority lifecycle in Anchor programs Anchor makes anweisung development easier, but upgrade safety still depends on disciplined control of program authority. In production Solana systems, most upgrade inciden..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[1].content",
          "englishWordCount": 535,
          "excerpt": "# Konto versioning und migration strategy Solana konten are long-lived state containers, so program upgrades must respect historical data. In Anchor, adding or changing konto fields can be safe, risky, or catastrophic de..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].content",
          "englishWordCount": 476,
          "excerpt": "# Explorer: upgrade risk matrix A useful upgrade explorer should show cause-und-effect between release inputs und safety outcomes. If a flag changes, engineers should immediately see how severity und readiness changes. T..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Safety validation gates, rollback planning, und deterministic readiness artifacts fuer controlled migration execution."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].content",
          "englishWordCount": 13,
          "excerpt": "Implement deterministic blocking issue checks fuer authority, artifact hash, und dry-run status."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].content",
          "englishWordCount": 466,
          "excerpt": "# Rollback strategy und incident playbooks Even strong upgrade plans can encounter surprises: incompatible downstream clients, unexpected konto edge cases, or release pipeline mistakes. Teams that recover quickly are the..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].content",
          "englishWordCount": 15,
          "excerpt": "Produce the final deterministic checkpoint artifact mit release tag, readiness flag, und migration batch count."
        },
        {
          "path": "courses.solana-reliability.description",
          "englishWordCount": 18,
          "excerpt": "Produktionsfokussiertes Reliability Engineering fuer Solana-Systeme: Fault Tolerance, Retries, Deadlines, Circuit Breakers und Graceful Degradation mit messbaren Ergebnissen."
        },
        {
          "path": "courses.solana-reliability.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Implement fault-tolerance building blocks mit clear failure classification, retry boundaries, und deterministic recovery behavior."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[0].content",
          "englishWordCount": 227,
          "excerpt": "Fault tolerance in Solana systems is not just about catching errors. It is about deciding which failures are safe to retry, which should fail fast, und how to preserve user trust while doing both. A praktisch reliability..."
        },
        {
          "path": "courses.solana-reliability.modules[1].description",
          "englishWordCount": 17,
          "excerpt": "Build resilience mechanisms (circuit breakers, bulkheads, und rate controls) that protect core user flows during provider instability."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[0].content",
          "englishWordCount": 191,
          "excerpt": "Resilience patterns are controls that prevent localized failures from becoming system-wide incidents. On Solana integrations, they are especially important because provider health can change quickly under bursty network ..."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].content",
          "englishWordCount": 14,
          "excerpt": "Implement a circuit breaker pattern that opens after consecutive failures und closes after a recovery period."
        },
        {
          "path": "courses.solana-testing-strategies.description",
          "englishWordCount": 19,
          "excerpt": "Umfassende produktionsorientierte Testing-Strategie fuer Solana: deterministische Unit Tests, realistische Integration Tests, Fuzz/Property Testing und Release-Confidence-Reporting."
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Build deterministic unit und integration tests layers mit clear ownership of invariants, fixtures, und failure diagnostics."
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[0].content",
          "englishWordCount": 166,
          "excerpt": "Tests Solana systems effectively requires layered confidence, not one giant test suite. Unit tests validate pure logic: math, state transitions, und invariant checks. They should be fast, deterministic, und run on every ..."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Use fuzzing, property-based tests, und mutation-style checks to expose edge-case failures before release."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[0].content",
          "englishWordCount": 160,
          "excerpt": "Fortgeschritten tests techniques uncover failures that example-based tests rarely find. Fuzzing explores broad random input space to trigger parser edge cases, boundary overflows, und unexpected state combinations. It is..."
        },
        {
          "path": "courses.solana-program-optimization.description",
          "englishWordCount": 16,
          "excerpt": "Entwickle produktionsreife Solana-Performance: Compute-Budgeting, effiziente Account-Layouts, Memory/Rent-Tradeoffs und deterministische Optimierungs-Workflows."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Optimize compute-heavy paths mit explicit CU budgets, operation-level profiling, und predictable leistung tradeoffs."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[0].content",
          "englishWordCount": 118,
          "excerpt": "Compute units are the hard resource budget that shapes what your Solana program can do in a single transaktion. Leistung optimization starts by treating CU usage as a contract, not an afterthought. A reliable optimizatio..."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Design memory/storage-efficient konto layouts mit rent-aware sizing, serialization discipline, und safe migration planning."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[0].content",
          "englishWordCount": 103,
          "excerpt": "Konto data optimization is both a cost und correctness discipline. Poor layouts increase rent, slow parsing, und make migrations fragile. Design principles: - Keep hot fields compact und easy to parse. - Use fixed-size r..."
        },
        {
          "path": "courses.solana-tokenomics-design.description",
          "englishWordCount": 17,
          "excerpt": "Entwirf robuste Solana-Tokenoekonomien mit Disziplin bei Distribution, Vesting-Sicherheit, Staking-Incentives und operativ verteidigbaren Governance-Mechaniken."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Model token allocation und vesting systems mit explicit fairness, unlock predictability, und deterministic accounting rules."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[0].content",
          "englishWordCount": 100,
          "excerpt": "Token distribution is a sicherheit und credibility decision, not just a spreadsheet exercise. Allocation und vesting rules shape long-term trust in the protocol. A strong distribution model answers: - who receives tokens..."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Design staking und governance mechanics mit clear incentive alignment, anti-manipulation constraints, und measurable participation health."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[0].content",
          "englishWordCount": 97,
          "excerpt": "Staking und governance systems must balance participation incentives mit manipulation resistance. Rewarding lock behavior is useful, but poorly tuned models can over-concentrate influence. Core design questions: 1) How i..."
        },
        {
          "path": "courses.solana-defi-primitives.description",
          "englishWordCount": 17,
          "excerpt": "Baue praktische DeFi-Grundlagen auf Solana: AMM-Mechanik, Liquiditaetsabrechnung, Lending-Primitives und flash-loan-sichere Compositions-Patterns."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Implement AMM und liquidity primitives mit deterministic math, slippage-aware outputs, und LP accounting correctness."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[0].content",
          "englishWordCount": 101,
          "excerpt": "AMM fundamentals are simple in formula but subtle in implementation quality. The invariant math must be deterministic, fee handling explicit, und rounding behavior consistent across paths. Fuer constant-product pools, ro..."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Model lending und flash-loan flows mit collateral safety, utilization-aware pricing, und strict repayment invariants."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[0].content",
          "englishWordCount": 90,
          "excerpt": "Lending primitives und flash-loan logic are powerful but unforgiving. Safety depends on strict collateral valuation, clear LTV/threshold rules, und deterministic repayment checks. A praktisch lending model should define:..."
        },
        {
          "path": "courses.solana-nft-standards.description",
          "englishWordCount": 16,
          "excerpt": "Implementiere Solana-NFTs mit produktionsreifen Standards: Metadata-Integritaet, Collection-Disziplin und fortgeschrittene programmierbare/nicht uebertragbare Verhaltensweisen."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Build core NFT functionality mit standards-compliant metadata, collection verification, und deterministic asset-state handling."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[0].content",
          "englishWordCount": 84,
          "excerpt": "NFT architecture on Solana combines token mechanics mit metadata und collection semantics. A correct implementation requires more than minting a token mit supply one. Core components include: - mint/state ownership corre..."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Implement fortgeschritten NFT behaviors (soulbound und programmable flows) mit explicit policy controls und safe update semantics."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[0].content",
          "englishWordCount": 78,
          "excerpt": "Fortgeschritten NFT features introduce policy complexity that must be explicit. Soulbound behavior, programmable restrictions, und dynamic metadata updates all expand failure surface. Fuer soulbound models, non-transfera..."
        },
        {
          "path": "courses.solana-cpi-patterns.description",
          "englishWordCount": 18,
          "excerpt": "Beherrsche CPI-Komposition auf Solana mit sicherer Account-Validierung, PDA-Signer-Disziplin und deterministischen Multi-Programm-Orchestrierungs-Patterns."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Build CPI fundamentals mit strict konto/signer checks, ownership validation, und safe PDA signing boundaries."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[0].content",
          "englishWordCount": 91,
          "excerpt": "Programmuebergreifender Aufruf (CPI) is where Solana composability becomes praktisch und where many sicherheit failures appear. The caller controls konto lists, so every CPI boundary must be treated as untrusted input. S..."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Compose fortgeschritten multi-program flows mit atomicity awareness, consistency checks, und deterministic failure handling."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[0].content",
          "englishWordCount": 92,
          "excerpt": "Multi-program composition introduces sequencing und consistency risk. Even when each CPI call is correct in isolation, combined flows can violate business invariants if ordering or rollback assumptions are weak. Robust c..."
        },
        {
          "path": "courses.solana-mev-strategies.description",
          "englishWordCount": 17,
          "excerpt": "Produktionsfokussiertes Transaction-Ordering-Engineering auf Solana: MEV-aware Routing, Bundle-Strategie, Liquidations/Arbitrage-Modellierung und nutzerschuetzende Ausfuehrungskontrollen."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].description",
          "englishWordCount": 17,
          "excerpt": "Understand MEV mechanics und transaktion ordering realities, then model opportunities und risks mit deterministic safety-aware policies."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[0].content",
          "englishWordCount": 167,
          "excerpt": "Maximal Extractable Value (MEV) on Solana is fundamentally about transaktion ordering under limited blockspace. Whether you are building trading tools, liquidation infrastructure, or user-facing apps, you need a realisti..."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Design fortgeschritten ordering/bundle strategies mit explicit risk controls, failure handling, und user-impact guardrails."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[0].content",
          "englishWordCount": 126,
          "excerpt": "Fortgeschritten transaktion-ordering strategies require disciplined orchestration, not just faster opportunity scans. Bundle-oriented execution is valuable because it can express dependency sets und all-or-nothing intent..."
        },
        {
          "path": "courses.solana-deployment-cicd.description",
          "englishWordCount": 15,
          "excerpt": "Produktions-Deployment-Engineering fuer Solana-Programme: Umgebungsstrategie, Release-Gating, CI/CD-Qualitaetskontrollen und upgrade-sichere operative Workflows."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Model environment-specific bereitstellung behavior mit deterministic configs, artifact checks, und release preflight validation."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[0].content",
          "englishWordCount": 142,
          "excerpt": "Solana bereitstellung is not one command; it is a release system mit environment-specific risk. Localnet, devnet, und mainnet each serve different validation goals, und production quality depends on using them intentiona..."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Build CI/CD pipelines that enforce build/test/sicherheit gates, compatibility checks, und controlled rollout/rollback evidence."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[0].content",
          "englishWordCount": 120,
          "excerpt": "CI/CD fuer Solana should enforce release quality, not just automate command execution. A praktisch pipeline includes staged gates: 1) static quality gate (lint/type/sicherheit checks), 2) deterministic unit/integration t..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.description",
          "englishWordCount": 19,
          "excerpt": "Baue sicherere Cross-Chain-Integrationen fuer Solana mit Wormhole-aehnlicher Messaging-Logik, Attestation-Verifikation und deterministischen Bridge-State-Kontrollen."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Understand cross-chain messaging trust boundaries, guardian attestations, und deterministic verification pipelines."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].content",
          "englishWordCount": 139,
          "excerpt": "Cross-chain messaging is a trust-boundary problem before it is a transport problem. In Wormhole-style systems, messages are observed, attested, und consumed across different chain environments, each mit independent failu..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implement asset-bridging patterns mit strict supply/accounting invariants, replay protection, und reconciliation workflows."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[0].content",
          "englishWordCount": 121,
          "excerpt": "Token bridging requires strict supply und state invariants. Lock-und-mint und burn-und-mint models both rely on one central rule: represented supply across chains must remain coherent. Critical controls include: - single..."
        },
        {
          "path": "courses.solana-oracle-pyth.description",
          "englishWordCount": 16,
          "excerpt": "Integriere Solana-Oracle-Feeds sicher: Preisvalidierung, Confidence/Staleness-Policy und Multi-Source-Aggregation fuer resiliente Protokollentscheidungen."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].description",
          "englishWordCount": 14,
          "excerpt": "Understand oracle data semantics (price, confidence, staleness) und enforce deterministic validation before business logic."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[0].content",
          "englishWordCount": 115,
          "excerpt": "Oracle integration is a risk-control problem, not a data-fetch problem. Price feeds must be evaluated fuer freshness, confidence, und contextual fitness before they drive protocol decisions. A safe oracle validation pipe..."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].description",
          "englishWordCount": 18,
          "excerpt": "Design multi-oracle aggregation und consensus policies that reduce single-source failure risk while remaining explainable und testable."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[0].content",
          "englishWordCount": 110,
          "excerpt": "Multi-oracle aggregation reduces single-point dependency but adds policy complexity. The goal is not to average blindly; it is to produce a robust decision value mit clear confidence in adverse conditions. Common strateg..."
        },
        {
          "path": "courses.solana-dao-tooling.description",
          "englishWordCount": 17,
          "excerpt": "Baue produktionsreife DAO-Systeme auf Solana: Proposal-Governance, Voting-Integritaet, Treasury-Kontrollen und deterministische Ausfuehrungs/Reporting-Workflows."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Implement governance mechanics mit explicit proposal lifecycle rules, voting-power logic, und deterministic state transitions."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[0].content",
          "englishWordCount": 113,
          "excerpt": "DAO governance architecture is a system of enforceable process rules. Proposal creation, voting, und execution must be deterministic, auditable, und resistant to manipulation. A robust governance model defines: 1) propos..."
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Engineer treasury und execution tooling mit policy gates, timelock safeguards, und auditable automation outcomes."
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[0].content",
          "englishWordCount": 111,
          "excerpt": "DAO treasury management is where governance intent becomes real financial action. Treasury tooling must therefore combine flexibility mit strict policy constraints. Core controls include: - spending limits und role-based..."
        },
        {
          "path": "courses.solana-gaming.description",
          "englishWordCount": 17,
          "excerpt": "Baue produktionsreife On-Chain-Game-Systeme auf Solana: effiziente State-Modelle, Turn-Integritaet, Fairness-Kontrollen und skalierbare Progressionsoekonomie."
        },
        {
          "path": "courses.solana-gaming.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Design game state und turn logic mit deterministic transitions, storage efficiency, und anti-cheat validation boundaries."
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[0].content",
          "englishWordCount": 139,
          "excerpt": "On-chain game design on Solana is a systems-engineering tradeoff between fairness, responsiveness, und cost. The best designs keep critical rules verifiable while minimizing expensive state writes. Core architecture deci..."
        },
        {
          "path": "courses.solana-gaming.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implement fairness-oriented randomness und integrity controls that keep gameplay auditable und dispute-resistant."
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[0].content",
          "englishWordCount": 117,
          "excerpt": "Randomness is one of the hardest fairness problems in blockchain games because execution is deterministic. Robust designs avoid naive pseudo-randomness tied directly to manipulable context. Praktisch fairness patterns in..."
        },
        {
          "path": "courses.solana-permanent-storage.description",
          "englishWordCount": 18,
          "excerpt": "Integriere permanentes dezentrales Storage mit Solana ueber Arweave-aehnliche Workflows: Content Addressing, Manifest-Integritaet und verifizierbarer Langzeit-Datenzugriff."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Understand permanent-storage architecture und build deterministic linking between Solana state und external immutable content."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[0].content",
          "englishWordCount": 122,
          "excerpt": "Permanent storage integration is a data durability contract. On Solana, storing full content on-chain is often impractical, so systems rely on immutable external storage references anchored by on-chain metadata. A robust..."
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Work mit manifests, verification pipelines, und cost/leistung controls fuer reliable long-lived data serving."
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[0].content",
          "englishWordCount": 101,
          "excerpt": "Manifests turn many stored assets into one navigable root, but they introduce their own integrity responsibilities. A manifest is only trustworthy if path mapping und referenced content IDs are validated consistently. Ke..."
        },
        {
          "path": "courses.solana-staking-economics.description",
          "englishWordCount": 16,
          "excerpt": "Verstehe Solana-Staking und Validator-Oekonomie fuer reale Entscheidungen: Delegationsstrategie, Reward-Dynamik, Kommissionswirkungen und operative Nachhaltigkeit."
        },
        {
          "path": "courses.solana-staking-economics.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Lerne native staking mechanics mit deterministic reward modeling, validator selection criteria, und delegation risk framing."
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[0].content",
          "englishWordCount": 113,
          "excerpt": "Solana staking economics is an incentives system connecting delegators, validatoren, und network sicherheit. Good delegation decisions require more than chasing headline APY. Delegators should evaluate: 1) validator leis..."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Analyze validator-side economics, operational cost pressure, und incentive alignment fuer long-term network health."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[0].content",
          "englishWordCount": 113,
          "excerpt": "Validator economics balances revenue opportunities against operational costs und reliability obligations. Sustainable validatoren optimize fuer long-term trust, not short-term extraction. Revenue sources include inflatio..."
        },
        {
          "path": "courses.solana-account-abstraction.description",
          "englishWordCount": 18,
          "excerpt": "Implementiere Smart-Wallet/Account-Abstraction-Patterns auf Solana mit programmierbarer Autorisierung, Recovery-Kontrollen und policy-gesteuerter Transaction-Validierung."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].description",
          "englishWordCount": 16,
          "excerpt": "Build smart-wallet fundamentals including multisig und social-recovery designs mit clear trust und failure boundaries."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[0].content",
          "englishWordCount": 119,
          "excerpt": "Konto abstraction on Solana shifts control from a single key to programmable policy. Smart wallets can enforce richer authorization logic, but policy complexity must be managed carefully. A robust smart-wallet design def..."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implement programmable validation policies (limits, allowlists, time/risk rules) mit deterministic enforcement und auditability."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[0].content",
          "englishWordCount": 110,
          "excerpt": "Programmable validation is where smart wallets deliver real value, but it is also where subtle policy bugs appear. Typical controls include spending limits, destination allowlists, time windows, und risk-score gates. The..."
        },
        {
          "path": "courses.solana-pda-mastery.description",
          "englishWordCount": 19,
          "excerpt": "Beherrsche fortgeschrittenes PDA-Engineering auf Solana: Seed-Schema-Design, Bump-Disziplin und sichere Cross-Program-PDA-Nutzung auf Produktionsniveau."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].description",
          "englishWordCount": 15,
          "excerpt": "Build strong PDA foundations mit deterministic derivation, canonical seed composition, und collision-resistant namespace strategy."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[0].content",
          "englishWordCount": 116,
          "excerpt": "Programmabgeleitete Adressen (PDAs) are deterministic authority und state anchors on Solana. Their power comes from predictable derivation; their risk comes from inconsistent seed discipline. A strong PDA design standard..."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Implement fortgeschritten PDA patterns (nested/counter/stateful) while preserving sicherheit invariants und migration safety."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[0].content",
          "englishWordCount": 107,
          "excerpt": "Fortgeschritten PDA patterns solve real scaling und composability needs but increase design complexity. Nested PDAs, counter-based PDAs, und multi-tenant PDA namespaces each require explicit invariants around uniqueness,..."
        },
        {
          "path": "courses.solana-economics.description",
          "englishWordCount": 17,
          "excerpt": "Analysiere Solana-Economics im Produktionskontext: Inflation/Fee-Burn-Wechselwirkung, Staking-Flows, Supply-Bewegung und Nachhaltigkeits-Tradeoffs von Protokollen."
        },
        {
          "path": "courses.solana-economics.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand Solana macro token economics (inflation, burn, rewards, fees) mit deterministic scenario modeling."
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[0].content",
          "englishWordCount": 118,
          "excerpt": "Solana economics is the interaction of issuance, burn, staking rewards, und usage demand. Sustainable protocol decisions require understanding these flows as a system, not isolated metrics. Core mechanisms include: 1) in..."
        },
        {
          "path": "courses.solana-economics.modules[1].description",
          "englishWordCount": 17,
          "excerpt": "Model token flow dynamics und sustainability signals using supply categories, unlock events, und behavior-driven liquidity effects."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[0].content",
          "englishWordCount": 117,
          "excerpt": "Token flow analysis turns abstract economics into operational insight. The key is to track where tokens are (staked, circulating, locked, treasury, pending unlock) und how they move over time. Useful flow metrics include..."
        }
      ],
      "totals": {
        "exactEnglishCount": 916,
        "englishLikeCount": 477
      }
    },
    {
      "locale": "zh-CN",
      "exactEnglishMatches": [
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].options[0]",
          "text": "To calculate NFT metadata size"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "It is the user who paid the creation fee forever"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "What does `executable: true` indicate?"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].options[1]",
          "text": "Token balances are program-specific state managed by the token program"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "This is your active signer public key."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[1]",
          "text": "Convert SOL to lamports using 1_000_000_000 multiplier."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[0]",
          "text": "A client-only simulation mode"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[1]",
          "text": "Calling one on-chain program from another on-chain program"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].prompt",
          "text": "Why are PDAs useful?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].options[0]",
          "text": "They let programs derive deterministic addresses without private keys"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].options[1]",
          "text": "The runtime on behalf of the program when invoke_signed seeds match"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].prompt",
          "text": "What happens if you change a seed?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[0]",
          "text": "The PDA stays the same but bump changes"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[2]",
          "text": "You derive a different PDA address"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].explanation",
          "text": "Seed bytes are part of the hash input, so any change yields a different derived address."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "A compressed NFT ledger entry"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[2].prompt",
          "text": "What authority controls minting?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[0]",
          "text": "Parse flags in pairs: --key value."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[2]",
          "text": "Construct JSON object in fixed key order before JSON.stringify."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does Anchor generate automatically from your program definitions?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Automatic PDA funding from devnet faucets"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A JSON interface used by clients/tests/tooling to call your program correctly"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "A private key format used only by on-chain programs"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is a seeds constraint verifying?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "That a token mint has 9 decimals"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].prompt",
          "text": "Why is a PDA considered off-curve?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].options[0]",
          "text": "It is derived to avoid having a corresponding private key"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].explanation",
          "text": "Off-curve means no user-held private key exists; programs authorize via seed proofs."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].prompt",
          "text": "What breaks if you change one PDA seed value?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[1]",
          "text": "Only the bump changes while address stays fixed"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[2]",
          "text": "Nothing changes unless RPC endpoint changes"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].explanation",
          "text": "PDA derivation is seed-sensitive. Any seed change creates a different address namespace."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].title",
          "text": "Initialize Counter PDA (deterministic)"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[0]",
          "text": "Use a deterministic hash-like reducer over programId + authorityPubkey + static seed."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[0]",
          "text": "Represent state as a pure JS structure so increment can be deterministic in tests."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[1]",
          "text": "Return a new state object from applyIncrement; avoid mutating the input object in-place."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the main role of optional integration tests?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Validate network execution paths after deterministic logic is proven"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Replace all unit tests"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Avoid asserting exact outputs"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Integration tests add runtime confidence but should not replace deterministic core checks."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do simulation failures happen even before final send succeeds?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because fee payer is irrelevant"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[0]",
          "text": "Compose the checkpoint from deterministic helper functions to keep output stable."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Where do SPL token balances actually live?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why keep raw amounts as integer strings in model code?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because decimals are always 9"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "Show pending overlays first, mutate durable balances only after stronger confirmation"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[2]",
          "text": "Disable activity feed until finalized"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "Optimistic overlays are useful, but confirmed state must remain authoritative."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].options[2]",
          "text": "Because commitment levels require it by protocol"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Phase-specific metrics enable actionable incident diagnosis."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is ordering by (ts, id) preferred over timestamp-only replay?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Stable ordering prevents environment-dependent state divergence."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should happen when the same event id arrives twice?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Idempotency guarantees deterministic behavior under retries."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[0]",
          "text": "Sort by (ts, id) before applying events."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[1]",
          "text": "Deduplicate by event id before snapshot interval checks."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[2]",
          "text": "Build checksum from stable snapshot metadata, not random values."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[0]",
          "text": "Use fixed-scale integers (micro USD) instead of floating point."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[1]",
          "text": "Apply filter -> search -> sort in a deterministic order."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "To reduce CSS size only"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because rate limits require it"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the main risk of generic one-size-fits-all error banners?"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Users cannot distinguish recovery actions across failure classes"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "They always break hydration"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Which metric should drive route selection at execution size?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Deterministic outAmount from full route simulation"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Displayed ticker price only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Lowest hop count only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Route quality is output-at-size, not headline spot labels."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does slippage tolerance directly determine?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "The minOut acceptance bound"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the deterministic minOut formula?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "minOut is a bounded percentage reduction from outAmount."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Why keep per-hop fee breakdowns?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Per-hop fee attribution makes route behavior auditable."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Minimize hop count always"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Choose first enumerated route"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "Why simulate virtual reserves per candidate route?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Virtual simulation avoids shared-state contamination."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].content",
          "text": "# Implement token/pool model + constant-product quote calc Implement deterministic CPMM quoting: - out = (reserveOut * inAfterFee) / (reserveIn + inAfterFee) - fee = floor(inAmount * feeBps / 10000) - impactBps from spot..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].hints[0]",
          "text": "Use inAfterFee = inAmount - floor(inAmount * feeBps / 10000)."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].hints[2]",
          "text": "Keep sorting deterministic to avoid route flicker."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[0]",
          "text": "Use virtual pool copies so fixture reserves are not mutated."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[2]",
          "text": "Return structured errors when pools or route links are invalid."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].prompt",
          "text": "What should happen when quote freshness expires?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].options[2]",
          "text": "Increase slippage automatically without notifying user"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Freshness boundaries should trigger deterministic recomputation."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which failures are not solved by blind retries?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].explanation",
          "text": "Planner errors require input/route changes, not repetition."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[0]",
          "text": "Keep output key order stable: swapPlan first, swapSummary second."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[1]",
          "text": "Path should be deterministic symbols along route hops."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[2]",
          "text": "Include fixtureHash + modelVersion under determinism metadata."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because owner checks improve rendering speed"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Because owner checks replace signer checks"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Only that an amount field exists"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the purpose of trace hashing in an audit workflow?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].options[1]",
          "text": "To replace structured test assertions"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Which sequence represents a valid evidence chain?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "Reproduce -> trace -> impact -> fix -> verify"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[1]",
          "text": "Fix -> reproduce -> trace -> release"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Accepting any PDA-like prefix"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Trusting client-provided bump values"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Deterministic re-derivation closes spoofable PDA substitution paths."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Because most exploitable bugs only appear under malformed or adversarial input"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Because traces are optional without them"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[0]",
          "text": "Compute drained lamports from recipient before/after."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[1]",
          "text": "Include deterministic field ordering in the JSON output."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[2]",
          "text": "The explanation should mention missing signer/owner validation."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].hints[2]",
          "text": "Keep output key order stable."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[1]",
          "text": "Use fixedBlockedExploit to set blocked status."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[2]",
          "text": "Return error code only when blocked is true."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].options[1]",
          "text": "They are interchangeable labels"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Good reports separate damage potential from exploit feasibility."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which recommendation is most actionable?"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[0]",
          "text": "Return stable, minimal checkpoint metadata."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[2]",
          "text": "Preserve scenarioIds order as provided."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why generate an offline deterministic launch pack before devnet/mainnet actions?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should supply checks use integer math instead of floating-point UI values?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "To avoid rounding drift in launch invariants"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Because decimals are always zero"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the primary role of freeze authority?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[0]",
          "text": "It can materially change effective fee behavior across transfer sizes"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "It is ignored once mint is initialized"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is a core risk of permanent delegate configuration?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].hints[2]",
          "text": "Keep output key order stable so checkpoint tests are reproducible."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].hints[1]",
          "text": "Append extension steps in deterministic order so plan labels are stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[0]",
          "text": "Transfer fee formula: fee = min(maxFee, floor(amount * feeBps / 10000))."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[2]",
          "text": "Fail when distributed amount exceeds initial supply."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is parameter closure required before execution?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Single-source configuration prevents mismatched launch behavior."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the purpose of hard stop launch criteria?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "To halt execution when invariants or authority assumptions fail"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Hard stop rules prevent progressing through unsafe operational states."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[0]",
          "text": "Keep checkpoint JSON key ordering fixed so output is stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[2]",
          "text": "Include determinism metadata (fixtures hash + encoding version) in the final object."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[0]",
          "text": "Add validation before returning the formatted string."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[1]",
          "text": "instructionCount should be treated as a number but returned as text."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].content",
          "text": "# Write a Counter Program Bankrun Test Implement a helper that returns the expected counter value after a sequence of increment operations. This mirrors a deterministic assertion you would use in a Bankrun test. Return t..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[0]",
          "text": "Use Array.reduce to sum increments."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[2]",
          "text": "Convert final number to string before returning."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the primary source of event data on Solana?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Explicit event topics like EVM"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is idempotency important in indexing?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "To prevent duplicate events during replays or forks"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "To improve RPC response times"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "As little-endian u64, then divided by 10^decimals"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[1].note",
          "text": "Inner CPI call at depth 2"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Success bubbles up from inner to outer"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[0]",
          "text": "Parse log entries to identify event types"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[1]",
          "text": "Extract fields using regex patterns"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It provides stable ordering during concurrent writes"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Cursor-based pagination handles concurrent writes without missing or duplicating entries."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What enables indexer recovery after crashes?"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Periodic checkpointing of last processed position"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Re-indexing from genesis on every start"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Caching all data in memory"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Checkpoints allow indexers to resume from the last known good position."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].hints[3]",
          "text": "Include metadata like timestamps"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the purpose of SPL Memo in payments?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What should never be included in a memo?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Memos are public on-chain; sensitive data should be hashed or kept off-chain."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[0]",
          "text": "Use base58 alphabet to validate the recipient address format."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[2]",
          "text": "Generate an idempotency key if not provided in the input."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].hints[2]",
          "text": "Key order matters: SOL transfer needs [from, to], SPL transfer needs [source, mint, dest, owner]."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Different key orders produce different signatures"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Canonicalization ensures consistent serialization so signatures match regardless of object construction order."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Initial state after intent creation"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Payment complete, generate receipt"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[0]",
          "text": "HMAC-SHA256: H(key, message) = SHA256((key XOR outer_pad) || SHA256((key XOR inner_pad) || message))"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[1]",
          "text": "Use constant-time comparison to prevent timing attacks on signature verification."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[2]",
          "text": "Verify the timestamp is recent (within 5 minutes) to prevent replay attacks."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a Merkle root commit to?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The tree depth only"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[0]",
          "text": "Start by validating the leaf index is within bounds."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[1]",
          "text": "At each level, find the sibling node (left or right of current)."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[3]",
          "text": "Traverse up to the root, collecting all updated node hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[4]",
          "text": "Use deterministic ordering: left hash comes before right hash."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].prompt",
          "text": "What determines concatenation order during verification?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[0]",
          "text": "The leaf index bits at each level"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[1]",
          "text": "The size of the sibling hashes"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[2]",
          "text": "The tree root hash"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].explanation",
          "text": "Each bit of the leaf index determines if the current hash goes left or right in the concatenation."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[1].explanation",
          "text": "log2(1024) = 10, so proofs contain 10 sibling hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[0]",
          "text": "To generate a proof, collect the sibling hash at each level from leaf to root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[1]",
          "text": "The sibling is at index+1 if current is left, index-1 if current is right."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[3]",
          "text": "Use the same ordering (left || right) when combining hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[4]",
          "text": "The proof is valid if the recomputed root matches the stored root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do old proofs fail after tree updates?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "The root changes when leaves are added/modified"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "The proof format changes"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "The leaf hashes are encrypted"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Adding leaves changes parent hashes up to the root, invalidating previous proofs."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "How can metadata attacks be prevented?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Hash verification against leaf commitments"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Using shorter metadata URIs"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Verifying metadata hashes ensures the off-chain data matches the on-chain commitment."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[0]",
          "text": "Validate the mint request has all required fields (leafIndex, nftId, owner)."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[2]",
          "text": "Insert the leaf by computing hashes up to the root, collecting sibling hashes as proof."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What determines voting power in most DAOs?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Token balance at snapshot block"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Voting power is typically proportional to token holdings at a specific snapshot time."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Anyone can trigger execution"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].content",
          "text": "# Challenge: Implement quorum/voting state machine Build a deterministic voting system: - Calculate vote weights from token balances - Check quorum requirements - Determine pass/fail based on thresholds - Handle abstenti..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[1]",
          "text": "Check if totalVoteWeight >= quorumThreshold to determine quorumMet."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[2]",
          "text": "Calculate support percentage as forWeight / (forWeight + againstWeight) when there are non-abstain votes."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does 2-of-3 multisig mean?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].options[0]",
          "text": "2 signatures required from 3 possible signers"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why track approvals on-chain?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[1]",
          "text": "Process actions in order - each action updates the signer's status."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[2]",
          "text": "Track the cumulative approved weight to compare against threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[3]",
          "text": "A proposal is 'approved' when approvedWeight >= threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[4]",
          "text": "A proposal is 'rejected' when no pending signers remain but threshold is not met."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "What is a replay attack in multisig systems?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Sending duplicate approval requests"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].hints[0]",
          "text": "First validate the proposal status is 'approved'."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The network automatically extends the limit"
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].hints[2]",
          "text": "Each byte of data adds 10 compute units."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Lower fees, higher throughput"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[0]",
          "text": "Sort fields by size (largest first) to minimize padding gaps."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[1]",
          "text": "Consider if u64 fields can be reduced to u32 based on maxValue."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[2]",
          "text": "Boolean flags can be packed into a single byte as bit flags."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[3]",
          "text": "Calculate bytes saved as originalSize - optimizedSize."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of setComputeUnitPrice?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Enable additional program features"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why request specific compute unit limits?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "Optimizing without profiling or evidence of need"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Premature optimization wastes effort on theoretical rather than measured bottlenecks."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[0]",
          "text": "Compute savings by subtracting 'after' from 'before' metrics."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[1]",
          "text": "Use approximate conversion: 1 SOL = $20, 1 SOL = 1,000,000,000 lamports."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why must native SOL be wrapped before swapping?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Native SOL cannot be transferred on Solana"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Solana automatically creates the ATA"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The tokens are sent to the system program"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is 50 basis points of slippage on a 1,000,000 output?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why should minOutAmount use BigInt instead of floating point?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Floating point introduces rounding errors in token amounts"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "BigInt is faster than floating point"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Single-hop direct route"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Total execution cost includes fees + impact"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[0]",
          "text": "Use BigInt arithmetic to avoid floating point errors when computing minOutAmount."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[1]",
          "text": "Slippage in basis points: minOut = outAmount - (outAmount * slippageBps / 10000)."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[3]",
          "text": "The priceImpactPct comes directly from the quote response."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].hints[0]",
          "text": "Define a TRANSITIONS map: each key is a state, each value maps event names to next states."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "They reduce the number of required signatures"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Retryable — get fresh blockhash"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[0]",
          "text": "Use BigInt to sum fee amounts across all route legs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[1]",
          "text": "Effective price = outAmount / inAmount, formatted to 9 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the main advantage of CLMMs over constant product AMMs?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Capital efficiency — LPs concentrate liquidity where trades happen"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "CLMMs allow LPs to allocate capital to specific price ranges, dramatically improving capital efficiency compared to spreading liquidity across all prices."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs use ticks to discretize the price space?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "To reduce the number of tokens in the pool"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs store sqrtPrice instead of price directly?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "It simplifies the AMM math — token amounts become linear in sqrtPrice"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "It uses less storage space on-chain"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Price within range, position is active"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "All SOL was sold as price rose through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Position reactivates when price returns to range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "All USDC was sold as price fell through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[0]",
          "text": "Price at a tick index = 1.0001^tickIndex. Use Math.pow(1.0001, tick)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[1]",
          "text": "Reverse conversion: tick = round(ln(price) / ln(1.0001))."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[2]",
          "text": "sqrtPriceX64 = BigInt(round(sqrt(price) * 2^64)) — Solana CLMM uses Q64.64 fixed-point."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[3]",
          "text": "Tick spacing alignment: floor(tick / spacing) * spacing."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[0]",
          "text": "Convert ticks to prices: lowerPrice = 1.0001^lowerTick, upperPrice = 1.0001^upperTick."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[2]",
          "text": "Fees only accrue when the position is in range. fee = floor(volumePerPeriod * feeRate)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[3]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[4]",
          "text": "Current status is based on the last price in the path relative to the range."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the main tradeoff of using a tight price range?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Lower fees but less impermanent loss"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "More tokens required to open the position"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When should an LP consider a full-range (all ticks) position?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "JavaScript Number cannot safely represent 128-bit integers"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "sqrtPriceX64 is a u128 value that can exceed JavaScript's Number.MAX_SAFE_INTEGER (2^53 - 1). BigInt provides arbitrary precision integer arithmetic."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "They are rejected by the program"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Floor division rounds toward negative infinity: floor(-100/64) = -2, so -100 aligns to -2 * 64 = -128. This is correct CLMM behavior."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[1]",
          "text": "Status is 'in-range' if lowerPrice <= currentPrice <= upperPrice."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[3]",
          "text": "IL formula: lpValue = sqrt(priceRatio) + sqrt(1/priceRatio); compare to holdValue = 2*sqrt(priceRatio)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[4]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimals."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a utilization ratio of 80% mean?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "80% of supplied assets are currently borrowed"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "80% of borrowers have been liquidated"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The pool has 80% of its maximum capacity"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Utilization = totalBorrowed / totalSupply. At 80%, four-fifths of all deposited assets are currently lent out to borrowers."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does the reserve factor affect supplier yield?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "It reduces supplier yield by skimming a percentage of borrow interest"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It increases supplier yield by adding protocol subsidies"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "It has no effect on supplier yield"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "The reserve factor takes a cut of borrow interest before distributing the rest to suppliers, reducing their effective APY."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What happens to borrow rates when utilization exceeds the kink?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "They increase steeply according to slope2"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "They remain constant at the kink rate"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "They decrease to attract more borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is the supply rate always lower than the borrow rate?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The protocol subsidizes borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Only 20% buffer remaining — consider adding collateral"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[0]",
          "text": "Utilization = totalBorrowed / totalSupply. Handle the zero-supply edge case."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[1]",
          "text": "Below kink: borrowRate = baseRate + (utilization/kink) * slope1."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[2]",
          "text": "Above kink: borrowRate = baseRate + slope1 + ((util - kink)/(1 - kink)) * slope2."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[3]",
          "text": "Supply rate = borrowRate * utilization * (1 - reserveFactor)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[1]",
          "text": "Effective threshold = weighted average of liquidationThreshold by collateral value."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[2]",
          "text": "Health factor = (collateralValue * effectiveThreshold) / borrowValue."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[3]",
          "text": "Max additional borrow = max(0, collateralValue * threshold - currentBorrow)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of the liquidation bonus?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It incentivizes liquidators to repay debt by offering collateral at a discount"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When does bad debt occur in a lending protocol?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "When collateral value is insufficient to cover outstanding debt after liquidation"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "When the reserve factor is set too high"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "When utilization drops below the kink"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "To be conservative — using (price - confidence) prevents over-valuing collateral during uncertainty"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Confidence intervals make prices more accurate"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should a protocol do when all oracle feeds are stale?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "Use the last known price regardless of age"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Estimate the price from on-chain DEX data"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[2]",
          "text": "Track the worst health factor across all scenarios."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[3]",
          "text": "Count how many scenarios result in isLiquidatable: true."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do perpetual futures protocols use a mark price instead of the last-traded price?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Mark price smooths out manipulation by incorporating oracle data, preventing artificial liquidations"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Mark price is cheaper to compute on-chain"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Last-traded price is not available on Solana"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Mark price incorporates the oracle price as a stability anchor. Using last-traded price alone would allow a single large trade to trigger cascading liquidations through price manipulation."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Weighted average: (8 * 20 + 2 * 30) / 10 = (160 + 60) / 10 = $22.00. The entry price shifts toward the new fill price proportional to the additional size."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "When the perpetual mark price is above the oracle (spot) price, who pays funding?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Longs pay shorts — the positive premium makes long positions expensive to hold"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Both sides pay the protocol a fee"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "A 10 SOL-PERP position at $25 entry faces a 0.01% funding rate. What is the per-period payment?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "text": "Funding payment = size * entryPrice * rate = 10 * 25 * 0.0001 = $0.025 per funding interval."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Position snapshot at current mark price"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Long PnL = size * (mark - entry)"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Positive rate: longs pay funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "True return includes funding drag"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[0]",
          "text": "Long PnL = size * (markPrice - entryPrice). Short PnL = size * (entryPrice - markPrice)."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[1]",
          "text": "Notional value = size * markPrice — represents the total position value."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[2]",
          "text": "ROE (return on equity) = unrealizedPnL / margin * 100."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[0]",
          "text": "Funding payment per period = size * entryPrice * fundingRate."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[1]",
          "text": "Longs pay when rate is positive (totalFunding -= payment). Shorts receive."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[2]",
          "text": "Average funding rate = sum(rates) / count."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[3]",
          "text": "Net margin impact = (totalFunding / margin) * 100, as a percentage."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is the maintenance margin rate set above zero?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "What causes a cascading liquidation spiral?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Forced position closes push the price further, triggering more liquidations in a feedback loop"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Too many traders opening positions at the same time"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Oracle prices updating too slowly"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "text": "When liquidation engines close positions by selling into the market, the selling pressure moves the price further against remaining positions, triggering their liquidations too — a self-reinforcing feedback loop."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should position size always be stored as a positive number?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Positive numbers use less storage space"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "A long position has a positive funding rate of 0.01%. What happens to the trader's balance?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The balance decreases — longs pay when the funding rate is positive"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The balance increases — longs receive positive funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Nothing — funding only affects shorts"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Positive funding rate means the perp is trading above spot. Longs pay shorts to discourage the long-heavy imbalance. The long trader's effective margin decreases by the funding payment amount."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[0]",
          "text": "Effective margin = initial margin + unrealized PnL + funding payments."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[1]",
          "text": "Margin ratio = effectiveMargin / notionalValue."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[3]",
          "text": "Generate alerts based on margin ratio vs maintenance margin rate thresholds."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[4]",
          "text": "Sort alerts by severity: CRITICAL > WARNING > INFO."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How is the priority fee calculated in lamports?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "The CU price is denominated in micro-lamports per CU. Dividing by 1,000,000 converts micro-lamports to lamports. The ceiling function ensures rounding up to the nearest lamport."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is setting the CU limit to exactly the simulated value risky?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The runtime does not accept exact values"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Simulation always underreports CU usage by 50%"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Low compute = minimal priority fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Higher compute increases priority cost proportionally"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "High CU + high priority = significant fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[1]",
          "text": "Cap compute unit limit at 1,400,000 (Solana max)."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[2]",
          "text": "Priority fee = ceil(computeUnitLimit * computeUnitPrice / 1_000_000) in lamports."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[3]",
          "text": "Total fee = base fee (5000 lamports) + priority fee."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].hints[3]",
          "text": "Recommend 'legacy' if fits without LUT, 'use-existing-lut' if LUT helps enough, 'create-new-lut' if still too large."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "When the blockhash has expired or pool state has changed"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Whenever any error occurs"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Only when the user manually clicks retry"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add random jitter to retry delays?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To make the delay shorter on average"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Jitter is required by the Solana protocol"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Without jitter, all clients using the same backoff formula would retry simultaneously, creating thundering herd problems on the RPC infrastructure."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Slippage exceeded -> actionable message"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Balance error -> show exact shortfall"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[1]",
          "text": "Fee estimates: low = 100 microlamports/CU, medium = 1000, high = 10000."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[2]",
          "text": "Retry policy: 3 retries, 500ms base delay, 2x backoff, always refresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[3]",
          "text": "Use the same CU calculation: ceil(totalCU * 1.1) capped at 1,400,000."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Foreground services maintaining a session channel"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Deep links passed between applications"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Shared local storage between apps"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "iOS suspends app execution on background transitions, preventing persistent channels"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "iOS uses a different blockchain protocol"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "iOS does not allow arbitrary background processes or persistent inter-app communication. When the user switches apps, the dApp's execution context is suspended."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Detect available connection methods (MWA, deep links, QR)"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "Capability detection ensures you only present connection methods that are actually available on the user's device."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Request sent via MWA session or deep link"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "User decision - timing is unpredictable"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[3]",
          "text": "Generate a requestId from type + payload prefix if not provided."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[0]",
          "text": "Process actions sequentially: each action modifies the session state."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[3]",
          "text": "Expire check clears session if current time >= expiresAt."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "As raw lamports or smallest unit values"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Raw simulation logs from the RPC response"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].title",
          "text": "Retry State Machine Flow"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "User action triggers request construction"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[0]",
          "text": "Count requests by status: 'signed' = success, 'rejected'/'timeout'/'error' = failure."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[2]",
          "text": "Session duration = sessionEnd - sessionStart in seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "solana:<recipient> (single colon, no slashes)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "solana://<recipient> (double slashes like HTTP)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "pay:<recipient> (custom pay scheme)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "When the amount exceeds 100 SOL"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How does the reference parameter enable payment tracking?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "It creates a webhook that notifies the merchant"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What amount value represents 2.5 USDC in a Solana Pay URL?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "amount=2.5 (human-readable decimal)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Native SOL transfer — no spl-token parameter"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[0]",
          "text": "Solana Pay URL format: solana:<recipient>?amount=<amount>&spl-token=<mint>&reference=<ref>&label=<label>&message=<msg>"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[1]",
          "text": "Validate recipient: must be 32-44 characters of valid base58."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[2]",
          "text": "Amount must be a positive finite number."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[0]",
          "text": "Track state transitions: pending -> found -> confirmed -> finalized."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[1]",
          "text": "The 'found' event sets the signature. 'confirmation' increments the counter."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[2]",
          "text": "Timeout check expires the reference if still pending after expiryTimeout seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[3]",
          "text": "Record each state change in the history array."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Confirmed is never sufficient — always use finalized"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What should happen when the payment request expires?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Silently restart the polling loop"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Redirect the customer to a different payment method"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Exponential backoff recovers from transient failures"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Never auto-complete mismatched payments"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Track processed references to prevent double fulfillment"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[0]",
          "text": "Generate receiptId from the last 8 chars of reference + timestamp."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[1]",
          "text": "Reconstruct the Solana Pay URL from payment data."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[2]",
          "text": "Currency is 'SPL' if splToken is present, otherwise 'SOL'."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What should happen when auto-connect fails silently on page load?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Show the connect button without an error message"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Display an error toast telling the user to reconnect"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Auto-connect is a background optimization. If it fails, the user never initiated the action, so showing an error would be confusing. Simply display the default connect button."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why should you show skeleton UI during the connecting phase?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It makes the page load faster"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How do you reliably detect which Solana cluster an RPC endpoint is connected to?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What must happen to cached data when the network changes?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Only token balances need to be refreshed"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Cached data can be retained since addresses are the same across clusters"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "User clicks Connect, show loading state"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[0]",
          "text": "Define a TRANSITIONS map: each state maps event types to next states."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[2]",
          "text": "Error state stores the error message. Disconnected clears all session data."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[2]",
          "text": "DISCONNECT invalidates all non-'global' entries."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[3]",
          "text": "Track invalidation counts per event in the event log."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must cache keys include the network cluster?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "The Solana RPC protocol requires cluster identification"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What does the stale-while-revalidate pattern do when a cache entry is past its TTL?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Blocks until fresh data is fetched from the RPC"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Primary endpoint responding normally"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Latency spike detected, slot behind tip"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Automatic failover to healthy secondary"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Primary recovered, restoring as default"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[1]",
          "text": "Average connect time = total durationMs from CONNECTED events / count."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[2]",
          "text": "Cache hit rate = hits / (hits + misses) * 100."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[3]",
          "text": "RPC health = healthy checks / total checks * 100."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "signMessage does not produce valid Ed25519 signatures"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does SIWS prevent replay attacks?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "By requiring a unique, server-generated nonce that is consumed after verification"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must nonces be generated server-side rather than client-side?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Client-generated nonces allow attackers to reuse previously valid nonce-signature pairs"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Client-side random number generators are too slow"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What format must the domain field use?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Plain domain name without protocol prefix (e.g., example.com)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[0]",
          "text": "Domain should not include protocol (https://). Strip or reject it."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[2]",
          "text": "Address must be 32-44 characters (Solana base58 public key)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[3]",
          "text": "If no statement is provided, default to 'Sign in to <domain>'."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[1]",
          "text": "issuedAt must be <= currentTime (not in the future)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[2]",
          "text": "expirationTime (if present) must be > currentTime."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The dApp should invalidate the server-side session (treat it as logout)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Atomic SET NX ensures only one request can consume the nonce"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Replay blocked: nonce was already consumed"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[0]",
          "text": "Track used nonces in a map. If a nonce was already used, it's a replay attempt."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[2]",
          "text": "Use an address set to count unique addresses."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does a wide p90 vs p50 spread usually indicate?"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A volatile fee regime where a guard premium may be needed"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "Floor protects small estimates."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Large payload triggers heap recommendation."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[0].content",
          "text": "Implement a deterministic compute budget planner. No RPC calls; operate only on provided input data."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[0]",
          "text": "Use percentile targeting from sorted synthetic fee samples."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[1]",
          "text": "Apply volatility guard if p90 vs p50 spread exceeds policy threshold."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[2].hints[0]",
          "text": "Map risk score bands to processed/confirmed/finalized UX levels."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].hints[1]",
          "text": "Avoid timestamps or random IDs in output."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[4].hints[1]",
          "text": "Checkpoint report should avoid nondeterministic fields."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do users still expect atomic behavior in multi-tx flows?"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because protocols always guarantee it"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].title",
          "text": "Flow Graph Risk Walkthrough"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "No compensation path after swap failure."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Still verify idempotency on each step."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[0].hints[1]",
          "text": "Emit explicit edges from dependency relationships."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[1].hints[1]",
          "text": "Flag non-idempotent steps because retries can break all-or-nothing guarantees."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].content",
          "text": "Encode deterministic failure handling metadata, including compensation state."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].hints[0]",
          "text": "Generate deterministic idempotency keys from stable inputs."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[3].hints[0]",
          "text": "No real Jito calls. Build deterministic data structures only."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].content",
          "text": "Generate a stable markdown flow safety report checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[0]",
          "text": "Render a stable markdown report as the final checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[1]",
          "text": "Keep the PASS/FAIL status deterministic from issue count."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Slippage is user tolerance; impact is market footprint"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They are identical metrics"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Slippage is a user-configured bound, while impact reflects route liquidity response to trade size."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[1].hints[0]",
          "text": "Clamp recommended BPS to policy bounds."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[2].hints[0]",
          "text": "Teach difference: impact is market footprint, slippage is user tolerance."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[3].hints[0]",
          "text": "Map risk grades to deterministic banner copy."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[4].hints[1]",
          "text": "Do not include timestamps or random IDs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "It reduces RPC cost directly"
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[0].hints[1]",
          "text": "Sort by key so output is deterministic across runs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[1].hints[0]",
          "text": "Apply only confirmed-depth events to state."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[0]",
          "text": "Integrity checks must fail on negative balances."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[1]",
          "text": "Finalized keys must always be a subset of applied keys."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].title",
          "text": "RPC failures in real life: timeouts, 429s, stale nodes"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is slot lag important in endpoint scoring?"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Fast responses can still be wrong if the node is stale"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Slot lag is equivalent to timeout"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Latency alone cannot guarantee freshness of chain state."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Fast but less reliable under pressure."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].title",
          "text": "Explorer: retry/backoff simulator"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].title",
          "text": "RPC Multi-Provider Client Project Journey"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[0].hints[0]",
          "text": "Build a deterministic retry schedule including the first attempt."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[1].hints[1]",
          "text": "Tie-break deterministically by endpoint ID."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[2].hints[1]",
          "text": "Use tighter TTL when node lag grows."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].title",
          "text": "Checkpoint: RPC health report export"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].hints[1]",
          "text": "Ensure field order is stable in JSON output."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Alignment inserts padding bytes"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "RPC forces 8-byte packets"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "u64 alignment usually forces padding after smaller fields."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "u32 length + UTF-8 bytes + u8 field"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[0].hints[1]",
          "text": "Struct total size should be aligned to max field alignment."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].title",
          "text": "Challenge: implement borshEncode/borshDecode helpers"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].hints[0]",
          "text": "Borsh strings are length-prefixed little-endian u32 + UTF-8 bytes."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].title",
          "text": "Challenge: zero-copy vs Borsh tradeoff model"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[0]",
          "text": "Model tradeoffs deterministically: read speed vs schema flexibility."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[1]",
          "text": "Recommendation should be pure function of inputs."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[3].hints[0]",
          "text": "Validate byte length before field parsing."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].title",
          "text": "Checkpoint: stable layout report"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should export stable JSON + markdown."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].title",
          "text": "Error taxonomy: recoverable vs fatal"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why are typed error codes preferred over free-form strings?"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable machine-readable semantics"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "They reduce compile time"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].title",
          "text": "Explorer: invariant decision tree"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].title",
          "text": "Invariant Guard Library Project Journey"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].title",
          "text": "Challenge: implement InvariantError + ensure helpers"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].hints[0]",
          "text": "Return typed error payloads, not raw strings."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[1].title",
          "text": "Challenge: implement deterministic EvidenceChain"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].title",
          "text": "Challenge: deterministic invariant case runner"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].hints[0]",
          "text": "Property-ish deterministic tests can still run as fixed case sets."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].title",
          "text": "Challenge: implement formatReport() stable markdown"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].content",
          "text": "Format a deterministic markdown evidence report."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].title",
          "text": "Checkpoint: invariant audit report"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].content",
          "text": "Export deterministic invariant audit checkpoint artifacts."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should capture deterministic summary fields only."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[1]",
          "text": "No wall-clock timestamps in exported artifact."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why use deterministic cost models before microbenchmarks?"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable regression signals in CI"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They replace all profiling"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Deterministic models make relative regressions easy to catch early."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].title",
          "text": "Data structures: Vec, HashMap, BTreeMap tradeoffs"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].title",
          "text": "Explorer: cost model sandbox"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].title",
          "text": "Compute Budget Profiler (Sim)"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].title",
          "text": "Challenge: implement CostModel::estimate()"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].content",
          "text": "Estimate deterministic operation costs from fixed weighting rules."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].title",
          "text": "Challenge: optimize function metrics"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[0]",
          "text": "Treat optimization as deterministic metric diffs, not runtime benchmarking."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[1]",
          "text": "Clamp reduced metrics at zero."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].title",
          "text": "Challenge: model serialization overhead"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[0]",
          "text": "Show why repeated encode/decode loops are expensive."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[1]",
          "text": "Keep the model deterministic by counting bytes instead of timing."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].content",
          "text": "Generate stable optimization suggestions from deterministic metrics."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[0]",
          "text": "Output suggestions as a stable, sorted list."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[1]",
          "text": "Use threshold-based recommendations to avoid noisy advice."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].title",
          "text": "Checkpoint: stable perf report"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].hints[1]",
          "text": "Use deterministic percentage rounding."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].title",
          "text": "Async fundamentals: futures, tasks, channels"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].title",
          "text": "Reorg-safe Async Pipeline Project Journey"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].title",
          "text": "Challenge: implement Pipeline::run()"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].hints[1]",
          "text": "No real timers; simulate progression by decrementing remaining ticks."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[1].title",
          "text": "Challenge: implement RetryPolicy schedule"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].title",
          "text": "Challenge: idempotency key dedupe"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].content",
          "text": "Deduplicate replay events by deterministic idempotency keys."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].hints[0]",
          "text": "Use idempotency keys to collapse duplicate replay events."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[3].content",
          "text": "Build deterministic snapshot state from simulated event streams."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].title",
          "text": "Checkpoint: pipeline run report"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint output should mirror deterministic pipeline run artifacts."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "It verifies expansion matches policy intent"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].title",
          "text": "Safety through codegen: constraint checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].title",
          "text": "Explorer: constraint builder to generated checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].content",
          "text": "Parse mini-DSL constraints into deterministic AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].hints[0]",
          "text": "Parse mini DSL lines into typed AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].content",
          "text": "Generate stable pseudo-code from parsed constraint AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[0]",
          "text": "Generate stable pseudo-code output from AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[1]",
          "text": "One deterministic line per constraint node."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].title",
          "text": "Challenge: deterministic golden-file checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].content",
          "text": "Compare generated check output against deterministic golden strings."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[0]",
          "text": "Golden tests compare generated output strings exactly."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[1]",
          "text": "Keep check output deterministic to make golden tests meaningful."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].content",
          "text": "Execute generated constraints on deterministic sample input."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].hints[1]",
          "text": "Return deterministic failure reasons."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].title",
          "text": "Checkpoint: generated safety report"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].content",
          "text": "Export deterministic markdown safety report from generated checks."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].hints[0]",
          "text": "Render a deterministic markdown report from generated check results."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].title",
          "text": "Upgrade authority lifecycle in Anchor programs"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Compare approved build hash to expected programdata hash policy input"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Rely on signer memory without written report"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is release communication part of upgrade safety?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Because Anchor automatically writes support tickets"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because all upgrades are backward compatible"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].title",
          "text": "Explorer: upgrade risk matrix"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].title",
          "text": "Challenge: implement migration step planner"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].hints[1]",
          "text": "requiresMigration should be true only when toVersion > fromVersion."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].title",
          "text": "Challenge: implement upgrade safety gate checks"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[1]",
          "text": "Return issueCount plus ordered issue code array."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[2]",
          "text": "Keep order stable to make report diffs deterministic."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What should happen first when rollback trigger thresholds are hit?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Continue migration batches to avoid confusion"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Delete all historical reports"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Trigger conditions should map to immediate deterministic response actions."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add deterministic fixtures after an incident?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "To prove policy changes prevent the same failure path"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To increase deploy complexity without benefit"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "To replace all code reviews"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].title",
          "text": "Challenge: build stable upgrade markdown summary"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].hints[2]",
          "text": "Return plain markdown string without trailing spaces."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].title",
          "text": "Checkpoint: upgrade readiness artifact"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[0]",
          "text": "ready is true only when issueCount equals 0."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[1]",
          "text": "Return stable keys in releaseTag, ready, migrationBatches order."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[2]",
          "text": "Checkpoint output should be machine-readable deterministic JSON."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[0]",
          "text": "Use match on the BackoffStrategy enum to handle each case"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[2]",
          "text": "should_retry simply checks if attempt is less than max_attempts"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].content",
          "text": "Implement a deadline management system to enforce time limits on operations."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].hints[0]",
          "text": "Store the absolute expiration timestamp in the Deadline struct"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].content",
          "text": "Implement a fallback mechanism that provides alternative execution paths when primary operations fail."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].hints[1]",
          "text": "Only call fallback if primary returns None"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].hints[1]",
          "text": "record_success should reset everything to Closed state"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[0]",
          "text": "Always refill before checking if consumption is possible"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[2]",
          "text": "Use min() to ensure tokens don't exceed capacity"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].content",
          "text": "Implement an error classification system to determine if errors are retryable."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[1]",
          "text": "should_retry can use matches! macro or match on classify result"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[2]",
          "text": "batch_classify can use iter().map().collect() pattern"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].title",
          "text": "Test Assertion Framework Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].hints[1]",
          "text": "Use format! to create descriptive error messages"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[2].hints[0]",
          "text": "Use vec![0; size] to create zero-filled data of specified size"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].title",
          "text": "Test Scenario Builder Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].hints[1]",
          "text": "Push strings into vectors (use to_string() to convert &str)"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].title",
          "text": "Fuzz Input Generator Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].hints[1]",
          "text": "Generate bytes by taking random % 256"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[2].content",
          "text": "Implement a property verifier that checks invariants hold across operations."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].title",
          "text": "Boundary Value Analyzer Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[1]",
          "text": "Typical value is the midpoint of the range"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[2]",
          "text": "Return all 7 boundary values as test cases"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].content",
          "text": "Implement a compute unit counter to estimate operation costs."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[0]",
          "text": "Loop cost is overhead plus iterations times per-iteration cost"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[2]",
          "text": "Apply safety margin by multiplying budget by the percentage"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].title",
          "text": "Data Structure Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[0]",
          "text": "Use copy_from_slice to write data efficiently"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[1]",
          "text": "Track the highest written position as 'used'"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[2]",
          "text": "Always check bounds before read/write operations"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].title",
          "text": "Batch Operation Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].content",
          "text": "Optimize batch operations to minimize compute units."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[0]",
          "text": "Use to_le_bytes() to convert integers to bytes"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[1]",
          "text": "Use from_le_bytes() to convert bytes back to integers"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[2]",
          "text": "Alignment formula: if remainder, add (alignment - remainder)"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[0]",
          "text": "Annual rent is data size times lamports per byte per year"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[1]",
          "text": "Exemption threshold is annual rent times threshold years"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[2]",
          "text": "Check if balance is greater than or equal to minimum"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].title",
          "text": "Zero-Copy Deserializer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[0]",
          "text": "Use copy_from_slice to read fixed-size data into stack arrays"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[2]",
          "text": "Always advance offset after reading"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].title",
          "text": "Vesting Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[0]",
          "text": "Use saturating_sub to avoid underflow when calculating elapsed time"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[2]",
          "text": "Releasable is simply vested minus already released"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].title",
          "text": "Token Allocation Distributor Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[0]",
          "text": "Use iter().map().sum() to calculate total percentage"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[2]",
          "text": "Use find() to locate allocation by recipient"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].title",
          "text": "Release Schedule Generator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].hints[0]",
          "text": "Divide duration by intervals to get interval duration"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[0]",
          "text": "Use compound interest formula: A = P(1 + r/n)^(nt)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[1]",
          "text": "Convert basis points to decimal by dividing by 10000"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[0]",
          "text": "If delegated_to is Some, voting power is 0 (they gave it away)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[1]",
          "text": "Use filter to find voters who delegated to a specific address"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[2]",
          "text": "Sum staked amounts to calculate delegated power"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].title",
          "text": "Proposal Threshold Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].hints[0]",
          "text": "Convert basis points to amount: (supply * bps) / 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[1].title",
          "text": "Constant Product AMM Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].title",
          "text": "Liquidity Provider Calculator Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].hints[2]",
          "text": "Rewards are proportional to LP token holdings"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].content",
          "text": "Implement a time-weighted average price oracle."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[0]",
          "text": "Use retain() to filter out old observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[1]",
          "text": "Calculate duration between consecutive observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[2]",
          "text": "TWAP is weighted sum divided by total duration"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[0]",
          "text": "Max borrow is collateral value times LTV ratio"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[1]",
          "text": "Position is liquidatable when borrowed exceeds threshold * value"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[2]",
          "text": "Health factor shows how close to liquidation (higher is safer)"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].title",
          "text": "Interest Rate Model Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].content",
          "text": "Implement a utilization-based interest rate model."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].hints[0]",
          "text": "Utilization is borrowed divided by supplied"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].content",
          "text": "Implement flash loan validation logic."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[0]",
          "text": "Fee is amount times fee_bps divided by 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[1]",
          "text": "Total repay is principal plus fee"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[1].title",
          "text": "NFT Metadata Parser Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[2].hints[2]",
          "text": "Only verify if collection is complete"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].title",
          "text": "Attribute Rarity Calculator Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].content",
          "text": "Calculate NFT attribute rarity scores."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[0]",
          "text": "Rarity percentage is (count / total) * 100"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[1]",
          "text": "Rarity score is inverse of rarity (1 / rarity)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[1].hints[2]",
          "text": "Use any() to check if address is in restrictions list"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].title",
          "text": "Dynamic NFT Updater Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].content",
          "text": "Implement dynamic NFT attributes that can evolve over time."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[1]",
          "text": "Update last_updated timestamp after successful update"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[2]",
          "text": "Time until update is max(0, next_update - current_time)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[3].hints[2]",
          "text": "Filter equipped items by matching type in items list"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[1].hints[2]",
          "text": "Privilege extension: if caller is signer, child can sign too"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[0]",
          "text": "Convert string seeds to bytes using as_bytes()"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[1]",
          "text": "Simulate PDA finding by trying different bump values"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[0]",
          "text": "Use HashMap insert to register handlers"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[1]",
          "text": "Route by looking up instruction_type in handlers map"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].title",
          "text": "Atomic Swap Orchestrator Challenge"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].content",
          "text": "Implement an atomic swap across multiple programs."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].hints[1]",
          "text": "Atomicity requires output_token of step N equals input_token of step N+1"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[2].content",
          "text": "Validate state consistency across multiple CPI calls."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[0]",
          "text": "Push permission into vector to register"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[2]",
          "text": "Use retain() to remove caller from allowed list"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].title",
          "text": "Arbitrage Opportunity Detector Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].content",
          "text": "Detect arbitrage opportunities across DEXes."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[1]",
          "text": "Profit percent is (sell - buy) / buy * 100"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[2]",
          "text": "Use max_by to find best opportunity"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].title",
          "text": "Liquidation Opportunity Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[0]",
          "text": "Position is liquidatable when borrowed > threshold * collateral_value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[2]",
          "text": "Liquidation profit is bonus percentage of collateral value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].title",
          "text": "Priority Fee Calculator Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[0]",
          "text": "Urgency factor scales the base fee"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[1]",
          "text": "Execution probability decreases as more fees are higher"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[0]",
          "text": "Tip is percentage of total profit"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[1]",
          "text": "Bundle is profitable if profit exceeds tip"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].title",
          "text": "Multi-Hop Arbitrage Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].content",
          "text": "Find multi-hop arbitrage paths across token pairs."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[1]",
          "text": "Two-hop arbitrage goes A -> B -> A through different pools"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[2]",
          "text": "Profit is final output minus initial input"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].title",
          "text": "MEV Simulation Engine Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].content",
          "text": "Simulate MEV extraction to estimate profitability."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].hints[2]",
          "text": "Expected value weights profit by success probability"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[0]",
          "text": "Push config into vector to add"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[1]",
          "text": "Use find() to locate config by environment name"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[0]",
          "text": "Compare binary length against MAX_PROGRAM_SIZE"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[2]",
          "text": "Compression ratio shows percentage size reduction"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].title",
          "text": "Upgrade Authority Manager Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[0]",
          "text": "Push metadata into vector to register"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[1]",
          "text": "can_upgrade checks if authority matches stored authority"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[0]",
          "text": "Track seen stages to enforce ordering constraints"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[2]",
          "text": "Can skip build/test if only documentation files changed"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].title",
          "text": "Version Compatibility Checker Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[1]",
          "text": "Compatibility requires same major, actual >= required"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[2]",
          "text": "Use min_by to find smallest compatible version"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].title",
          "text": "Cross-Chain Messaging Architecture"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].content",
          "text": "Implement VAA (Verified Action Approval) signature verification."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[0]",
          "text": "Check signatures length against MIN_SIGNERS first"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[2]",
          "text": "Quorum is 2/3 of total guardians rounded up"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[0]",
          "text": "Increment sequence before creating message"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[2]",
          "text": "Verify message sequence is within emitted range"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[0]",
          "text": "Use contains() to check if sequence was processed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[1]",
          "text": "Return error if trying to mark already-processed sequence"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[2]",
          "text": "Use retain() to filter out old sequences"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[1].hints[1]",
          "text": "Verify requester matches owner before unlocking"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].title",
          "text": "Wrapped Token Mint Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].hints[1]",
          "text": "Check bounds before minting/burning"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].title",
          "text": "Bridge Rate Limiter Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[0]",
          "text": "Reset window before checking if duration passed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[1]",
          "text": "Only consume if total won't exceed max"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[1].hints[1]",
          "text": "Confidence ratio: conf / |price| < threshold"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[0]",
          "text": "Multiplier formula: smoothing / (period + 1)"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[1]",
          "text": "First EMA equals first price"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[2]",
          "text": "Subsequent EMAs use weighted average formula"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].title",
          "text": "Median Price Calculator Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].content",
          "text": "Calculate median price from multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].hints[2]",
          "text": "Use retain() to filter out outliers"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].content",
          "text": "Implement consensus checking across multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[0]",
          "text": "Check minimum sources first"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[2]",
          "text": "Agreement percent is (agreeing / total) * 100"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].title",
          "text": "Fallback Oracle Manager Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[0]",
          "text": "Store sources in priority order"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[1]",
          "text": "current_source index tracks which is active"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[2]",
          "text": "Fallback if index > 0 (not primary)"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].title",
          "text": "Proposal Lifecycle Manager Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].hints[1]",
          "text": "Voting active only during time window in Active state"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[0]",
          "text": "Delegated voters have 0 voting power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[1]",
          "text": "Quadratic voting uses square root of balance"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[2]",
          "text": "Apply cap after calculating base power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].content",
          "text": "Manage vote delegation between DAO members."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].hints[0]",
          "text": "Remove existing delegation before creating new one"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].title",
          "text": "Treasury Spending Limit Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].hints[1]",
          "text": "Reset period if duration has passed"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[2].hints[2]",
          "text": "Remove operation from list to cancel"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].title",
          "text": "Automated Action Trigger Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[1]",
          "text": "Match on condition type to evaluate"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[2]",
          "text": "Only return non-triggered actions that meet conditions"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[1].hints[1]",
          "text": "Turn complete when all players submitted"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].title",
          "text": "Game State Compressor Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[0]",
          "text": "Use bit shifting to pack x in high 4 bits, y in low 4 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[2]",
          "text": "Health stored as percentage (0-100) fits in 7 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].title",
          "text": "Player Progression Tracker Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[0]",
          "text": "XP formula: base * multiplier^(level-1)"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[1]",
          "text": "Keep leveling up while XP exceeds requirement"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[2]",
          "text": "Check contains() before adding achievement"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[1].hints[1]",
          "text": "Verify by recomputing hash from reveal"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[2].hints[2]",
          "text": "4d6 drop lowest: roll 4, sum all, subtract minimum"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[1]",
          "text": "Generate random number in range [0, total)"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[2]",
          "text": "Find item where cumulative weight exceeds roll"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].title",
          "text": "Storage Cost Estimator Challenge"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].content",
          "text": "Estimate Arweave storage costs based on data size."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].hints[0]",
          "text": "Calculate winston cost then convert to USD"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[3].hints[0]",
          "text": "Sort items by priority before bundling"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[0]",
          "text": "Validate tx_id length before adding"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[1]",
          "text": "Resolve in order: exact, index, fallback"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[0]",
          "text": "Push item to vector to add"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[1]",
          "text": "Filter items where any tag matches"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].title",
          "text": "Staking Rewards Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].hints[0]",
          "text": "Apply commission as (1 - commission) multiplier"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[2].hints[0]",
          "text": "Weight factors: commission 40%, uptime 40%, skip rate 20%"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[0]",
          "text": "Target is total divided by count, clamped to min/max"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[2]",
          "text": "Check all allocations within tolerance percentage"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[1].hints[0]",
          "text": "Sum all cost components"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[2].title",
          "text": "Epoch Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[0]",
          "text": "Only inactive stakes can be activated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[1]",
          "text": "Only active stakes can be deactivated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[2]",
          "text": "Fully active after warmup_epochs from activation"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[1].hints[0]",
          "text": "Use contains() to check ownership"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[2].hints[1]",
          "text": "Check guardian status before approving"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].title",
          "text": "Session Key Manager Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[0]",
          "text": "Valid if current time before expiration"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[2]",
          "text": "Remaining is max minus used"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].title",
          "text": "Spending Limit Enforcer Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[0]",
          "text": "Reset counters before checking"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[1]",
          "text": "Check all three limits: per-tx, daily, weekly"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[2]",
          "text": "Reset daily if new day, weekly if 7+ days passed"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[2].hints[1]",
          "text": "Check contains() before adding"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[3].title",
          "text": "Time Lock Enforcer Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[0]",
          "text": "Try bumps from 255 down to 0"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[2]",
          "text": "Check if derived address matches expected"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[2].hints[2]",
          "text": "Collect into Vec<Vec<u8>>"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[3].hints[1]",
          "text": "Signer seeds include all seeds plus bump"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].title",
          "text": "Nested PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].content",
          "text": "Generate PDAs derived from other PDA addresses."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].hints[0]",
          "text": "Include parent address in child seeds"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].title",
          "text": "Counter PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].content",
          "text": "Generate unique PDAs using incrementing counters."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[0]",
          "text": "Increment counter after each generation"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[2]",
          "text": "Batch generation calls generate_next multiple times"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].title",
          "text": "PDA Collision Detector Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[0]",
          "text": "Check if seeds match any existing entry"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[1]",
          "text": "Return error if collision detected"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[1]",
          "text": "Compound inflation year over year"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[2]",
          "text": "APY is inflation divided by staked percentage"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].title",
          "text": "Fee Burn Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].hints[1]",
          "text": "Burn is percentage of total fee"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].title",
          "text": "Rent Economics Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[0]",
          "text": "Annual rent is bytes times rate"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[1]",
          "text": "Exemption is annual times threshold years"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[2]",
          "text": "Rent due is annual times period"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].title",
          "text": "Supply Flow Tracker Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[0]",
          "text": "Total excludes burned tokens"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[1]",
          "text": "Apply flow by subtracting from source, adding to destination"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[2]",
          "text": "Net flow is inflow minus outflow"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].title",
          "text": "Vesting Schedule Impact Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].content",
          "text": "Calculate token unlock impact on supply."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[0]",
          "text": "0 before cliff, linear after, full at end"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[1]",
          "text": "Monthly unlock is difference between consecutive months"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[2]",
          "text": "Check multiple months to find peak"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].title",
          "text": "Protocol Sustainability Score Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[0]",
          "text": "Net issuance is inflation minus burn"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[1]",
          "text": "Burn ratio is burn divided by inflation"
        }
      ],
      "englishLikeMatches": [
        {
          "path": "courses.solana-fundamentals.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Core execution model, 账户 semantics, 和 交易 construction patterns you need before writing programs or complex clients."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].content",
          "englishWordCount": 238,
          "excerpt": "# Solana 思维模型 Solana development gets much easier once you stop thinking in terms of \"contracts that own state\" 和 start thinking in terms of \"programs that operate on 账户.\" On Solana, the durable state of your app does no..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "On Solana, mutable app state is 账户 data. Programs validate 和 mutate those 账户 but do not hold mutable state internally."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "The runtime checks the message envelope 和 authorization: fee payer, freshness via blockhash, required signatures, 和 指令 payloads."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].explanation",
          "englishWordCount": 12,
          "excerpt": "Read/write sets let the runtime detect conflicts 和 parallelize independent work deterministically."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].content",
          "englishWordCount": 217,
          "excerpt": "# 账户 model 深入解析 Every on-chain object on Solana is an 账户 使用 a standard envelope. You can reason about any 账户 using a small set of fields: address, lamports, owner, executable flag, 和 data bytes length/content. Address (a..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].explanation",
          "englishWordCount": 12,
          "excerpt": "SPL token state uses dedicated 账户 layouts 和 authorization rules enforced by the token program."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].content",
          "englishWordCount": 265,
          "excerpt": "# 交易 & 指令 An 指令 is the smallest executable unit on Solana: `programId + account metas + opaque data bytes`. A 交易 wraps one or more 指令 plus signatures 和 message metadata. This 设计 gives you composability 和 atomicity in one..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].content",
          "englishWordCount": 54,
          "excerpt": "# Build a SOL transfer 交易 Implement a deterministic `buildTransferTx(params)` helper in the project file: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` - Use `@solana/web3.js` - Return a 交易 使用 exactly ..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[2]",
          "englishWordCount": 13,
          "excerpt": "Mirror this logic in the real project helper in src/lib/课程/solana-fundamentals/project/walletManager.ts."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].content",
          "englishWordCount": 218,
          "excerpt": "# Programs: what they are (和 aren’t) A Solana program is executable 账户 code, not an object that secretly owns mutable storage. Your program receives 账户 from the 交易, verifies constraints, 和 writes only to 账户 it is authori..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "账户 lists are part of the 指令 contract; hidden discovery would break determinism 和 scheduling assumptions."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].content",
          "englishWordCount": 213,
          "excerpt": "# 程序派生地址 (PDAs) A 程序派生地址 (PDA) is a deterministic 账户 address derived from seeds plus a program ID, 使用 one key property: it is intentionally off-curve, so no private key exists 用于 it. This lets your program control addres..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].content",
          "englishWordCount": 211,
          "excerpt": "# SPL Tokens 基础 SPL Token is Solana’s standard token program family 用于 fungible assets. A token mint 账户 defines token-level configuration: decimals, total supply accounting, 和 authorities such as mint authority or freeze..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Associated Token 账户 standardize where fungible token balances are stored 用于 each owner/mint."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].content",
          "englishWordCount": 51,
          "excerpt": "# 钱包 Manager CLI-sim Implement a deterministic CLI parser + command executor in: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` Required behavior: - `address` prints the active pubkey - `build-transfer ..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].content",
          "englishWordCount": 320,
          "excerpt": "# Anchor 思维模型 Anchor is best understood as a contract between three layers that must agree on shape: your Rust handlers, generated interface metadata (IDL), 和 client-side 指令 builders. In raw Solana programs you manually ..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].content",
          "englishWordCount": 244,
          "excerpt": "# 账户, constraints, 和 safety Most serious Solana vulnerabilities come from 账户 validation mistakes, not from arithmetic. Anchor’s constraint system exists to turn those checks into declarative, auditable rules. You declare..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].content",
          "englishWordCount": 225,
          "excerpt": "# PDAs in Anchor 程序派生地址 are the backbone of predictable 账户 topology in Anchor applications. A PDA is derived from seed bytes plus program ID 和 intentionally lives off the ed25519 curve, so no private key exists 用于 it. Th..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].content",
          "englishWordCount": 62,
          "excerpt": "# Initialize Counter PDA (deterministic) Implement deterministic helper functions 用于 a Counter project: - `deriveCounterPda(programId, authorityPubkey)` - `buildInitCounterIx(params)` This 课时 validates client-side reason..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[1]",
          "englishWordCount": 14,
          "excerpt": "The init 指令 must include four keys in fixed order: counter PDA, authority, payer, system program."
        },
        {
          "path": "courses.anchor-development.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Deterministic 指令 builders, stable state emulation, 和 测试 strategy that separates pure logic from network integration."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].content",
          "englishWordCount": 38,
          "excerpt": "# Increment 指令 builder + state layout Implement deterministic increment behavior in pure TypeScript: - Build a reusable state representation 用于 counter data. - Implement `applyIncrement` as a pure transition function. - ..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].content",
          "englishWordCount": 226,
          "excerpt": "# 测试 strategy without flakiness A reliable Solana curriculum should teach deterministic engineering first, then optional network integration. Flaky tests are usually caused by external dependencies: RPC latency, faucet l..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].content",
          "englishWordCount": 226,
          "excerpt": "# Client composition & UX Once 指令 layouts 和 PDA logic are deterministic, client integration becomes a composition exercise: 钱包 adapter 用于 signing, provider/connection 用于 transport, 交易 builder 用于 指令 packing, 和 UI state 用于..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].content",
          "englishWordCount": 47,
          "excerpt": "# Counter project checkpoint Compose the full deterministic flow: 1. Derive counter PDA from authority + program ID. 2. Build init 指令 metadata. 3. Build increment 指令 metadata. 4. Emulate state transitions: `init -> incre..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[1]",
          "englishWordCount": 13,
          "excerpt": "Use fixed key order 和 fixed JSON key order to satisfy strict expected output matching."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].content",
          "englishWordCount": 430,
          "excerpt": "# 钱包 state + 账户 思维模型 用于 UI devs Most Solana frontend bugs are not visual bugs. They are model bugs. A dashboard can look polished while silently computing balances from the wrong 账户 class, mixing lamports 使用 token units,..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].content",
          "englishWordCount": 335,
          "excerpt": "# 交易 lifecycle 用于 UI: pending/confirmed/finalized, optimistic UI Frontend 交易 UX is a state machine problem. Users press one button, but your app traverses multiple phases: intent creation, 交易 construction, signature requ..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].content",
          "englishWordCount": 349,
          "excerpt": "# Data correctness: dedupe, ordering, idempotency, correction events Frontend teams frequently assume event streams are perfectly ordered 和 unique. Production systems rarely behave that way. You can receive duplicate eve..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].content",
          "englishWordCount": 31,
          "excerpt": "# Build core state model + reducer from events Implement a deterministic reducer 用于 dashboard state: - apply event stream transitions 用于 balances 和 mint metadata - enforce idempotency by event id - support correction mar..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Corrections should mark replaced event ids 和 remove their effects from state transitions."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].content",
          "englishWordCount": 27,
          "excerpt": "# Implement event stream simulator + replay timeline + snapshots Build deterministic replay tooling: - replay sorted events by (ts, id) - snapshot every N applied events - compute stable checksum 用于 replay output - retur..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].content",
          "englishWordCount": 28,
          "excerpt": "# Implement query layer + computed metrics Implement dashboard query/view logic: - search/filter/sort rows deterministically - compute total 和 row valueUsd 使用 fixed-scale integer math - expose stable view model 用于 UI ren..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].content",
          "englishWordCount": 378,
          "excerpt": "# Production UX: caching, pagination, error banners, skeletons, rate limits After model correctness, frontend quality is mostly about user trust under imperfect conditions. Users do not evaluate your dashboard by clean d..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[3].content",
          "englishWordCount": 27,
          "excerpt": "# Emit stable DashboardSummary from fixtures Compose deterministic checkpoint output: - owner, token count, totalValueUsd - top tokens sorted deterministically - recent activity rows - invariants 和 determinism metadata (..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].content",
          "englishWordCount": 501,
          "excerpt": "# AMM 基础 on Solana: pools, fees, slippage, 和 价格影响 When users click “Swap,” they usually assume there is one objective truth: the current price. In practice, frontend swap systems compute an estimate from pool reserves 和 ..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].content",
          "englishWordCount": 379,
          "excerpt": "# Quote anatomy: in/out, fees, minOut, 和 worst-case execution A production quote is not one number. It is a structured object that must tell users what they send, what they likely receive, how much they pay in fees, 和 wh..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].content",
          "englishWordCount": 398,
          "excerpt": "# Routing: why two-hop can beat one-hop Users often assume direct pair routes are always best because they are simpler. In fragmented liquidity systems, that assumption fails frequently. A direct SOL -> JUP pool might ha..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].content",
          "englishWordCount": 29,
          "excerpt": "# Implement route enumeration 和 best-route selection Implement deterministic route planner: - enumerate one-hop 和 two-hop candidates - quote each candidate at exact input size - select best route using stable tie-breaker..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].content",
          "englishWordCount": 33,
          "excerpt": "# Implement slippage/minOut, fee breakdown, 和 safety invariants Implement deterministic safety layer: - apply slippage to compute minOut - simulate route 使用 virtual reserve updates - return structured errors 用于 invalid p..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].content",
          "englishWordCount": 394,
          "excerpt": "# Production swap UX: stale quotes, protection, 和 simulation A deterministic route engine is necessary but not sufficient 用于 production. Users experience DeFi through timing, messaging, 和 safety affordances. A mathematic..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].content",
          "englishWordCount": 28,
          "excerpt": "# Produce stable SwapPlan + SwapSummary checkpoint Compose deterministic checkpoint artifacts: - build swap plan from selected route quote - include fixtureHash 和 modelVersion - emit stable summary 使用 path, minOut, fee t..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].content",
          "englishWordCount": 521,
          "excerpt": "# Solana threat model 用于 auditors: 账户, owners, signers, writable, PDAs 安全 work on Solana starts 使用 one non-negotiable fact: 指令 callers choose the 账户 list. Programs do not receive trusted implicit context. They receive ex..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].content",
          "englishWordCount": 427,
          "excerpt": "# Evidence chain: reproduce, trace, impact, fix, verify Strong 安全 reports are built on evidence chains, not opinions. In the Solana context, that means moving from a claim such as “missing signer check exists” to a deter..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].content",
          "englishWordCount": 450,
          "excerpt": "# Common Solana bug classes 和 mitigations Auditors on Solana repeatedly encounter the same core bug families. The implementation details differ across protocols, but exploit mechanics are surprisingly consistent: identit..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "安全 failures are usually adversarial edge cases, so tests must target those edges directly."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].content",
          "englishWordCount": 41,
          "excerpt": "# Break it: exploit missing signer + owner checks Implement a deterministic exploit-proof formatter 用于 signer/owner vulnerabilities. Expected output fields: - scenario - before/after vault balance - before/after recipien..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].content",
          "englishWordCount": 28,
          "excerpt": "# Break it: exploit PDA spoof mismatch Implement a deterministic PDA spoof proof output. You must show: - expected PDA - accepted PDA - mismatch boolean - trace hash This 课时 validates evidence generation 用于 derivation mi..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].content",
          "englishWordCount": 28,
          "excerpt": "# Fix it: validations + invariant suite Implement patch validation output that confirms: - signer check - owner check - PDA check - safe u64 arithmetic - exploit blocked state 使用 error code Keep output deterministic 用于 e..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].content",
          "englishWordCount": 440,
          "excerpt": "# Writing audit reports: severity, likelihood, blast radius, remediation A strong audit report is an engineering document, not a narrative essay. It should allow a reader to answer four questions quickly: what failed, ho..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].content",
          "englishWordCount": 27,
          "excerpt": "# Checkpoint: deterministic AuditReport JSON + markdown Create the final deterministic checkpoint payload: - 课程 + version - scenario IDs - finding count This checkpoint mirrors the final 课程 artifact produced by the simul..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].content",
          "englishWordCount": 369,
          "excerpt": "# SPL tokens vs Token-2022: what extensions change Token engineering starts 使用 a clean boundary between base token semantics 和 configurable policy. Legacy SPL Token gives you a stable fungible primitive: mint metadata, t..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].content",
          "englishWordCount": 348,
          "excerpt": "# Mint anatomy: authorities, decimals, supply, freeze, mint A production token launch succeeds or fails on parameter discipline. The mint 账户 is a compact policy object: it defines decimal precision, minting authority, op..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].content",
          "englishWordCount": 349,
          "excerpt": "# Extension safety pitfalls: fee configs, delegate abuse, default 账户 state Token-2022 extensions let teams express policy in a standard token framework, but policy power is exactly where operational failures happen. 安全 i..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].content",
          "englishWordCount": 35,
          "excerpt": "# Validate token config + derive deterministic addresses offline Implement strict config validation 和 deterministic pseudo-derivation: - validate decimals, u64 strings, recipient totals, extension fields - derive stable ..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].content",
          "englishWordCount": 28,
          "excerpt": "# Build Token-2022 initialization 指令 plan Create a deterministic offline initialization plan: - create mint 账户 step - init mint step 使用 decimals - append selected extension steps in stable order - base64 encode step payl..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].content",
          "englishWordCount": 27,
          "excerpt": "# Build mint-to + transfer-fee math + simulation Implement pure simulation 用于 transfer fees 和 launch distribution: - fee = min(maxFee, floor(amount * feeBps / 10000)) - aggregate distribution totals deterministically - e..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].content",
          "englishWordCount": 346,
          "excerpt": "# Launch checklist: params, upgrade/authority strategy, airdrop/测试 plan A successful token launch is an operations exercise as much as a programming task. By the time users see your token in 钱包, dozens of choices have al..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].content",
          "englishWordCount": 27,
          "excerpt": "# Emit stable LaunchPackSummary Compose full project output as stable JSON: - normalized authorities 和 extensions - supply totals 和 optional fee model examples - deterministic plan metadata 和 invariants - fixtures hash +..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[0].content",
          "englishWordCount": 311,
          "excerpt": "# Mobile 钱包 概览 Solana Mobile development is built around the Solana Mobile Stack (SMS), a set of standards 和 tooling designed 用于 secure, high-quality crypto-native mobile experiences. SMS is more than a hardware initiati..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[1].content",
          "englishWordCount": 219,
          "excerpt": "# MWA Integration Integrating Mobile 钱包 Adapter typically starts 使用 `@solana-mobile/mobile-wallet-adapter` APIs 和 an interaction pattern built around `transact()`. Within a 交易 session, the app can authorize, request capa..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].content",
          "englishWordCount": 23,
          "excerpt": "# Build a Mobile 交易 Function Implement a helper that formats a deterministic MWA 交易 request summary string. Expected output format: `<cluster>|<payer>|<instructionCount>` Use this exact order 和 delimiter."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[0].content",
          "englishWordCount": 243,
          "excerpt": "# dApp Store Submission Publishing to the Solana dApp Store requires more than packaging binaries. Teams should treat submission as a product, compliance, 和 安全 review process. A strong submission demonstrates safe 钱包 int..."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[1].content",
          "englishWordCount": 263,
          "excerpt": "# Mobile 最佳实践 Mobile crypto UX requires balancing speed, safety, 和 trust. Users make high-stakes decisions on small screens, often on unstable networks. Solana mobile apps should therefore optimize 用于 explicitness 和 reco..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[0].content",
          "englishWordCount": 272,
          "excerpt": "# 测试 Approaches 测试 Solana programs requires multiple layers because failures can occur in logic, 账户 validation, 交易 composition, or network behavior. A production 测试 strategy usually combines unit tests, integration tests..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[1].content",
          "englishWordCount": 218,
          "excerpt": "# Bankrun 测试 Solana Bankrun provides deterministic, high-speed test execution 用于 Solana programs from TypeScript environments. It emulates a local bank-like runtime where 交易 can be processed predictably, 账户 can be inspec..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[0].content",
          "englishWordCount": 235,
          "excerpt": "# Fuzzing 使用 Trident Fuzzing explores large input spaces automatically to find bugs that handcrafted tests miss. 用于 Solana 和 Anchor programs, Trident-style fuzzing workflows generate randomized 指令 sequences 和 parameter v..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[1].content",
          "englishWordCount": 200,
          "excerpt": "# Devnet 测试 Devnet 测试 bridges the gap between deterministic local tests 和 real-world network conditions. While local 验证者 和 Bankrun are ideal 用于 speed 和 reproducibility, devnet reveals behavior under real RPC latency, blo..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[2].content",
          "englishWordCount": 204,
          "excerpt": "# CI/CD Pipeline 用于 Solana A mature Solana CI/CD pipeline enforces quality gates across code, tests, 安全 checks, 和 部署 workflows. 用于 program teams, CI is not just linting Rust 和 TypeScript; it is about protecting on-chain ..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].content",
          "englishWordCount": 284,
          "excerpt": "# Events model: 交易, logs, 和 program 指令 Indexing Solana starts 使用 understanding where data lives 和 how to extract structured events from raw chain data. Unlike EVM chains where events are explicit log topics, Solana encod..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Solana programs emit events via logs 和 state changes, not explicit event topics."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].content",
          "englishWordCount": 198,
          "excerpt": "# Token 账户 decoding 和 SPL layout SPL Token 账户 follow a standardized binary layout that indexers must parse to track balances 和 mint operations. Understanding this layout enables you to extract meaningful data from raw 账户..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Amounts are stored as little-endian u64 和 must be converted using the mint's decimal places."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[2].content",
          "englishWordCount": 46,
          "excerpt": "# Challenge: Decode token 账户 + diff token balances Implement deterministic token 账户 decoding 和 balance diffing: - Parse a 165-byte SPL Token 账户 layout - Extract mint, owner, 和 amount fields - Compute balance differences ..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].content",
          "englishWordCount": 216,
          "excerpt": "# 交易 meta parsing: logs, errors, 和 inner 指令 交易 metadata provides the context needed to index complex operations. Understanding how to parse logs, handle errors, 和 traverse inner 指令 enables comprehensive event extraction...."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].content",
          "englishWordCount": 37,
          "excerpt": "# Challenge: Index 交易 to normalized events Implement a 交易 indexer that produces normalized Event objects: - Parse 指令 logs 和 identify event types - Extract transfer events 使用 from/to/amount/mint - Handle multiple events p..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].content",
          "englishWordCount": 214,
          "excerpt": "# Pagination, checkpointing, 和 caching semantics Production indexers must handle large datasets efficiently while maintaining consistency. Pagination, checkpointing, 和 caching form the backbone of scalable indexing infra..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[2].content",
          "englishWordCount": 200,
          "excerpt": "# Analytics aggregation: per 钱包, per token metrics Raw event data becomes valuable through aggregation. Building analytics pipelines enables insights into user behavior, token flows, 和 protocol usage patterns. Per-钱包 ana..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].content",
          "englishWordCount": 49,
          "excerpt": "# Checkpoint: Produce stable JSON analytics summary Implement the final analytics checkpoint that produces a deterministic summary: - Aggregate events into per-钱包 和 per-token metrics - Generate sorted, stable JSON output..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].content",
          "englishWordCount": 243,
          "excerpt": "# Address validation 和 memo strategies Payment flows on Solana require robust address validation 和 thoughtful memo strategies. Unlike traditional payment systems 使用 账户 numbers, Solana uses base58-encoded public keys that..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[1].content",
          "englishWordCount": 207,
          "excerpt": "# Idempotency keys 和 replay protection Payment systems must handle network failures gracefully. Idempotency ensures that retrying a failed request produces the same outcome as the original, preventing duplicate charges 和..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].content",
          "englishWordCount": 46,
          "excerpt": "# Challenge: Create payment intent 使用 validation Implement a payment intent creator 使用 full validation: - Validate recipient address format (base58, 32 bytes) - Validate amount (positive, within limits) - Generate determ..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[3].content",
          "englishWordCount": 184,
          "excerpt": "# 交易 building 和 key metadata Building payment 交易 requires careful attention to 指令 construction, 账户 metadata, 和 program interactions. The goal is creating valid, efficient 交易 that minimize fees while ensuring correctness...."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].content",
          "englishWordCount": 28,
          "excerpt": "# Challenge: Build transfer 交易 Implement a transfer 交易 builder: - Build SystemProgram.transfer 用于 SOL transfers - Build TokenProgram.transfer 用于 SPL transfers - Return 指令 bundle 使用 correct key metadata - Include fee paye..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].content",
          "englishWordCount": 177,
          "excerpt": "# Webhook signing 和 verification Webhooks enable asynchronous payment notifications. 安全 requires cryptographic signing so recipients can verify webhook authenticity 和 detect tampering. Webhook signing uses HMAC-SHA256 使用..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].content",
          "englishWordCount": 185,
          "excerpt": "# Error state machine 和 receipt format Payment flows require well-defined state machines to handle the complexity of asynchronous confirmations, failures, 和 retries. Clear state transitions 和 receipt formats ensure relia..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].content",
          "englishWordCount": 43,
          "excerpt": "# Challenge: Verify webhook 和 produce receipt Implement the final payment flow checkpoint: - Verify signed webhook signature (HMAC-SHA256) - Extract payment details from payload - Generate standardized receipt JSON - Inc..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].content",
          "englishWordCount": 269,
          "excerpt": "# Merkle trees 用于 state compression Compressed NFTs (cNFTs) on Solana use Merkle trees to dramatically reduce storage costs. Understanding Merkle trees is essential 用于 working 使用 compressed NFTs 和 building compression-aw..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[1].content",
          "englishWordCount": 205,
          "excerpt": "# Leaf hashing conventions 和 metadata Leaf hashing determines how NFT metadata is committed to the Merkle tree. Understanding these conventions ensures compatibility 使用 compression standards 和 proper proof generation. Le..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement Merkle tree insert + root updates Build a Merkle tree implementation 使用 insertions: - Insert leaves 和 compute new root - Update parent hashes up the tree - Handle tree growth 和 depth limits - Retur..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].content",
          "englishWordCount": 216,
          "excerpt": "# Proof generation 和 path computation Merkle proofs enable verification of leaf inclusion without accessing the entire tree. Understanding proof generation is essential 用于 working 使用 compressed NFTs 和 building verificati..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement proof generation + verifier Build a complete proof system: - Generate proofs from a Merkle tree 和 leaf index - Verify proofs against a root hash - Handle invalid proofs (wrong siblings, wrong index..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[1].content",
          "englishWordCount": 206,
          "excerpt": "# Collection mints 和 metadata simulation Compressed NFT collections use a collection mint as the parent NFT, enabling grouping 和 verification of related assets. Understanding this hierarchy is essential 用于 building colle..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].content",
          "englishWordCount": 247,
          "excerpt": "# Attack surface: invalid proofs 和 replay Compressed NFTs introduce unique 安全 considerations. Understanding attack vectors 和 mitigations is critical 用于 building secure compression-aware applications. Invalid proof attack..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].content",
          "englishWordCount": 50,
          "excerpt": "# Checkpoint: Simulate mint + verify ownership proof Complete the compression lab checkpoint: - Simulate minting a cNFT (insert leaf, update root) - Generate ownership proof 用于 the minted NFT - Verify the proof against c..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].content",
          "englishWordCount": 232,
          "excerpt": "# DAO model: proposals, voting, 和 execution Decentralized 治理 on Solana follows a proposal-based model where token holders vote on changes 和 the DAO treasury executes approved decisions. Understanding this flow is essenti..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[1].content",
          "englishWordCount": 179,
          "excerpt": "# Quorum math 和 vote weight calculation Accurate vote counting is critical 用于 legitimate 治理 outcomes. Understanding quorum requirements, vote weight calculation, 和 edge cases ensures fair decision-making. Quorum defines ..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].content",
          "englishWordCount": 161,
          "excerpt": "# Timelock states 和 execution scheduling Timelocks provide a critical safety layer between 治理 approval 和 execution. Understanding timelock states 和 transitions ensures reliable proposal execution. Timelock states include..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].content",
          "englishWordCount": 159,
          "excerpt": "# Multisig 交易 building 和 approvals Multisig 钱包 provide collective control over treasury funds. Understanding multisig construction, approval flows, 和 安全 patterns is essential 用于 treasury operations. Multisig structure de..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].content",
          "englishWordCount": 29,
          "excerpt": "# Challenge: Implement multisig tx builder + approval rules Build a multisig 交易 system: - Create 交易 使用 指令 - Record signer approvals - Enforce threshold requirements - Handle approval revocation - Generate deterministic 交..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].content",
          "englishWordCount": 175,
          "excerpt": "# Safe defaults: owner checks 和 replay guards 治理 和 multisig systems require robust 安全 defaults. Understanding common vulnerabilities 和 their mitigations protects treasury funds. Owner checks validate that 交易 only affect ..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].content",
          "englishWordCount": 44,
          "excerpt": "# Challenge: Execute proposal 和 produce treasury diff Complete the 治理 simulator checkpoint: - Execute approved proposals 使用 timelock validation - Apply treasury state changes atomically - Generate execution trace 使用 befo..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].content",
          "englishWordCount": 210,
          "excerpt": "# Compute model: budgets, costs, 和 limits Solana's compute model enforces deterministic execution limits through compute budgets. Understanding this model is essential 用于 building efficient programs that stay within limi..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[1].content",
          "englishWordCount": 177,
          "excerpt": "# 账户 layout 设计 和 serialization cost 账户 data layout significantly impacts compute costs. Well-designed layouts minimize serialization overhead 和 reduce 账户 access costs. Serialization formats affect cost. Borsh is the stan..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].content",
          "englishWordCount": 37,
          "excerpt": "# Challenge: Implement estimateCost(op) model Build a compute cost estimation system: - Model costs 用于 different operation types - 账户 用于 指令 complexity - Include memory access costs - Return baseline measurements - Handle..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].content",
          "englishWordCount": 144,
          "excerpt": "# 指令 data size 和 encoding optimization 指令 data size directly impacts 交易 cost 和 throughput. Optimizing encoding reduces fees 和 increases the operations possible within compute limits. Compact encoding uses minimal bytes t..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement optimized layout/codec Optimize an 账户 data layout while preserving semantics: - Reduce data size through compact encoding - Maintain all original functionality - Preserve backward compatibility whe..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].content",
          "englishWordCount": 163,
          "excerpt": "# Compute budget 指令 基础 Compute budget 指令 give developers control over resource allocation 和 交易 prioritization. Understanding these tools enables precise optimization. setComputeUnitLimit requests a specific CU budget. Th..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Specific limits optimize costs - you pay 用于 the limit requested, not actual usage."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].content",
          "englishWordCount": 156,
          "excerpt": "# Micro-optimizations 和 tradeoffs 性能 optimization involves balancing competing concerns. Understanding tradeoffs helps make informed decisions about when 和 what to optimize. Readability vs 性能 is a constant tension. Highl..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].content",
          "englishWordCount": 37,
          "excerpt": "# Checkpoint: Compare before/after + output perf report Complete the optimization lab checkpoint: - Measure baseline 性能 metrics - Apply optimization techniques - Verify correctness is preserved - Generate 性能 comparison r..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].content",
          "englishWordCount": 376,
          "excerpt": "# Swap 思维模型: mints, ATAs, decimals, 和 routes Token swaps on Solana follow a fundamentally different model than centralized exchanges. Understanding the building blocks — mints, associated token 账户 (ATAs), decimal precisi..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 18,
          "excerpt": "AMM programs interact 使用 SPL token 账户. Native SOL must be wrapped into the SPL token format so it can be processed by swap programs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].content",
          "englishWordCount": 348,
          "excerpt": "# Slippage 和 价格影响: protecting swap outcomes Slippage is the difference between the expected output amount at quote time 和 the actual amount received at execution time. In volatile markets 使用 active trading, pool reserves..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 18,
          "excerpt": "Token amounts are integers. Floating-point math can produce off-by-one errors that cause 交易 failures or incorrect minimum amounts."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].content",
          "englishWordCount": 385,
          "excerpt": "# Route visualization: understanding swap legs 和 fees Swap routes reveal the path your tokens take through DeFi liquidity. Visualizing routes helps users understand why a multi-hop path might yield more output than a dir..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].content",
          "englishWordCount": 64,
          "excerpt": "# Challenge: Build a normalized SwapPlan from a quote Parse a raw aggregator quote response 和 produce a normalized SwapPlan: - Extract input/output mints 和 amounts from the quote - Calculate minOutAmount using BigInt sli..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].content",
          "englishWordCount": 66,
          "excerpt": "# Challenge: Implement swap UI state machine Build a deterministic state machine 用于 the swap UI flow: - States: idle → quoting → ready → sending → confirming → success | error - Process a sequence of events 和 track all s..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].content",
          "englishWordCount": 368,
          "excerpt": "# Swap 交易 anatomy: 指令, 账户, 和 compute A swap 交易 on Solana is a carefully ordered sequence of 指令 that together achieve an atomic token exchange. Understanding each 指令's role, the 账户 list requirements, 和 compute budget cons..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].content",
          "englishWordCount": 356,
          "excerpt": "# Reliability patterns: retries, stale quotes, 和 latency Production swap flows must handle the reality of network latency, expired quotes, 和 交易 failures. Reliability engineering separates toy swap implementations from pr..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].content",
          "englishWordCount": 65,
          "excerpt": "# Checkpoint: Generate a SwapRunReport Build the final swap run report that combines all 课程 concepts: - Summarize the route 使用 leg details 和 total fees (using BigInt summation) - Compute the effective price as outAmount ..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Collect errors from both the state machine result 和 any additional errors array."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].content",
          "englishWordCount": 619,
          "excerpt": "# CLMM vs constant product: why ticks exist Concentrated Liquidity Market Makers (CLMMs) represent a fundamental evolution in automated market maker 设计. To understand why they exist, we must first understand the limitati..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Ticks provide discrete price points 用于 position boundaries, liquidity transitions, 和 efficient fee tracking at tick crossings."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].content",
          "englishWordCount": 530,
          "excerpt": "# Price, tick, 和 sqrtPrice: core conversions The mathematical foundation of every CLMM rests on three interrelated representations of price: the human-readable price, the tick index, 和 the sqrtPriceX64. Understanding how..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Token amounts in a CLMM position are linear functions of sqrtPrice, making on-chain computation simpler 和 more gas-efficient."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].content",
          "englishWordCount": 618,
          "excerpt": "# Range positions: in-range 和 out-of-range dynamics A CLMM position is defined by its lower tick 和 upper tick. These two boundaries determine the price range in which the position is active, earns fees, 和 holds a mix of ..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].content",
          "englishWordCount": 61,
          "excerpt": "# Challenge: Implement tick/price conversion helpers Implement the core tick math functions used in every CLMM integration: - Convert a tick index to a human-readable price using price = 1.0001^tick - Convert the price t..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].content",
          "englishWordCount": 65,
          "excerpt": "# Challenge: Simulate position fee accrual Implement a fee accrual simulator 用于 a CLMM position over a price path: - Convert lower 和 upper tick boundaries to prices - Walk through each price in the path 和 determine in-ra..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].content",
          "englishWordCount": 615,
          "excerpt": "# Range strategies: tight, wide, 和 rebalancing rules Choosing the right price range is the most important decision a CLMM liquidity provider makes. The range determines capital efficiency, fee income, impermanent loss ex..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "Tight ranges concentrate capital 用于 higher efficiency 和 fee share, but the position goes out-of-range more often, requiring active management."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Full-range positions replicate constant product behavior 和 never go out-of-range, making them suitable 用于 highly volatile or unpredictable pairs."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].content",
          "englishWordCount": 631,
          "excerpt": "# CLMM risks: rounding, overflow, 和 tick spacing errors Building reliable CLMM integrations requires awareness of precision risks that can cause incorrect calculations, failed 交易, or lost funds. This 课时 catalogs the most..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].content",
          "englishWordCount": 64,
          "excerpt": "# Checkpoint: Generate a Position Report Implement a comprehensive LP position report generator that combines all CLMM concepts: - Convert tick boundaries to human-readable prices - Determine in-range or out-of-range sta..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].content",
          "englishWordCount": 512,
          "excerpt": "# Lending pool model: supply, borrow, 和 utilization Lending protocols are the backbone of decentralized finance. They enable users to earn yield on idle assets by supplying them to a shared pool, while borrowers draw fro..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].content",
          "englishWordCount": 425,
          "excerpt": "# Interest rate curves 和 the kink model Interest rates in lending protocols are not fixed. They adjust dynamically based on pool utilization to balance supply 和 demand 用于 liquidity. The piecewise-linear \"kink\" model is t..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "Above the kink, slope2 (the jump multiplier) applies, causing borrow rates to spike sharply 和 discourage further borrowing."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Supply rate = borrowRate * utilization * (1 - reserveFactor). Since utilization < 1 和 reserveFactor > 0, the supply rate is always less than the borrow rate."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].content",
          "englishWordCount": 424,
          "excerpt": "# Health factor monitoring 和 liquidation preview The health factor is the single number that determines whether a lending position is safe or subject to liquidation. Monitoring health factors in real time is essential 用于..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].content",
          "englishWordCount": 83,
          "excerpt": "# Challenge: Compute utilization-based interest rates Implement the kink-based interest rate model used by lending protocols: - Calculate the utilization ratio from total supply 和 total borrowed - Apply the piecewise-lin..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].content",
          "englishWordCount": 73,
          "excerpt": "# Challenge: Compute health factor 和 liquidation status Implement the health factor computation 用于 a multi-asset lending position: - Sum collateral 和 borrow values from an array of position objects - Compute weighted ave..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].content",
          "englishWordCount": 504,
          "excerpt": "# Liquidation mechanics: bonus, close factor, 和 bad debt Liquidation is the enforcement mechanism that keeps lending protocols solvent. When a borrower's health factor falls below 1.0, external actors called liquidators ..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 16,
          "excerpt": "The liquidation bonus compensates liquidators 用于 gas costs 和 risk, ensuring positions are liquidated promptly to protect the protocol."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Bad debt materializes when rapid price drops make collateral worth less than the debt, leaving the protocol 使用 unrecoverable losses."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].content",
          "englishWordCount": 555,
          "excerpt": "# Oracle risk 和 stale pricing in lending Lending protocols depend entirely on accurate, timely price feeds to compute collateral values, health factors, 和 liquidation eligibility. Oracles — the services that bring off-ch..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 18,
          "excerpt": "Using price minus confidence 用于 collateral gives a conservative valuation, protecting the protocol when oracle publishers disagree or markets are volatile."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Operating on stale prices is dangerous. Pausing operations prevents incorrect liquidations 和 under-collateralized borrows during oracle outages."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].content",
          "englishWordCount": 76,
          "excerpt": "# Checkpoint: Generate a multi-scenario risk report Build the final risk report that combines all 课程 concepts: - Evaluate a base case using current position prices - Apply price overrides from multiple named scenarios (b..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].content",
          "englishWordCount": 598,
          "excerpt": "# Perpetual futures: base positions, entry price, 和 mark vs oracle Perpetual futures (perps) are synthetic derivatives that let traders gain exposure to an asset's price movement without holding the underlying token. Unl..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].content",
          "englishWordCount": 587,
          "excerpt": "# Funding rates: why they exist 和 how they accrue Funding rates are the mechanism that tethers a perpetual contract's price to the underlying spot price. Without funding, the perp price could drift arbitrarily far from r..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "A positive premium (mark > oracle) produces a positive funding rate. Longs pay shorts, which discourages excessive long demand 和 pushes the perp price back toward spot."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].content",
          "englishWordCount": 539,
          "excerpt": "# PnL visualization: tracking profit over time Profit 和 loss (PnL) tracking in perpetual futures requires careful accounting across multiple dimensions: unrealized PnL from price movement, realized PnL from closed portio..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].content",
          "englishWordCount": 54,
          "excerpt": "# Challenge: Calculate perpetual futures PnL Implement a PnL calculator 用于 perpetual futures positions: - Compute unrealized PnL based on entry price vs mark price - Handle both long 和 short positions correctly - Calcula..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].content",
          "englishWordCount": 70,
          "excerpt": "# Challenge: Simulate funding rate accrual Build a funding accrual simulator that processes discrete funding intervals: - Iterate through an array of funding rates 和 compute the payment 用于 each period - Longs pay (subtra..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].content",
          "englishWordCount": 579,
          "excerpt": "# Margin ratio 和 liquidation thresholds Margin is the collateral that backs a leveraged position. When the margin falls below a critical threshold relative to the position's notional value, the protocol forcibly closes t..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 27,
          "excerpt": "The maintenance buffer ensures that when a position is liquidated, there is still margin left to pay liquidation fees 和 absorb slippage during the close. Without it, positions could go underwater, creating bad debt."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].content",
          "englishWordCount": 726,
          "excerpt": "# Common bugs: sign errors, units, 和 funding direction Perpetual futures implementations are mathematically straightforward — the formulas are basic arithmetic. Yet sign errors, unit mismatches, 和 funding direction bugs ..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 35,
          "excerpt": "When size carries the direction sign, every formula that uses size must 账户 用于 the sign — not just PnL, but also notional value, funding payments, 和 liquidation price. Keeping size positive 和 branching on a separate 'side..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].content",
          "englishWordCount": 71,
          "excerpt": "# Checkpoint: Generate a Risk Console Report Build the comprehensive risk console report that integrates all 课程 concepts: - Calculate unrealized PnL 和 ROE 用于 the position - Accumulate funding payments across all provided..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].content",
          "englishWordCount": 497,
          "excerpt": "# Why DeFi 交易 fail: CU limits, size, 和 blockhash expiry DeFi 交易 on Solana fail 用于 three primary reasons: compute budget exhaustion, 交易 size overflow, 和 blockhash expiry. Understanding each failure mode is essential befor..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Solana allocates 200,000 CUs by default. DeFi 交易 almost always need more, requiring an explicit SetComputeUnitLimit 指令."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Expired blockhash 交易 are never processed 和 produce no on-chain record. The client must detect the timeout 和 resubmit 使用 a fresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].content",
          "englishWordCount": 427,
          "excerpt": "# Compute budget 指令 和 priority fee strategy The Compute Budget Program provides two critical 指令 that every serious DeFi 交易 should include: `SetComputeUnitLimit` 和 `SetComputeUnitPrice`. Together, they control how much co..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "账户 state may change between simulation 和 execution, causing minor CU variations. A 10% margin absorbs these differences."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].content",
          "englishWordCount": 438,
          "excerpt": "# 交易 cost estimation 和 fee planning Accurate fee estimation is the foundation of a good DeFi user experience. Users need to know what a 交易 will cost before they sign it. 验证者 need sufficient fees to prioritize your 交易. Ge..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].content",
          "englishWordCount": 68,
          "excerpt": "# Challenge: Build a 交易 plan 使用 compute budgeting Build a 交易 planning function that analyzes a set of 指令 和 produces a complete 交易 plan: - Sum estimatedCU from all 指令 和 add a 10% safety margin (ceiling) - Cap the compute ..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].content",
          "englishWordCount": 89,
          "excerpt": "# Challenge: Plan Address Lookup Table usage Build a function that determines the optimal Address Lookup Table strategy 用于 a 交易: - Collect all unique 账户 keys across 指令 - Check which keys exist in available LUTs - Calcula..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].content",
          "englishWordCount": 502,
          "excerpt": "# Reliability patterns: retry, re-quote, resend vs rebuild Production DeFi applications must handle 交易 failures gracefully. The difference between a frustrating 和 a reliable experience comes down to retry strategy: knowi..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 22,
          "excerpt": "Rebuilding is necessary when the 交易's blockhash is stale or when on-chain state has changed (e.g., slippage exceeded). Simple network issues only require resending the same bytes."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "englishWordCount": 12,
          "excerpt": "To prevent many clients from retrying at the exact same moment 和 overwhelming the network"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].content",
          "englishWordCount": 548,
          "excerpt": "# UX: actionable error messages 用于 交易 failures Raw Solana error messages are cryptic. \"交易 simulation failed: Error processing 指令 2: custom program error: 0x1771\" tells a developer something but tells a user nothing. Mapp..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].content",
          "englishWordCount": 81,
          "excerpt": "# Checkpoint: Generate a send strategy report Build the final send strategy report that combines all 课程 concepts into a comprehensive 交易 optimization plan: - Build a tx plan: sum CU estimates 使用 10% margin (capped at 1,4..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].content",
          "englishWordCount": 665,
          "excerpt": "# Mobile signing reality check: Android vs iOS constraints Mobile 钱包 signing on Solana is fundamentally different from browser-based 钱包 interactions. The constraints imposed by Android 和 iOS operating systems shape every..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "Android MWA uses foreground services to maintain a persistent communication channel between the dApp 和 钱包, enabling multi-request sessions without app switching."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].content",
          "englishWordCount": 653,
          "excerpt": "# 钱包 connection UX patterns: connect, reconnect, 和 recovery 钱包 connection on mobile is the first interaction users have 使用 your dApp. A smooth connection flow builds trust; a broken one drives users away. This 课时 covers ..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Network mismatches should be communicated clearly to the user 使用 指令 on how to resolve them, avoiding confusing silent failures."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].content",
          "englishWordCount": 599,
          "excerpt": "# Signing session timeline: request, 钱包, 和 response flow Understanding the complete lifecycle of a mobile signing request is essential 用于 building reliable dApps. Every sign request passes through multiple stages, each 使..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].content",
          "englishWordCount": 61,
          "excerpt": "# Challenge: Build a typed sign request Implement a sign request builder 用于 Mobile 钱包 Adapter: - Validate the payload type (交易 or message) - Validate payload data (base64 用于 交易, non-empty string 用于 messages) - Set sessio..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[2]",
          "englishWordCount": 13,
          "excerpt": "App identity requires at least name 和 URI. Icon is optional but should default to empty string."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].content",
          "englishWordCount": 55,
          "excerpt": "# Challenge: Session persistence 和 restoration Implement a session persistence manager 用于 mobile 钱包 sessions: - Process a sequence of actions: save, restore, clear, 和 expire_check - Track 钱包 address 和 last sign request I..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].content",
          "englishWordCount": 570,
          "excerpt": "# Mobile 交易 review: what users need to see 交易 review screens are the last line of defense between a user 和 a potentially harmful 交易. On mobile, screen real estate is limited 和 user attention is fragmented. Designing effe..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 16,
          "excerpt": "Token amounts must be converted to human-readable format using the token's decimal configuration 和 include the symbol 用于 clarity."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Balance change summaries (e.g., -1.5 SOL, +150 USDC) are the most user-friendly way to communicate what a 交易 will do."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].content",
          "englishWordCount": 657,
          "excerpt": "# One-tap retry: handling offline, rejected, 和 timeout states Mobile environments are inherently unreliable. Users move between WiFi 和 cellular, enter tunnels, close apps mid-交易, 和 钱包 crash. A robust retry system is not ..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].content",
          "englishWordCount": 57,
          "excerpt": "# Checkpoint: Generate a session report Implement a session report generator that summarizes a complete mobile signing session: - Count total requests, successful signs, 和 failed signs - Sum retry attempts across all req..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].content",
          "englishWordCount": 550,
          "excerpt": "# Solana Pay 思维模型 和 URL encoding rules Solana Pay is an open specification 用于 encoding payment requests into URLs that 钱包 can parse 和 execute. Unlike traditional payment processors that rely on centralized intermediaries..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "The Solana Pay specification uses the 'solana:' scheme followed immediately by the recipient address 使用 no slashes."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "交易 requests allow the server to build arbitrarily complex 交易. Transfer requests only support simple single-token transfers."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].content",
          "englishWordCount": 584,
          "excerpt": "# Transfer request anatomy: recipient, amount, reference, 和 labels A Solana Pay transfer request URL contains everything a 钱包 needs to construct 和 submit a payment 交易. Each component of the URL serves a specific purpose ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "The reference public key is included as a non-signer 账户 in the transfer 指令. The merchant polls getSignaturesForAddress(reference) to detect when the payment 交易 confirms."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Solana Pay URLs use human-readable decimal amounts. The 钱包 handles the conversion to raw units based on the token's decimal configuration."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].content",
          "englishWordCount": 448,
          "excerpt": "# URL builder: live preview of Solana Pay URLs Building Solana Pay URLs correctly requires understanding how each parameter contributes to the final encoded string. In this 课时, we walk through the construction process st..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].content",
          "englishWordCount": 72,
          "excerpt": "# Challenge: Encode a Solana Pay transfer request URL Build a function that encodes a Solana Pay transfer request URL from input parameters: - Validate the recipient address (must be 32-44 characters of valid base58) - V..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].content",
          "englishWordCount": 82,
          "excerpt": "# Challenge: Track payment references through confirmation states Build a reference tracking state machine that processes payment events: - States flow: pending -> found -> confirmed -> finalized (or pending -> expired) ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].content",
          "englishWordCount": 600,
          "excerpt": "# Confirmation UX: pending, confirmed, 和 expired states The user experience during payment confirmation is the most critical moment in any Solana Pay integration. Between the customer scanning the QR code 和 the merchant ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "用于 coffee-shop-scale payments, confirmed commitment provides a strong enough guarantee. Finalized adds 6-12 seconds of latency 和 is only necessary when fulfillment is irreversible."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 22,
          "excerpt": "Expired requests should be clearly communicated. The customer may have been in the middle of approving — they need to know the request expired 和 can try again."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].content",
          "englishWordCount": 656,
          "excerpt": "# Error handling 和 edge cases in payment flows Production payment systems encounter a wide range of failure modes that must be handled gracefully. Solana Pay integrations face challenges unique to blockchain payments: ne..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].content",
          "englishWordCount": 76,
          "excerpt": "# Checkpoint: Generate a POS receipt Build the final POS receipt generator that combines all 课程 concepts: - Reconstruct the Solana Pay URL from payment data (recipient, amount, spl-token, reference, label) - Generate a d..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].content",
          "englishWordCount": 643,
          "excerpt": "# Connection UX that doesn't suck: a 设计 checklist 钱包 connection is the first interaction a user has 使用 any Solana dApp. If this experience is slow, confusing, or error-prone, most users will leave before they ever reach ..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "Skeleton UI reserves the layout space 用于 钱包-dependent content, preventing jarring shifts when the connection resolves 和 data loads."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].content",
          "englishWordCount": 675,
          "excerpt": "# Network gating 和 wrong-network recovery Solana has multiple clusters: mainnet-beta, devnet, testnet, 和 localnet. Unlike EVM chains where the 钱包 controls the network 和 emits chain-change events, Solana's network selecti..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 30,
          "excerpt": "Each Solana cluster has a unique genesis hash. Comparing the RPC's genesis hash against known values is the only reliable detection method, since URL strings can be misleading 和 钱包 don't always expose network info."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 22,
          "excerpt": "While 账户 addresses are identical across clusters, the 账户 states (balances, data, existence) are completely different. All cached RPC data must be cleared on network switch."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].content",
          "englishWordCount": 578,
          "excerpt": "# Connection state machine: states, events, 和 transitions 钱包 connection logic in most dApps is implemented as a tangle of boolean flags, useEffect hooks, 和 conditional renders. This approach leads to impossible states (l..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].content",
          "englishWordCount": 69,
          "excerpt": "# Challenge: Implement 钱包 connection state machine Build a deterministic state machine 用于 钱包 connection management: - States: disconnected, connecting, connected, error - Process a sequence of events 和 track all state tr..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].content",
          "englishWordCount": 78,
          "excerpt": "# Challenge: Cache invalidation on 钱包 events Build a cache invalidation engine that processes 钱包 events 和 invalidates the correct cache entries: - Cache entries have tags: \"账户\" (钱包-specific data), \"network\" (cluster-spec..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].content",
          "englishWordCount": 635,
          "excerpt": "# RPC reads 和 caching strategy 用于 钱包 apps Every interaction in a Solana 钱包 application ultimately depends on RPC calls: fetching balances, loading token 账户, reading program state, 和 confirming 交易. Without a caching strat..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 25,
          "excerpt": "The same 账户 address can have completely different state on mainnet vs devnet. Without the network in the key, switching clusters would return stale data from the previous cluster."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 23,
          "excerpt": "SWR prioritizes responsiveness by serving stale data instantly while refreshing in the background. This eliminates loading states 用于 data that has only slightly exceeded its TTL."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].content",
          "englishWordCount": 829,
          "excerpt": "# RPC health monitoring 和 graceful degradation RPC endpoints are the lifeline of every Solana 钱包 application. When they go down, become slow, or return stale data, your app becomes unusable. Production 钱包 apps must conti..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].content",
          "englishWordCount": 69,
          "excerpt": "# Checkpoint: Generate a 钱包 UX Report Build the final 钱包 UX quality report that combines all 课程 concepts: - Count connection attempts (CONNECT events) 和 successful connections (CONNECTED events) - Calculate success rate ..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].content",
          "englishWordCount": 767,
          "excerpt": "# Why SIWS exists: replacing connect-和-signMessage Before Sign-In 使用 Solana (SIWS) became a standard, dApps authenticated 钱包 holders using a two-step pattern: connect the 钱包, then call `signMessage` 使用 an arbitrary strin..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "Without structured format, 钱包 treat signMessage payloads as opaque bytes 和 cannot validate or warn about the content, making it easy 用于 malicious dApps to disguise harmful payloads as sign-in requests."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 23,
          "excerpt": "The server generates a unique nonce 用于 each sign-in attempt. After successful verification, the nonce is marked as consumed. Any reuse of the same nonce is rejected as a replay attack."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].content",
          "englishWordCount": 796,
          "excerpt": "# SIWS input fields 和 安全 rules The Sign-In 使用 Solana input is a structured object that defines every parameter of an authentication request. Each field has specific validation rules, 安全 implications, 和 rendering expectat..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "If the client generates nonces, an attacker can replay a previously captured nonce-signature pair. Server-generated nonces ensure each authentication attempt is unique 和 controlled by the server."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "The domain field must be a plain domain name. Protocol prefixes, paths, ports, 和 query strings must be rejected to ensure consistent domain matching."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[2].content",
          "englishWordCount": 765,
          "excerpt": "# Message preview: how 钱包 render SIWS requests When a dApp sends a SIWS sign-in request to a 钱包, the 钱包 transforms the structured input into a human-readable message that the user sees on the approval screen. Understandi..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].content",
          "englishWordCount": 65,
          "excerpt": "# Challenge: Build a validated SIWS sign-in input Implement a function that creates a validated Sign-In 使用 Solana input: - Validate domain (non-empty, must not include protocol prefix) - Validate nonce (at least 8 charac..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].content",
          "englishWordCount": 57,
          "excerpt": "# Challenge: Verify a SIWS sign-in response Implement server-side verification of a SIWS sign-in output: - Check domain matches expected domain - Check nonce matches expected nonce - Check issuedAt is not in the future r..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].content",
          "englishWordCount": 749,
          "excerpt": "# Sessions 和 logout: what to store 和 what not to store After a successful SIWS sign-in verification, the server must establish a session so the user does not need to re-authenticate on every request. Session management 用..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 29,
          "excerpt": "钱包 addresses are publicly known. Using them as session IDs would allow anyone who knows a user's address to impersonate their session. Random tokens ensure only the authenticated client can present a valid session."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 21,
          "excerpt": "钱包 disconnection signals the user's intent to end the interaction. The dApp should respect this by invalidating the session, preventing confusion about authentication state."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].content",
          "englishWordCount": 847,
          "excerpt": "# Replay protection 和 nonce registry 设计 Replay attacks are the most critical threat to any signature-based authentication system. In a replay attack, an adversary captures a valid signed message 和 submits it again to the..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].content",
          "englishWordCount": 75,
          "excerpt": "# Checkpoint: Generate an auth audit report Build the final auth audit report that combines all 课程 concepts: - Process an array of authentication attempts 使用 address, nonce, 和 verified status - Track used nonces to detec..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].content",
          "englishWordCount": 567,
          "excerpt": "# Fee markets on Solana: what actually moves inclusion Priority fees on Solana are often explained as a simple slider, but production systems need a more precise model. Inclusion is influenced by contention 用于 compute, 验..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 13,
          "excerpt": "A large CU request 使用 weak price can lose inclusion, while aggressive price on oversized CU can overpay."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].content",
          "englishWordCount": 516,
          "excerpt": "# Compute budget 基础 和 common failure modes Most 交易 failures blamed on \"network issues\" are actually planning errors in compute budget 和 payload sizing. A defensive client treats compute planning as a deterministic prefli..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[2].content",
          "englishWordCount": 449,
          "excerpt": "# Explorer: compute budget planner inputs to plan Explorers are useful only when they expose policy tradeoffs clearly. 用于 a fee 和 compute planner, that means visualizing how input estimates, percentile targets, 和 confirm..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].content",
          "englishWordCount": 12,
          "excerpt": "Implement policy-based priority fee estimation using synthetic sample arrays 和 deterministic warnings."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].content",
          "englishWordCount": 14,
          "excerpt": "Build stable markdown output 用于 a fee strategy summary that users 和 support teams can review quickly."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].content",
          "englishWordCount": 503,
          "excerpt": "# Atomicity concepts 和 why users assume all-or-nothing Users rarely think in 交易 graphs. They think in intents: \"swap my token\" or \"close my position.\" When a workflow spans multiple 交易, user expectation remains all-or-no..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].content",
          "englishWordCount": 488,
          "excerpt": "# Multi-交易 flows: approvals, ATA creation, swaps, refunds A reliable flow simulator must encode where partial execution risk lives. In practice, risk points cluster at boundaries: before value transfer, during value tran..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[2].content",
          "englishWordCount": 453,
          "excerpt": "# Explorer: flow graph steps 和 risk points Flow graph explorers are most valuable when they highlight risk semantics, not just sequence order. A defensive explorer should display each step 使用 dependency context, idempote..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].content",
          "englishWordCount": 512,
          "excerpt": "# What can go wrong between quote 和 execution A swap quote is a prediction, not a guarantee. Between quote generation 和 execution, liquidity changes, competing orders land, 和 network conditions shift. Users often assume ..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[1].content",
          "englishWordCount": 469,
          "excerpt": "# Slippage controls 和 guardrails Slippage settings are a policy surface, not a cosmetic preference. Defensive swap UX defines explicit bounds, context-aware defaults, 和 clear consequences when users attempt risky overrid..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[2].content",
          "englishWordCount": 429,
          "excerpt": "# Explorer: quote freshness timer 和 decision table A quote freshness explorer should make policy behavior obvious under time pressure. Users 和 engineers need to see when a quote transitions from safe to warning to blocke..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[0].content",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic swap risk grading from quote, slippage, impact, hops, 和 liquidity inputs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].content",
          "englishWordCount": 490,
          "excerpt": "# Indexing 101: logs, 账户, 和 交易 parsing Reliable indexers are not just fast parsers. They are consistency systems that decide what to trust, when to trust it, 和 how to recover from changing chain history. On Solana, event..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[1].content",
          "englishWordCount": 449,
          "excerpt": "# Reorgs 和 fork choice: why confirmed is not finalized Confirmation labels are useful but often misunderstood in indexing pipelines. A confirmed event has stronger confidence than processed, but it is not equivalent to f..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[2].content",
          "englishWordCount": 449,
          "excerpt": "# Explorer: ingest to dedupe to confirm to apply A pipeline explorer should explain transformation stages clearly so engineers can inspect where correctness can break. 用于 indexing reliability, the core stages are ingest,..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Real-world RPC failure behavior, endpoint selection strategy, 和 deterministic retry policy modeling."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].content",
          "englishWordCount": 502,
          "excerpt": "# RPC failures in real life: timeouts, 429s, stale nodes Reliable client infrastructure begins 使用 realistic failure assumptions. RPC calls fail 用于 many reasons: transient network timeouts, provider rate limits, stale nod..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].content",
          "englishWordCount": 420,
          "excerpt": "# Multi-endpoint strategies: hedged requests 和 fallbacks Multi-endpoint 设计 is more than adding a backup URL. It is a scheduling problem where each request should be sent to the most suitable endpoint given recent health ..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].content",
          "englishWordCount": 444,
          "excerpt": "# Explorer: retry/backoff simulator Retry 和 backoff policies determine whether clients recover gracefully or amplify outages. A simulator should make schedule behavior explicit so teams can reason about user latency 和 pr..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].content",
          "englishWordCount": 527,
          "excerpt": "# Memory layout: alignment, padding, 和 why Solana 账户 care Rust layout behavior is deterministic inside one compiled binary but can vary when assumptions are implicit. 用于 Solana 账户, this matters because raw bytes are pers..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].content",
          "englishWordCount": 470,
          "excerpt": "# Struct 和 enum layout pitfalls plus Borsh rules Borsh is widely used because it gives deterministic serialization across languages, but teams still get tripped up by how enums, vectors, 和 strings map to bytes. Understan..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[2].content",
          "englishWordCount": 421,
          "excerpt": "# Explorer: layout visualizer 用于 field offsets A layout visualizer turns abstract alignment rules into concrete numbers engineers can review. Instead of debating whether a struct is \"probably fine,\" teams can inspect exa..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic layout analysis, encoding/decoding, safe parsing, 和 compatibility-focused reporting helpers."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].content",
          "englishWordCount": 523,
          "excerpt": "# Error taxonomy: recoverable vs fatal Rust encourages explicit error modeling, but teams still produce weak error contracts when they rely on ad hoc strings or inconsistent wrappers. In Solana 和 Anchor-adjacent systems,..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[1].content",
          "englishWordCount": 501,
          "excerpt": "# Result<T, E> patterns, ? operator, 和 context Result-based control flow is one of Rust's strongest tools 用于 building robust services 和 on-chain-adjacent clients. The key is not merely using Result, but designing error t..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].content",
          "englishWordCount": 445,
          "excerpt": "# Explorer: invariant decision tree An invariant decision tree helps teams reason about guard ordering 和 failure priority. Not every invariant should be checked in arbitrary order. Early checks should prevent expensive w..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement guard helpers, evidence-chain generation, 和 stable audit reporting 用于 reliability 和 incident response."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].content",
          "englishWordCount": 470,
          "excerpt": "# 性能 思维模型: allocations, clones, hashing Rust 性能 work in Solana ecosystems is mostly about data movement discipline. Teams often chase micro-optimizations while ignoring dominant costs such as repeated allocations, unnece..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].content",
          "englishWordCount": 453,
          "excerpt": "# Data structures: Vec, HashMap, BTreeMap tradeoffs Data structure choice is one of the highest leverage 性能 decisions in Rust systems. Vec offers compact contiguous storage 和 predictable iteration speed. HashMap offers a..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].content",
          "englishWordCount": 433,
          "excerpt": "# Explorer: cost model sandbox A cost sandbox lets teams test optimization hypotheses without waiting 用于 full benchmark infrastructure. Provide operation counts, compute weighted costs, 和 inspect which buckets dominate t..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].content",
          "englishWordCount": 485,
          "excerpt": "# Async fundamentals: futures, tasks, channels Rust async systems are built on explicit scheduling rather than implicit thread-per-task models. Futures represent pending work, executors poll futures, 和 channels coordinat..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[1].content",
          "englishWordCount": 430,
          "excerpt": "# Concurrency limits 和 backpressure Backpressure is not optional in high-volume pipelines. Without it, producer speed can overwhelm reducers, retries, or storage sinks. A resilient 设计 sets explicit concurrency caps 和 que..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[2].content",
          "englishWordCount": 450,
          "excerpt": "# Explorer: pipeline graph 和 concurrency Pipeline graphs help teams communicate stage boundaries, concurrency budgets, 和 retry behaviors. A graph that shows ingest, dedupe, retry, 和 snapshot stages 使用 explicit capacities..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement deterministic scheduling, retries, dedupe/reducer stages, 和 report exports 用于 reorg-safe pipeline operations."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].content",
          "englishWordCount": 470,
          "excerpt": "# Macro 思维模型: declarative vs procedural Rust macros come in two broad forms: declarative macros 用于 pattern-based expansion 和 procedural macros 用于 syntax-aware transformation. Anchor relies heavily on macro-driven ergonom..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].content",
          "englishWordCount": 443,
          "excerpt": "# Safety through codegen: constraint checks Constraint codegen converts compact declarations into explicit runtime guards. Typical constraints include signer presence, 账户 ownership, has-one relations, 和 mutability requir..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].content",
          "englishWordCount": 441,
          "excerpt": "# Explorer: constraint builder to generated checks A constraint builder explorer helps engineers see how DSL choices affect generated code 和 runtime safety outcomes. Input one attribute line, observe parsed AST, generate..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Parse DSL constraints, generate checks, run deterministic evaluations, 和 publish stable safety reports."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].content",
          "englishWordCount": 521,
          "excerpt": "# Upgrade authority lifecycle in Anchor programs Anchor makes 指令 development easier, but upgrade safety still depends on disciplined control of program authority. In production Solana systems, most upgrade incidents are ..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[1].content",
          "englishWordCount": 475,
          "excerpt": "# 账户 versioning 和 migration strategy Solana 账户 are long-lived state containers, so program upgrades must respect historical data. In Anchor, adding or changing 账户 fields can be safe, risky, or catastrophic depending on h..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].content",
          "englishWordCount": 431,
          "excerpt": "# Explorer: upgrade risk matrix A useful upgrade explorer should show cause-和-effect between release inputs 和 safety outcomes. If a flag changes, engineers should immediately see how severity 和 readiness changes. This 课时..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].content",
          "englishWordCount": 431,
          "excerpt": "# Rollback strategy 和 incident playbooks Even strong upgrade plans can encounter surprises: incompatible downstream clients, unexpected 账户 edge cases, or release pipeline mistakes. Teams that recover quickly are the ones..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].content",
          "englishWordCount": 13,
          "excerpt": "Produce the final deterministic checkpoint artifact 使用 release tag, readiness flag, 和 migration batch count."
        },
        {
          "path": "courses.solana-reliability.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Implement fault-tolerance building blocks 使用 clear failure classification, retry boundaries, 和 deterministic recovery behavior."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[0].content",
          "englishWordCount": 213,
          "excerpt": "Fault tolerance in Solana systems is not just about catching errors. It is about deciding which failures are safe to retry, which should fail fast, 和 how to preserve user trust while doing both. A 实战 reliability model st..."
        },
        {
          "path": "courses.solana-reliability.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Build resilience mechanisms (circuit breakers, bulkheads, 和 rate controls) that protect core user flows during provider instability."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[0].content",
          "englishWordCount": 180,
          "excerpt": "Resilience patterns are controls that prevent localized failures from becoming system-wide incidents. On Solana integrations, they are especially important because provider health can change quickly under bursty network ..."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].content",
          "englishWordCount": 13,
          "excerpt": "Implement a circuit breaker pattern that opens after consecutive failures 和 closes after a recovery period."
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[0].content",
          "englishWordCount": 150,
          "excerpt": "测试 Solana systems effectively requires layered confidence, not one giant test suite. Unit tests validate pure logic: math, state transitions, 和 invariant checks. They should be fast, deterministic, 和 run on every change...."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Use fuzzing, property-based tests, 和 mutation-style checks to expose edge-case failures before release."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[0].content",
          "englishWordCount": 146,
          "excerpt": "高级 测试 techniques uncover failures that example-based tests rarely find. Fuzzing explores broad random input space to trigger parser edge cases, boundary overflows, 和 unexpected state combinations. It is especially useful..."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Compute units are the hard resource budget that shapes what your Solana program can do in a single 交易. 性能 optimization starts by treating CU usage as a contract, not an afterthought. A reliable optimization loop is: 1) m..."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "设计 memory/storage-efficient 账户 layouts 使用 rent-aware sizing, serialization discipline, 和 safe migration planning."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[0].content",
          "englishWordCount": 91,
          "excerpt": "账户 data optimization is both a cost 和 correctness discipline. Poor layouts increase rent, slow parsing, 和 make migrations fragile. 设计 principles: - Keep hot fields compact 和 easy to parse. - Use fixed-size representation..."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Model token allocation 和 vesting systems 使用 explicit fairness, unlock predictability, 和 deterministic accounting rules."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[0].content",
          "englishWordCount": 89,
          "excerpt": "Token distribution is a 安全 和 credibility decision, not just a spreadsheet exercise. Allocation 和 vesting rules shape long-term trust in the protocol. A strong distribution model answers: - who receives tokens 和 why, - wh..."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[0].content",
          "englishWordCount": 85,
          "excerpt": "Staking 和 治理 systems must balance participation incentives 使用 manipulation resistance. Rewarding lock behavior is useful, but poorly tuned models can over-concentrate influence. Core 设计 questions: 1) How is staking rewar..."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[0].content",
          "englishWordCount": 93,
          "excerpt": "AMM fundamentals are simple in formula but subtle in implementation quality. The invariant math must be deterministic, fee handling explicit, 和 rounding behavior consistent across paths. 用于 constant-product pools, route ..."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Model lending 和 flash-loan flows 使用 collateral safety, utilization-aware pricing, 和 strict repayment invariants."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[0].content",
          "englishWordCount": 81,
          "excerpt": "Lending primitives 和 flash-loan logic are powerful but unforgiving. Safety depends on strict collateral valuation, clear LTV/threshold rules, 和 deterministic repayment checks. A 实战 lending model should define: - collater..."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Build core NFT functionality 使用 standards-compliant metadata, collection verification, 和 deterministic asset-state handling."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[0].content",
          "englishWordCount": 74,
          "excerpt": "NFT architecture on Solana combines token mechanics 使用 metadata 和 collection semantics. A correct implementation requires more than minting a token 使用 supply one. Core components include: - mint/state ownership correctne..."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement 高级 NFT behaviors (soulbound 和 programmable flows) 使用 explicit policy controls 和 safe update semantics."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[0].content",
          "englishWordCount": 67,
          "excerpt": "高级 NFT features introduce policy complexity that must be explicit. Soulbound behavior, programmable restrictions, 和 dynamic metadata updates all expand failure surface. 用于 soulbound models, non-transferability must be en..."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Build CPI fundamentals 使用 strict 账户/signer checks, ownership validation, 和 safe PDA signing boundaries."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[0].content",
          "englishWordCount": 77,
          "excerpt": "跨程序调用 (CPI) is where Solana composability becomes 实战 和 where many 安全 failures appear. The caller controls 账户 lists, so every CPI boundary must be treated as untrusted input. Safe CPI 设计 requires: - explicit 账户 identity 和..."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[0].content",
          "englishWordCount": 86,
          "excerpt": "Multi-program composition introduces sequencing 和 consistency risk. Even when each CPI call is correct in isolation, combined flows can violate business invariants if ordering or rollback assumptions are weak. Robust com..."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand MEV mechanics 和 交易 ordering realities, then model opportunities 和 risks 使用 deterministic safety-aware policies."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[0].content",
          "englishWordCount": 156,
          "excerpt": "Maximal Extractable Value (MEV) on Solana is fundamentally about 交易 ordering under limited blockspace. Whether you are building trading tools, liquidation infrastructure, or user-facing apps, you need a realistic model o..."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[0].content",
          "englishWordCount": 115,
          "excerpt": "高级 交易-ordering strategies require disciplined orchestration, not just faster opportunity scans. Bundle-oriented execution is valuable because it can express dependency sets 和 all-or-nothing intent, but bundle 设计 must inc..."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[0].content",
          "englishWordCount": 126,
          "excerpt": "Solana 部署 is not one command; it is a release system 使用 environment-specific risk. Localnet, devnet, 和 mainnet each serve different validation goals, 和 production quality depends on using them intentionally. A reliable 部..."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Build CI/CD pipelines that enforce build/test/安全 gates, compatibility checks, 和 controlled rollout/rollback evidence."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[0].content",
          "englishWordCount": 111,
          "excerpt": "CI/CD 用于 Solana should enforce release quality, not just automate command execution. A 实战 pipeline includes staged gates: 1) static quality gate (lint/type/安全 checks), 2) deterministic unit/integration tests, 3) build re..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].content",
          "englishWordCount": 131,
          "excerpt": "Cross-chain messaging is a trust-boundary problem before it is a transport problem. In Wormhole-style systems, messages are observed, attested, 和 consumed across different chain environments, each 使用 independent failure ..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement asset-bridging patterns 使用 strict supply/accounting invariants, replay protection, 和 reconciliation workflows."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[0].content",
          "englishWordCount": 113,
          "excerpt": "Token bridging requires strict supply 和 state invariants. Lock-和-mint 和 burn-和-mint models both rely on one central rule: represented supply across chains must remain coherent. Critical controls include: - single-consume..."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand oracle data semantics (price, confidence, staleness) 和 enforce deterministic validation before business logic."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[0].content",
          "englishWordCount": 108,
          "excerpt": "Oracle integration is a risk-control problem, not a data-fetch problem. Price feeds must be evaluated 用于 freshness, confidence, 和 contextual fitness before they drive protocol decisions. A safe oracle validation pipeline..."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "设计 multi-oracle aggregation 和 consensus policies that reduce single-source failure risk while remaining explainable 和 testable."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[0].content",
          "englishWordCount": 103,
          "excerpt": "Multi-oracle aggregation reduces single-point dependency but adds policy complexity. The goal is not to average blindly; it is to produce a robust decision value 使用 clear confidence in adverse conditions. Common strategi..."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Implement 治理 mechanics 使用 explicit proposal lifecycle rules, voting-power logic, 和 deterministic state transitions."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[0].content",
          "englishWordCount": 101,
          "excerpt": "DAO 治理 architecture is a system of enforceable process rules. Proposal creation, voting, 和 execution must be deterministic, auditable, 和 resistant to manipulation. A robust 治理 model defines: 1) proposal lifecycle states ..."
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[0].content",
          "englishWordCount": 103,
          "excerpt": "DAO treasury management is where 治理 intent becomes real financial action. Treasury tooling must therefore combine flexibility 使用 strict policy constraints. Core controls include: - spending limits 和 role-based authority,..."
        },
        {
          "path": "courses.solana-gaming.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "设计 game state 和 turn logic 使用 deterministic transitions, storage efficiency, 和 anti-cheat validation boundaries."
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[0].content",
          "englishWordCount": 127,
          "excerpt": "On-chain game 设计 on Solana is a systems-engineering tradeoff between fairness, responsiveness, 和 cost. The best designs keep critical rules verifiable while minimizing expensive state writes. Core architecture decisions:..."
        },
        {
          "path": "courses.solana-gaming.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement fairness-oriented randomness 和 integrity controls that keep gameplay auditable 和 dispute-resistant."
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[0].content",
          "englishWordCount": 113,
          "excerpt": "Randomness is one of the hardest fairness problems in blockchain games because execution is deterministic. Robust designs avoid naive pseudo-randomness tied directly to manipulable context. 实战 fairness patterns include c..."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand permanent-storage architecture 和 build deterministic linking between Solana state 和 external immutable content."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[0].content",
          "englishWordCount": 116,
          "excerpt": "Permanent storage integration is a data durability contract. On Solana, storing full content on-chain is often impractical, so systems rely on immutable external storage references anchored by on-chain metadata. A robust..."
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[0].content",
          "englishWordCount": 93,
          "excerpt": "Manifests turn many stored assets into one navigable root, but they introduce their own integrity responsibilities. A manifest is only trustworthy if path mapping 和 referenced content IDs are validated consistently. Key ..."
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[0].content",
          "englishWordCount": 101,
          "excerpt": "Solana staking economics is an incentives system connecting delegators, 验证者, 和 network 安全. Good delegation decisions require more than chasing headline APY. Delegators should evaluate: 1) 验证者 性能 consistency, 2) commissio..."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Analyze 验证者-side economics, operational cost pressure, 和 incentive alignment 用于 long-term network health."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[0].content",
          "englishWordCount": 98,
          "excerpt": "验证者 economics balances revenue opportunities against operational costs 和 reliability obligations. Sustainable 验证者 optimize 用于 long-term trust, not short-term extraction. Revenue sources include inflation rewards 和 fee-re..."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Build smart-钱包 fundamentals including multisig 和 social-recovery designs 使用 clear trust 和 failure boundaries."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[0].content",
          "englishWordCount": 107,
          "excerpt": "账户 abstraction on Solana shifts control from a single key to programmable policy. Smart 钱包 can enforce richer authorization logic, but policy complexity must be managed carefully. A robust smart-钱包 设计 defines: 1) authori..."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement programmable validation policies (limits, allowlists, time/risk rules) 使用 deterministic enforcement 和 auditability."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[0].content",
          "englishWordCount": 99,
          "excerpt": "Programmable validation is where smart 钱包 deliver real value, but it is also where subtle policy bugs appear. Typical controls include spending limits, destination allowlists, time windows, 和 risk-score gates. These cont..."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Build strong PDA foundations 使用 deterministic derivation, canonical seed composition, 和 collision-resistant namespace strategy."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[0].content",
          "englishWordCount": 106,
          "excerpt": "程序派生地址 (PDAs) are deterministic authority 和 state anchors on Solana. Their power comes from predictable derivation; their risk comes from inconsistent seed discipline. A strong PDA 设计 standard defines: 1) canonical seed ..."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[0].content",
          "englishWordCount": 97,
          "excerpt": "高级 PDA patterns solve real scaling 和 composability needs but increase 设计 complexity. Nested PDAs, counter-based PDAs, 和 multi-tenant PDA namespaces each require explicit invariants around uniqueness, lifecycle, 和 authori..."
        },
        {
          "path": "courses.solana-economics.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Understand Solana macro token economics (inflation, burn, rewards, fees) 使用 deterministic scenario modeling."
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[0].content",
          "englishWordCount": 109,
          "excerpt": "Solana economics is the interaction of issuance, burn, staking rewards, 和 usage demand. Sustainable protocol decisions require understanding these flows as a system, not isolated metrics. Core mechanisms include: 1) infl..."
        },
        {
          "path": "courses.solana-economics.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Model token flow dynamics 和 sustainability signals using supply categories, unlock events, 和 behavior-driven liquidity effects."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[0].content",
          "englishWordCount": 111,
          "excerpt": "Token flow analysis turns abstract economics into operational insight. The key is to track where tokens are (staked, circulating, locked, treasury, pending unlock) 和 how they move over time. Useful flow metrics include: ..."
        }
      ],
      "totals": {
        "exactEnglishCount": 866,
        "englishLikeCount": 332
      }
    },
    {
      "locale": "ar",
      "exactEnglishMatches": [
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].options[0]",
          "text": "To calculate NFT metadata size"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "It is the user who paid the creation fee forever"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "What does `executable: true` indicate?"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].options[1]",
          "text": "Token balances are program-specific state managed by the token program"
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "This is your active signer public key."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[1]",
          "text": "Convert SOL to lamports using 1_000_000_000 multiplier."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[0]",
          "text": "A client-only simulation mode"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[2].options[1]",
          "text": "Calling one on-chain program from another on-chain program"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].prompt",
          "text": "Why are PDAs useful?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[0].options[0]",
          "text": "They let programs derive deterministic addresses without private keys"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[1].options[1]",
          "text": "The runtime on behalf of the program when invoke_signed seeds match"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].prompt",
          "text": "What happens if you change a seed?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[0]",
          "text": "The PDA stays the same but bump changes"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].options[2]",
          "text": "You derive a different PDA address"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].blocks[1].questions[2].explanation",
          "text": "Seed bytes are part of the hash input, so any change yields a different derived address."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "A compressed NFT ledger entry"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[2].prompt",
          "text": "What authority controls minting?"
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[0]",
          "text": "Parse flags in pairs: --key value."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].hints[2]",
          "text": "Construct JSON object in fixed key order before JSON.stringify."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does Anchor generate automatically from your program definitions?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Automatic PDA funding from devnet faucets"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A JSON interface used by clients/tests/tooling to call your program correctly"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "A private key format used only by on-chain programs"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is a seeds constraint verifying?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "That a token mint has 9 decimals"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].prompt",
          "text": "Why is a PDA considered off-curve?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].options[0]",
          "text": "It is derived to avoid having a corresponding private key"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[0].explanation",
          "text": "Off-curve means no user-held private key exists; programs authorize via seed proofs."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].prompt",
          "text": "What breaks if you change one PDA seed value?"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[1]",
          "text": "Only the bump changes while address stays fixed"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].options[2]",
          "text": "Nothing changes unless RPC endpoint changes"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].blocks[1].questions[1].explanation",
          "text": "PDA derivation is seed-sensitive. Any seed change creates a different address namespace."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].title",
          "text": "Initialize Counter PDA (deterministic)"
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[0]",
          "text": "Use a deterministic hash-like reducer over programId + authorityPubkey + static seed."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[0]",
          "text": "Represent state as a pure JS structure so increment can be deterministic in tests."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].hints[1]",
          "text": "Return a new state object from applyIncrement; avoid mutating the input object in-place."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the main role of optional integration tests?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Validate network execution paths after deterministic logic is proven"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Replace all unit tests"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Avoid asserting exact outputs"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Integration tests add runtime confidence but should not replace deterministic core checks."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do simulation failures happen even before final send succeeds?"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because fee payer is irrelevant"
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[0]",
          "text": "Compose the checkpoint from deterministic helper functions to keep output stable."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Where do SPL token balances actually live?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why keep raw amounts as integer strings in model code?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because decimals are always 9"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[0]",
          "text": "Show pending overlays first, mutate durable balances only after stronger confirmation"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].options[2]",
          "text": "Disable activity feed until finalized"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "Optimistic overlays are useful, but confirmed state must remain authoritative."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].options[2]",
          "text": "Because commitment levels require it by protocol"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Phase-specific metrics enable actionable incident diagnosis."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is ordering by (ts, id) preferred over timestamp-only replay?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Stable ordering prevents environment-dependent state divergence."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should happen when the same event id arrives twice?"
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Idempotency guarantees deterministic behavior under retries."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[0]",
          "text": "Sort by (ts, id) before applying events."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[1]",
          "text": "Deduplicate by event id before snapshot interval checks."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].hints[2]",
          "text": "Build checksum from stable snapshot metadata, not random values."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[0]",
          "text": "Use fixed-scale integers (micro USD) instead of floating point."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].hints[1]",
          "text": "Apply filter -> search -> sort in a deterministic order."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "To reduce CSS size only"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Because rate limits require it"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the main risk of generic one-size-fits-all error banners?"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Users cannot distinguish recovery actions across failure classes"
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "They always break hydration"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Which metric should drive route selection at execution size?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Deterministic outAmount from full route simulation"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Displayed ticker price only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Lowest hop count only"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Route quality is output-at-size, not headline spot labels."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does slippage tolerance directly determine?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "The minOut acceptance bound"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the deterministic minOut formula?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[0].explanation",
          "text": "minOut is a bounded percentage reduction from outAmount."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Why keep per-hop fee breakdowns?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "text": "Per-hop fee attribution makes route behavior auditable."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Minimize hop count always"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Choose first enumerated route"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "Why simulate virtual reserves per candidate route?"
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "text": "Virtual simulation avoids shared-state contamination."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].content",
          "text": "# Implement token/pool model + constant-product quote calc Implement deterministic CPMM quoting: - out = (reserveOut * inAfterFee) / (reserveIn + inAfterFee) - fee = floor(inAmount * feeBps / 10000) - impactBps from spot..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[0].hints[0]",
          "text": "Use inAfterFee = inAmount - floor(inAmount * feeBps / 10000)."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].hints[2]",
          "text": "Keep sorting deterministic to avoid route flicker."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[0]",
          "text": "Use virtual pool copies so fixture reserves are not mutated."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].hints[2]",
          "text": "Return structured errors when pools or route links are invalid."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].prompt",
          "text": "What should happen when quote freshness expires?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].options[2]",
          "text": "Increase slippage automatically without notifying user"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Freshness boundaries should trigger deterministic recomputation."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which failures are not solved by blind retries?"
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].blocks[0].questions[1].explanation",
          "text": "Planner errors require input/route changes, not repetition."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[0]",
          "text": "Keep output key order stable: swapPlan first, swapSummary second."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[1]",
          "text": "Path should be deterministic symbols along route hops."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].hints[2]",
          "text": "Include fixtureHash + modelVersion under determinism metadata."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because owner checks improve rendering speed"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Because owner checks replace signer checks"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Only that an amount field exists"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].prompt",
          "text": "What is the purpose of trace hashing in an audit workflow?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[0].options[1]",
          "text": "To replace structured test assertions"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].prompt",
          "text": "Which sequence represents a valid evidence chain?"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "Reproduce -> trace -> impact -> fix -> verify"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].blocks[1].questions[1].options[1]",
          "text": "Fix -> reproduce -> trace -> release"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Accepting any PDA-like prefix"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "Trusting client-provided bump values"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[0].explanation",
          "text": "Deterministic re-derivation closes spoofable PDA substitution paths."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Because most exploitable bugs only appear under malformed or adversarial input"
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Because traces are optional without them"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[0]",
          "text": "Compute drained lamports from recipient before/after."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[1]",
          "text": "Include deterministic field ordering in the JSON output."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].hints[2]",
          "text": "The explanation should mention missing signer/owner validation."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].hints[2]",
          "text": "Keep output key order stable."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[1]",
          "text": "Use fixedBlockedExploit to set blocked status."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].hints[2]",
          "text": "Return error code only when blocked is true."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].options[1]",
          "text": "They are interchangeable labels"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[0].explanation",
          "text": "Good reports separate damage potential from exploit feasibility."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].blocks[0].questions[1].prompt",
          "text": "Which recommendation is most actionable?"
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[0]",
          "text": "Return stable, minimal checkpoint metadata."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].hints[2]",
          "text": "Preserve scenarioIds order as provided."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why generate an offline deterministic launch pack before devnet/mainnet actions?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should supply checks use integer math instead of floating-point UI values?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "To avoid rounding drift in launch invariants"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Because decimals are always zero"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What is the primary role of freeze authority?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[0]",
          "text": "It can materially change effective fee behavior across transfer sizes"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[0].options[2]",
          "text": "It is ignored once mint is initialized"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is a core risk of permanent delegate configuration?"
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].hints[2]",
          "text": "Keep output key order stable so checkpoint tests are reproducible."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].hints[1]",
          "text": "Append extension steps in deterministic order so plan labels are stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[0]",
          "text": "Transfer fee formula: fee = min(maxFee, floor(amount * feeBps / 10000))."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].hints[2]",
          "text": "Fail when distributed amount exceeds initial supply."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why is parameter closure required before execution?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Single-source configuration prevents mismatched launch behavior."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What is the purpose of hard stop launch criteria?"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "To halt execution when invariants or authority assumptions fail"
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Hard stop rules prevent progressing through unsafe operational states."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[0]",
          "text": "Keep checkpoint JSON key ordering fixed so output is stable."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].hints[2]",
          "text": "Include determinism metadata (fixtures hash + encoding version) in the final object."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[0]",
          "text": "Add validation before returning the formatted string."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].hints[1]",
          "text": "instructionCount should be treated as a number but returned as text."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].content",
          "text": "# Write a Counter Program Bankrun Test Implement a helper that returns the expected counter value after a sequence of increment operations. This mirrors a deterministic assertion you would use in a Bankrun test. Return t..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[0]",
          "text": "Use Array.reduce to sum increments."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[2].hints[2]",
          "text": "Convert final number to string before returning."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the primary source of event data on Solana?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Explicit event topics like EVM"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is idempotency important in indexing?"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "To prevent duplicate events during replays or forks"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "To improve RPC response times"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].options[0]",
          "text": "As little-endian u64, then divided by 10^decimals"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[1].note",
          "text": "Inner CPI call at depth 2"
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Success bubbles up from inner to outer"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[0]",
          "text": "Parse log entries to identify event types"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].hints[1]",
          "text": "Extract fields using regex patterns"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It provides stable ordering during concurrent writes"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Cursor-based pagination handles concurrent writes without missing or duplicating entries."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What enables indexer recovery after crashes?"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Periodic checkpointing of last processed position"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Re-indexing from genesis on every start"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Caching all data in memory"
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Checkpoints allow indexers to resume from the last known good position."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].hints[3]",
          "text": "Include metadata like timestamps"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the purpose of SPL Memo in payments?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What should never be included in a memo?"
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Memos are public on-chain; sensitive data should be hashed or kept off-chain."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[0]",
          "text": "Use base58 alphabet to validate the recipient address format."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].hints[2]",
          "text": "Generate an idempotency key if not provided in the input."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].hints[2]",
          "text": "Key order matters: SOL transfer needs [from, to], SPL transfer needs [source, mint, dest, owner]."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Different key orders produce different signatures"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Canonicalization ensures consistent serialization so signatures match regardless of object construction order."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Initial state after intent creation"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Payment complete, generate receipt"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[0]",
          "text": "HMAC-SHA256: H(key, message) = SHA256((key XOR outer_pad) || SHA256((key XOR inner_pad) || message))"
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[1]",
          "text": "Use constant-time comparison to prevent timing attacks on signature verification."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].hints[2]",
          "text": "Verify the timestamp is recent (within 5 minutes) to prevent replay attacks."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a Merkle root commit to?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The tree depth only"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[0]",
          "text": "Start by validating the leaf index is within bounds."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[1]",
          "text": "At each level, find the sibling node (left or right of current)."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[3]",
          "text": "Traverse up to the root, collecting all updated node hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].hints[4]",
          "text": "Use deterministic ordering: left hash comes before right hash."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].prompt",
          "text": "What determines concatenation order during verification?"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[0]",
          "text": "The leaf index bits at each level"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[1]",
          "text": "The size of the sibling hashes"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].options[2]",
          "text": "The tree root hash"
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[0].explanation",
          "text": "Each bit of the leaf index determines if the current hash goes left or right in the concatenation."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].blocks[0].questions[1].explanation",
          "text": "log2(1024) = 10, so proofs contain 10 sibling hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[0]",
          "text": "To generate a proof, collect the sibling hash at each level from leaf to root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[1]",
          "text": "The sibling is at index+1 if current is left, index-1 if current is right."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[3]",
          "text": "Use the same ordering (left || right) when combining hashes."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].hints[4]",
          "text": "The proof is valid if the recomputed root matches the stored root."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "Why do old proofs fail after tree updates?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "The root changes when leaves are added/modified"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "The proof format changes"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].options[2]",
          "text": "The leaf hashes are encrypted"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Adding leaves changes parent hashes up to the root, invalidating previous proofs."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "How can metadata attacks be prevented?"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[0]",
          "text": "Hash verification against leaf commitments"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Using shorter metadata URIs"
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Verifying metadata hashes ensures the off-chain data matches the on-chain commitment."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[0]",
          "text": "Validate the mint request has all required fields (leafIndex, nftId, owner)."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].hints[2]",
          "text": "Insert the leaf by computing hashes up to the root, collecting sibling hashes as proof."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What determines voting power in most DAOs?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Token balance at snapshot block"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Voting power is typically proportional to token holdings at a specific snapshot time."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Anyone can trigger execution"
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].content",
          "text": "# Challenge: Implement quorum/voting state machine Build a deterministic voting system: - Calculate vote weights from token balances - Check quorum requirements - Determine pass/fail based on thresholds - Handle abstenti..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[1]",
          "text": "Check if totalVoteWeight >= quorumThreshold to determine quorumMet."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[3].hints[2]",
          "text": "Calculate support percentage as forWeight / (forWeight + againstWeight) when there are non-abstain votes."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does 2-of-3 multisig mean?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[0].options[0]",
          "text": "2 signatures required from 3 possible signers"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why track approvals on-chain?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[1]",
          "text": "Process actions in order - each action updates the signer's status."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[2]",
          "text": "Track the cumulative approved weight to compare against threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[3]",
          "text": "A proposal is 'approved' when approvedWeight >= threshold."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].hints[4]",
          "text": "A proposal is 'rejected' when no pending signers remain but threshold is not met."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].prompt",
          "text": "What is a replay attack in multisig systems?"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Sending duplicate approval requests"
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].hints[0]",
          "text": "First validate the proposal status is 'approved'."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The network automatically extends the limit"
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].hints[2]",
          "text": "Each byte of data adds 10 compute units."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].blocks[0].steps[2].note",
          "text": "Lower fees, higher throughput"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[0]",
          "text": "Sort fields by size (largest first) to minimize padding gaps."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[1]",
          "text": "Consider if u64 fields can be reduced to u32 based on maxValue."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[2]",
          "text": "Boolean flags can be packed into a single byte as bit flags."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].hints[3]",
          "text": "Calculate bytes saved as originalSize - optimizedSize."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of setComputeUnitPrice?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Enable additional program features"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why request specific compute unit limits?"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "Optimizing without profiling or evidence of need"
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "Premature optimization wastes effort on theoretical rather than measured bottlenecks."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[0]",
          "text": "Compute savings by subtracting 'after' from 'before' metrics."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].hints[1]",
          "text": "Use approximate conversion: 1 SOL = $20, 1 SOL = 1,000,000,000 lamports."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why must native SOL be wrapped before swapping?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Native SOL cannot be transferred on Solana"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Solana automatically creates the ATA"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "The tokens are sent to the system program"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is 50 basis points of slippage on a 1,000,000 output?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why should minOutAmount use BigInt instead of floating point?"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Floating point introduces rounding errors in token amounts"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "BigInt is faster than floating point"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Single-hop direct route"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Total execution cost includes fees + impact"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[0]",
          "text": "Use BigInt arithmetic to avoid floating point errors when computing minOutAmount."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[1]",
          "text": "Slippage in basis points: minOut = outAmount - (outAmount * slippageBps / 10000)."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].hints[3]",
          "text": "The priceImpactPct comes directly from the quote response."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].hints[0]",
          "text": "Define a TRANSITIONS map: each key is a state, each value maps event names to next states."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "They reduce the number of required signatures"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Retryable — get fresh blockhash"
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[0]",
          "text": "Use BigInt to sum fee amounts across all route legs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[1]",
          "text": "Effective price = outAmount / inAmount, formatted to 9 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What is the main advantage of CLMMs over constant product AMMs?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Capital efficiency — LPs concentrate liquidity where trades happen"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "CLMMs allow LPs to allocate capital to specific price ranges, dramatically improving capital efficiency compared to spreading liquidity across all prices."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs use ticks to discretize the price space?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "To reduce the number of tokens in the pool"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why do CLMMs store sqrtPrice instead of price directly?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "It simplifies the AMM math — token amounts become linear in sqrtPrice"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "It uses less storage space on-chain"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Price within range, position is active"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "All SOL was sold as price rose through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Position reactivates when price returns to range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "All USDC was sold as price fell through the range"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[0]",
          "text": "Price at a tick index = 1.0001^tickIndex. Use Math.pow(1.0001, tick)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[1]",
          "text": "Reverse conversion: tick = round(ln(price) / ln(1.0001))."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[2]",
          "text": "sqrtPriceX64 = BigInt(round(sqrt(price) * 2^64)) — Solana CLMM uses Q64.64 fixed-point."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].hints[3]",
          "text": "Tick spacing alignment: floor(tick / spacing) * spacing."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[0]",
          "text": "Convert ticks to prices: lowerPrice = 1.0001^lowerTick, upperPrice = 1.0001^upperTick."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[2]",
          "text": "Fees only accrue when the position is in range. fee = floor(volumePerPeriod * feeRate)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[3]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimal places."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].hints[4]",
          "text": "Current status is based on the last price in the path relative to the range."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the main tradeoff of using a tight price range?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Lower fees but less impermanent loss"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "More tokens required to open the position"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When should an LP consider a full-range (all ticks) position?"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "JavaScript Number cannot safely represent 128-bit integers"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "text": "sqrtPriceX64 is a u128 value that can exceed JavaScript's Number.MAX_SAFE_INTEGER (2^53 - 1). BigInt provides arbitrary precision integer arithmetic."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "They are rejected by the program"
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "text": "Floor division rounds toward negative infinity: floor(-100/64) = -2, so -100 aligns to -2 * 64 = -128. This is correct CLMM behavior."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[1]",
          "text": "Status is 'in-range' if lowerPrice <= currentPrice <= upperPrice."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[3]",
          "text": "IL formula: lpValue = sqrt(priceRatio) + sqrt(1/priceRatio); compare to holdValue = 2*sqrt(priceRatio)."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].hints[4]",
          "text": "APR = (totalFees * annualizedMultiplier / liquidity) * 100, formatted to 4 decimals."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What does a utilization ratio of 80% mean?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "80% of supplied assets are currently borrowed"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "80% of borrowers have been liquidated"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "The pool has 80% of its maximum capacity"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Utilization = totalBorrowed / totalSupply. At 80%, four-fifths of all deposited assets are currently lent out to borrowers."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does the reserve factor affect supplier yield?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "It reduces supplier yield by skimming a percentage of borrow interest"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It increases supplier yield by adding protocol subsidies"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "It has no effect on supplier yield"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "The reserve factor takes a cut of borrow interest before distributing the rest to suppliers, reducing their effective APY."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "What happens to borrow rates when utilization exceeds the kink?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "They increase steeply according to slope2"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "They remain constant at the kink rate"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "They decrease to attract more borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is the supply rate always lower than the borrow rate?"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The protocol subsidizes borrowers"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Only 20% buffer remaining — consider adding collateral"
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[0]",
          "text": "Utilization = totalBorrowed / totalSupply. Handle the zero-supply edge case."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[1]",
          "text": "Below kink: borrowRate = baseRate + (utilization/kink) * slope1."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[2]",
          "text": "Above kink: borrowRate = baseRate + slope1 + ((util - kink)/(1 - kink)) * slope2."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].hints[3]",
          "text": "Supply rate = borrowRate * utilization * (1 - reserveFactor)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[1]",
          "text": "Effective threshold = weighted average of liquidationThreshold by collateral value."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[2]",
          "text": "Health factor = (collateralValue * effectiveThreshold) / borrowValue."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].hints[3]",
          "text": "Max additional borrow = max(0, collateralValue * threshold - currentBorrow)."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What is the purpose of the liquidation bonus?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "It incentivizes liquidators to repay debt by offering collateral at a discount"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "When does bad debt occur in a lending protocol?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "When collateral value is insufficient to cover outstanding debt after liquidation"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "When the reserve factor is set too high"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "When utilization drops below the kink"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[0]",
          "text": "To be conservative — using (price - confidence) prevents over-valuing collateral during uncertainty"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].options[1]",
          "text": "Confidence intervals make prices more accurate"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].prompt",
          "text": "What should a protocol do when all oracle feeds are stale?"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[1]",
          "text": "Use the last known price regardless of age"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].options[2]",
          "text": "Estimate the price from on-chain DEX data"
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[2]",
          "text": "Track the worst health factor across all scenarios."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].hints[3]",
          "text": "Count how many scenarios result in isLiquidatable: true."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do perpetual futures protocols use a mark price instead of the last-traded price?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Mark price smooths out manipulation by incorporating oracle data, preventing artificial liquidations"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Mark price is cheaper to compute on-chain"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Last-traded price is not available on Solana"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Mark price incorporates the oracle price as a stability anchor. Using last-traded price alone would allow a single large trade to trigger cascading liquidations through price manipulation."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "Weighted average: (8 * 20 + 2 * 30) / 10 = (160 + 60) / 10 = $22.00. The entry price shifts toward the new fill price proportional to the additional size."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "When the perpetual mark price is above the oracle (spot) price, who pays funding?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Longs pay shorts — the positive premium makes long positions expensive to hold"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Both sides pay the protocol a fee"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "A 10 SOL-PERP position at $25 entry faces a 0.01% funding rate. What is the per-period payment?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "text": "Funding payment = size * entryPrice * rate = 10 * 25 * 0.0001 = $0.025 per funding interval."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Position snapshot at current mark price"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Long PnL = size * (mark - entry)"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "Positive rate: longs pay funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "True return includes funding drag"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[0]",
          "text": "Long PnL = size * (markPrice - entryPrice). Short PnL = size * (entryPrice - markPrice)."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[1]",
          "text": "Notional value = size * markPrice — represents the total position value."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].hints[2]",
          "text": "ROE (return on equity) = unrealizedPnL / margin * 100."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[0]",
          "text": "Funding payment per period = size * entryPrice * fundingRate."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[1]",
          "text": "Longs pay when rate is positive (totalFunding -= payment). Shorts receive."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[2]",
          "text": "Average funding rate = sum(rates) / count."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].hints[3]",
          "text": "Net margin impact = (totalFunding / margin) * 100, as a percentage."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is the maintenance margin rate set above zero?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].prompt",
          "text": "What causes a cascading liquidation spiral?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[0]",
          "text": "Forced position closes push the price further, triggering more liquidations in a feedback loop"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Too many traders opening positions at the same time"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Oracle prices updating too slowly"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "text": "When liquidation engines close positions by selling into the market, the selling pressure moves the price further against remaining positions, triggering their liquidations too — a self-reinforcing feedback loop."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why should position size always be stored as a positive number?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Positive numbers use less storage space"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "A long position has a positive funding rate of 0.01%. What happens to the trader's balance?"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The balance decreases — longs pay when the funding rate is positive"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The balance increases — longs receive positive funding"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Nothing — funding only affects shorts"
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Positive funding rate means the perp is trading above spot. Longs pay shorts to discourage the long-heavy imbalance. The long trader's effective margin decreases by the funding payment amount."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[0]",
          "text": "Effective margin = initial margin + unrealized PnL + funding payments."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[1]",
          "text": "Margin ratio = effectiveMargin / notionalValue."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[3]",
          "text": "Generate alerts based on margin ratio vs maintenance margin rate thresholds."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].hints[4]",
          "text": "Sort alerts by severity: CRITICAL > WARNING > INFO."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How is the priority fee calculated in lamports?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "The CU price is denominated in micro-lamports per CU. Dividing by 1,000,000 converts micro-lamports to lamports. The ceiling function ensures rounding up to the nearest lamport."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why is setting the CU limit to exactly the simulated value risky?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "The runtime does not accept exact values"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Simulation always underreports CU usage by 50%"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Low compute = minimal priority fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Higher compute increases priority cost proportionally"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].blocks[0].steps[2].note",
          "text": "High CU + high priority = significant fee"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[1]",
          "text": "Cap compute unit limit at 1,400,000 (Solana max)."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[2]",
          "text": "Priority fee = ceil(computeUnitLimit * computeUnitPrice / 1_000_000) in lamports."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].hints[3]",
          "text": "Total fee = base fee (5000 lamports) + priority fee."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].hints[3]",
          "text": "Recommend 'legacy' if fits without LUT, 'use-existing-lut' if LUT helps enough, 'create-new-lut' if still too large."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[0]",
          "text": "When the blockhash has expired or pool state has changed"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Whenever any error occurs"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Only when the user manually clicks retry"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add random jitter to retry delays?"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To make the delay shorter on average"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Jitter is required by the Solana protocol"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "text": "Without jitter, all clients using the same backoff formula would retry simultaneously, creating thundering herd problems on the RPC infrastructure."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Slippage exceeded -> actionable message"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Balance error -> show exact shortfall"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[1]",
          "text": "Fee estimates: low = 100 microlamports/CU, medium = 1000, high = 10000."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[2]",
          "text": "Retry policy: 3 retries, 500ms base delay, 2x backoff, always refresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].hints[3]",
          "text": "Use the same CU calculation: ceil(totalCU * 1.1) capped at 1,400,000."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Foreground services maintaining a session channel"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Deep links passed between applications"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Shared local storage between apps"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "iOS suspends app execution on background transitions, preventing persistent channels"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "iOS uses a different blockchain protocol"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "text": "iOS does not allow arbitrary background processes or persistent inter-app communication. When the user switches apps, the dApp's execution context is suspended."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Detect available connection methods (MWA, deep links, QR)"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "text": "Capability detection ensures you only present connection methods that are actually available on the user's device."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[1].note",
          "text": "Request sent via MWA session or deep link"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].blocks[0].steps[3].note",
          "text": "User decision - timing is unpredictable"
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[3]",
          "text": "Generate a requestId from type + payload prefix if not provided."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[0]",
          "text": "Process actions sequentially: each action modifies the session state."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].hints[3]",
          "text": "Expire check clears session if current time >= expiresAt."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "As raw lamports or smallest unit values"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Raw simulation logs from the RPC response"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].title",
          "text": "Retry State Machine Flow"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "User action triggers request construction"
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[0]",
          "text": "Count requests by status: 'signed' = success, 'rejected'/'timeout'/'error' = failure."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].hints[2]",
          "text": "Session duration = sessionEnd - sessionStart in seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "solana:<recipient> (single colon, no slashes)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "solana://<recipient> (double slashes like HTTP)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "pay:<recipient> (custom pay scheme)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "When the amount exceeds 100 SOL"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How does the reference parameter enable payment tracking?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "It creates a webhook that notifies the merchant"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What amount value represents 2.5 USDC in a Solana Pay URL?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "amount=2.5 (human-readable decimal)"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "Native SOL transfer — no spl-token parameter"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[0]",
          "text": "Solana Pay URL format: solana:<recipient>?amount=<amount>&spl-token=<mint>&reference=<ref>&label=<label>&message=<msg>"
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[1]",
          "text": "Validate recipient: must be 32-44 characters of valid base58."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].hints[2]",
          "text": "Amount must be a positive finite number."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[0]",
          "text": "Track state transitions: pending -> found -> confirmed -> finalized."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[1]",
          "text": "The 'found' event sets the signature. 'confirmation' increments the counter."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[2]",
          "text": "Timeout check expires the reference if still pending after expiryTimeout seconds."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].hints[3]",
          "text": "Record each state change in the history array."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Confirmed is never sufficient — always use finalized"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What should happen when the payment request expires?"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Silently restart the polling loop"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Redirect the customer to a different payment method"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Exponential backoff recovers from transient failures"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Never auto-complete mismatched payments"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Track processed references to prevent double fulfillment"
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[0]",
          "text": "Generate receiptId from the last 8 chars of reference + timestamp."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[1]",
          "text": "Reconstruct the Solana Pay URL from payment data."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].hints[2]",
          "text": "Currency is 'SPL' if splToken is present, otherwise 'SOL'."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "What should happen when auto-connect fails silently on page load?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Show the connect button without an error message"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Display an error toast telling the user to reconnect"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Auto-connect is a background optimization. If it fails, the user never initiated the action, so showing an error would be confusing. Simply display the default connect button."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why should you show skeleton UI during the connecting phase?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "It makes the page load faster"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "How do you reliably detect which Solana cluster an RPC endpoint is connected to?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What must happen to cached data when the network changes?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Only token balances need to be refreshed"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].options[2]",
          "text": "Cached data can be retained since addresses are the same across clusters"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].blocks[0].steps[0].note",
          "text": "User clicks Connect, show loading state"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[0]",
          "text": "Define a TRANSITIONS map: each state maps event types to next states."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].hints[2]",
          "text": "Error state stores the error message. Disconnected clears all session data."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[2]",
          "text": "DISCONNECT invalidates all non-'global' entries."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].hints[3]",
          "text": "Track invalidation counts per event in the event log."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must cache keys include the network cluster?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "The Solana RPC protocol requires cluster identification"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "What does the stale-while-revalidate pattern do when a cache entry is past its TTL?"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "Blocks until fresh data is fetched from the RPC"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[0].note",
          "text": "Primary endpoint responding normally"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[1].note",
          "text": "Latency spike detected, slot behind tip"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Automatic failover to healthy secondary"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Primary recovered, restoring as default"
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[1]",
          "text": "Average connect time = total durationMs from CONNECTED events / count."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[2]",
          "text": "Cache hit rate = hits / (hits + misses) * 100."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].hints[3]",
          "text": "RPC health = healthy checks / total checks * 100."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "signMessage does not produce valid Ed25519 signatures"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "How does SIWS prevent replay attacks?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "By requiring a unique, server-generated nonce that is consumed after verification"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].prompt",
          "text": "Why must nonces be generated server-side rather than client-side?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[0]",
          "text": "Client-generated nonces allow attackers to reuse previously valid nonce-signature pairs"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Client-side random number generators are too slow"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].prompt",
          "text": "What format must the domain field use?"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].options[0]",
          "text": "Plain domain name without protocol prefix (e.g., example.com)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[0]",
          "text": "Domain should not include protocol (https://). Strip or reject it."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[2]",
          "text": "Address must be 32-44 characters (Solana base58 public key)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].hints[3]",
          "text": "If no statement is provided, default to 'Sign in to <domain>'."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[1]",
          "text": "issuedAt must be <= currentTime (not in the future)."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].hints[2]",
          "text": "expirationTime (if present) must be > currentTime."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "The dApp should invalidate the server-side session (treat it as logout)"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[2].note",
          "text": "Atomic SET NX ensures only one request can consume the nonce"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].blocks[0].steps[3].note",
          "text": "Replay blocked: nonce was already consumed"
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[0]",
          "text": "Track used nonces in a map. If a nonce was already used, it's a replay attempt."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].hints[2]",
          "text": "Use an address set to count unique addresses."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "What does a wide p90 vs p50 spread usually indicate?"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[1].options[0]",
          "text": "A volatile fee regime where a guard premium may be needed"
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "Floor protects small estimates."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Large payload triggers heap recommendation."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[0].content",
          "text": "Implement a deterministic compute budget planner. No RPC calls; operate only on provided input data."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[0]",
          "text": "Use percentile targeting from sorted synthetic fee samples."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].hints[1]",
          "text": "Apply volatility guard if p90 vs p50 spread exceeds policy threshold."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[2].hints[0]",
          "text": "Map risk score bands to processed/confirmed/finalized UX levels."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].hints[1]",
          "text": "Avoid timestamps or random IDs in output."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[4].hints[1]",
          "text": "Checkpoint report should avoid nondeterministic fields."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why do users still expect atomic behavior in multi-tx flows?"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "Because protocols always guarantee it"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].title",
          "text": "Flow Graph Risk Walkthrough"
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "No compensation path after swap failure."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Still verify idempotency on each step."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[0].hints[1]",
          "text": "Emit explicit edges from dependency relationships."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[1].hints[1]",
          "text": "Flag non-idempotent steps because retries can break all-or-nothing guarantees."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].content",
          "text": "Encode deterministic failure handling metadata, including compensation state."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[2].hints[0]",
          "text": "Generate deterministic idempotency keys from stable inputs."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[3].hints[0]",
          "text": "No real Jito calls. Build deterministic data structures only."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].content",
          "text": "Generate a stable markdown flow safety report checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[0]",
          "text": "Render a stable markdown report as the final checkpoint artifact."
        },
        {
          "path": "courses.bundles-atomicity.modules[1].lessons[4].hints[1]",
          "text": "Keep the PASS/FAIL status deterministic from issue count."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Slippage is user tolerance; impact is market footprint"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They are identical metrics"
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Slippage is a user-configured bound, while impact reflects route liquidity response to trade size."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[1].hints[0]",
          "text": "Clamp recommended BPS to policy bounds."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[2].hints[0]",
          "text": "Teach difference: impact is market footprint, slippage is user tolerance."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[3].hints[0]",
          "text": "Map risk grades to deterministic banner copy."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[4].hints[1]",
          "text": "Do not include timestamps or random IDs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "It reduces RPC cost directly"
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[0].hints[1]",
          "text": "Sort by key so output is deterministic across runs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[1].hints[0]",
          "text": "Apply only confirmed-depth events to state."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[0]",
          "text": "Integrity checks must fail on negative balances."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[1].lessons[3].hints[1]",
          "text": "Finalized keys must always be a subset of applied keys."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].title",
          "text": "RPC failures in real life: timeouts, 429s, stale nodes"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why is slot lag important in endpoint scoring?"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Fast responses can still be wrong if the node is stale"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Slot lag is equivalent to timeout"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Latency alone cannot guarantee freshness of chain state."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].blocks[0].steps[1].note",
          "text": "Fast but less reliable under pressure."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].title",
          "text": "Explorer: retry/backoff simulator"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].title",
          "text": "RPC Multi-Provider Client Project Journey"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[0].hints[0]",
          "text": "Build a deterministic retry schedule including the first attempt."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[1].hints[1]",
          "text": "Tie-break deterministically by endpoint ID."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[2].hints[1]",
          "text": "Use tighter TTL when node lag grows."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].title",
          "text": "Checkpoint: RPC health report export"
        },
        {
          "path": "courses.rpc-reliability-latency.modules[1].lessons[4].hints[1]",
          "text": "Ensure field order is stable in JSON output."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Alignment inserts padding bytes"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "RPC forces 8-byte packets"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "u64 alignment usually forces padding after smaller fields."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].blocks[0].steps[0].note",
          "text": "u32 length + UTF-8 bytes + u8 field"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[0].hints[1]",
          "text": "Struct total size should be aligned to max field alignment."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].title",
          "text": "Challenge: implement borshEncode/borshDecode helpers"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[1].hints[0]",
          "text": "Borsh strings are length-prefixed little-endian u32 + UTF-8 bytes."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].title",
          "text": "Challenge: zero-copy vs Borsh tradeoff model"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[0]",
          "text": "Model tradeoffs deterministically: read speed vs schema flexibility."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[2].hints[1]",
          "text": "Recommendation should be pure function of inputs."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[3].hints[0]",
          "text": "Validate byte length before field parsing."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].title",
          "text": "Checkpoint: stable layout report"
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should export stable JSON + markdown."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].title",
          "text": "Error taxonomy: recoverable vs fatal"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why are typed error codes preferred over free-form strings?"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable machine-readable semantics"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "They reduce compile time"
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].title",
          "text": "Explorer: invariant decision tree"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].title",
          "text": "Invariant Guard Library Project Journey"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].title",
          "text": "Challenge: implement InvariantError + ensure helpers"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[0].hints[0]",
          "text": "Return typed error payloads, not raw strings."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[1].title",
          "text": "Challenge: implement deterministic EvidenceChain"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].title",
          "text": "Challenge: deterministic invariant case runner"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[2].hints[0]",
          "text": "Property-ish deterministic tests can still run as fixed case sets."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].title",
          "text": "Challenge: implement formatReport() stable markdown"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[3].content",
          "text": "Format a deterministic markdown evidence report."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].title",
          "text": "Checkpoint: invariant audit report"
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].content",
          "text": "Export deterministic invariant audit checkpoint artifacts."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint should capture deterministic summary fields only."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].lessons[4].hints[1]",
          "text": "No wall-clock timestamps in exported artifact."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].prompt",
          "text": "Why use deterministic cost models before microbenchmarks?"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "They provide stable regression signals in CI"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].options[1]",
          "text": "They replace all profiling"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "text": "Deterministic models make relative regressions easy to catch early."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].title",
          "text": "Data structures: Vec, HashMap, BTreeMap tradeoffs"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].title",
          "text": "Explorer: cost model sandbox"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].title",
          "text": "Compute Budget Profiler (Sim)"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].title",
          "text": "Challenge: implement CostModel::estimate()"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[0].content",
          "text": "Estimate deterministic operation costs from fixed weighting rules."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].title",
          "text": "Challenge: optimize function metrics"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[0]",
          "text": "Treat optimization as deterministic metric diffs, not runtime benchmarking."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[1].hints[1]",
          "text": "Clamp reduced metrics at zero."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].title",
          "text": "Challenge: model serialization overhead"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[0]",
          "text": "Show why repeated encode/decode loops are expensive."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[2].hints[1]",
          "text": "Keep the model deterministic by counting bytes instead of timing."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].content",
          "text": "Generate stable optimization suggestions from deterministic metrics."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[0]",
          "text": "Output suggestions as a stable, sorted list."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[3].hints[1]",
          "text": "Use threshold-based recommendations to avoid noisy advice."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].title",
          "text": "Checkpoint: stable perf report"
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[1].lessons[4].hints[1]",
          "text": "Use deterministic percentage rounding."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].title",
          "text": "Async fundamentals: futures, tasks, channels"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].title",
          "text": "Reorg-safe Async Pipeline Project Journey"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].title",
          "text": "Challenge: implement Pipeline::run()"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[0].hints[1]",
          "text": "No real timers; simulate progression by decrementing remaining ticks."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[1].title",
          "text": "Challenge: implement RetryPolicy schedule"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].title",
          "text": "Challenge: idempotency key dedupe"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].content",
          "text": "Deduplicate replay events by deterministic idempotency keys."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[2].hints[0]",
          "text": "Use idempotency keys to collapse duplicate replay events."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[3].content",
          "text": "Build deterministic snapshot state from simulated event streams."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].title",
          "text": "Checkpoint: pipeline run report"
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].lessons[4].hints[0]",
          "text": "Checkpoint output should mirror deterministic pipeline run artifacts."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "It verifies expansion matches policy intent"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].title",
          "text": "Safety through codegen: constraint checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].title",
          "text": "Explorer: constraint builder to generated checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].content",
          "text": "Parse mini-DSL constraints into deterministic AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[0].hints[0]",
          "text": "Parse mini DSL lines into typed AST nodes."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].content",
          "text": "Generate stable pseudo-code from parsed constraint AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[0]",
          "text": "Generate stable pseudo-code output from AST."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[1].hints[1]",
          "text": "One deterministic line per constraint node."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].title",
          "text": "Challenge: deterministic golden-file checks"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].content",
          "text": "Compare generated check output against deterministic golden strings."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[0]",
          "text": "Golden tests compare generated output strings exactly."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[2].hints[1]",
          "text": "Keep check output deterministic to make golden tests meaningful."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].content",
          "text": "Execute generated constraints on deterministic sample input."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[3].hints[1]",
          "text": "Return deterministic failure reasons."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].title",
          "text": "Checkpoint: generated safety report"
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].content",
          "text": "Export deterministic markdown safety report from generated checks."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].lessons[4].hints[0]",
          "text": "Render a deterministic markdown report from generated check results."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].title",
          "text": "Upgrade authority lifecycle in Anchor programs"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[0]",
          "text": "Compare approved build hash to expected programdata hash policy input"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[0].options[2]",
          "text": "Rely on signer memory without written report"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].prompt",
          "text": "Why is release communication part of upgrade safety?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[1]",
          "text": "Because Anchor automatically writes support tickets"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].blocks[0].questions[1].options[2]",
          "text": "Because all upgrades are backward compatible"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].title",
          "text": "Explorer: upgrade risk matrix"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].title",
          "text": "Challenge: implement migration step planner"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[3].hints[1]",
          "text": "requiresMigration should be true only when toVersion > fromVersion."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].title",
          "text": "Challenge: implement upgrade safety gate checks"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[1]",
          "text": "Return issueCount plus ordered issue code array."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[0].hints[2]",
          "text": "Keep order stable to make report diffs deterministic."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].prompt",
          "text": "What should happen first when rollback trigger thresholds are hit?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[1]",
          "text": "Continue migration batches to avoid confusion"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].options[2]",
          "text": "Delete all historical reports"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "text": "Trigger conditions should map to immediate deterministic response actions."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].prompt",
          "text": "Why add deterministic fixtures after an incident?"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "text": "To prove policy changes prevent the same failure path"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[1]",
          "text": "To increase deploy complexity without benefit"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].blocks[0].questions[1].options[2]",
          "text": "To replace all code reviews"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].title",
          "text": "Challenge: build stable upgrade markdown summary"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[2].hints[2]",
          "text": "Return plain markdown string without trailing spaces."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].title",
          "text": "Checkpoint: upgrade readiness artifact"
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[0]",
          "text": "ready is true only when issueCount equals 0."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[1]",
          "text": "Return stable keys in releaseTag, ready, migrationBatches order."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].hints[2]",
          "text": "Checkpoint output should be machine-readable deterministic JSON."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[0]",
          "text": "Use match on the BackoffStrategy enum to handle each case"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[1].hints[2]",
          "text": "should_retry simply checks if attempt is less than max_attempts"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].content",
          "text": "Implement a deadline management system to enforce time limits on operations."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[2].hints[0]",
          "text": "Store the absolute expiration timestamp in the Deadline struct"
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].content",
          "text": "Implement a fallback mechanism that provides alternative execution paths when primary operations fail."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[3].hints[1]",
          "text": "Only call fallback if primary returns None"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].hints[1]",
          "text": "record_success should reset everything to Closed state"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[0]",
          "text": "Always refill before checking if consumption is possible"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[2].hints[2]",
          "text": "Use min() to ensure tokens don't exceed capacity"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].content",
          "text": "Implement an error classification system to determine if errors are retryable."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[1]",
          "text": "should_retry can use matches! macro or match on classify result"
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[3].hints[2]",
          "text": "batch_classify can use iter().map().collect() pattern"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].title",
          "text": "Test Assertion Framework Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[1].hints[1]",
          "text": "Use format! to create descriptive error messages"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[2].hints[0]",
          "text": "Use vec![0; size] to create zero-filled data of specified size"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].title",
          "text": "Test Scenario Builder Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[3].hints[1]",
          "text": "Push strings into vectors (use to_string() to convert &str)"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].title",
          "text": "Fuzz Input Generator Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[1].hints[1]",
          "text": "Generate bytes by taking random % 256"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[2].content",
          "text": "Implement a property verifier that checks invariants hold across operations."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].title",
          "text": "Boundary Value Analyzer Challenge"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[1]",
          "text": "Typical value is the midpoint of the range"
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[3].hints[2]",
          "text": "Return all 7 boundary values as test cases"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].content",
          "text": "Implement a compute unit counter to estimate operation costs."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[0]",
          "text": "Loop cost is overhead plus iterations times per-iteration cost"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[1].hints[2]",
          "text": "Apply safety margin by multiplying budget by the percentage"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].title",
          "text": "Data Structure Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[0]",
          "text": "Use copy_from_slice to write data efficiently"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[1]",
          "text": "Track the highest written position as 'used'"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[2].hints[2]",
          "text": "Always check bounds before read/write operations"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].title",
          "text": "Batch Operation Optimizer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[3].content",
          "text": "Optimize batch operations to minimize compute units."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[0]",
          "text": "Use to_le_bytes() to convert integers to bytes"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[1]",
          "text": "Use from_le_bytes() to convert bytes back to integers"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[1].hints[2]",
          "text": "Alignment formula: if remainder, add (alignment - remainder)"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[0]",
          "text": "Annual rent is data size times lamports per byte per year"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[1]",
          "text": "Exemption threshold is annual rent times threshold years"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[2].hints[2]",
          "text": "Check if balance is greater than or equal to minimum"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].title",
          "text": "Zero-Copy Deserializer Challenge"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[0]",
          "text": "Use copy_from_slice to read fixed-size data into stack arrays"
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[3].hints[2]",
          "text": "Always advance offset after reading"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].title",
          "text": "Vesting Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[0]",
          "text": "Use saturating_sub to avoid underflow when calculating elapsed time"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[1].hints[2]",
          "text": "Releasable is simply vested minus already released"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].title",
          "text": "Token Allocation Distributor Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[0]",
          "text": "Use iter().map().sum() to calculate total percentage"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[2].hints[2]",
          "text": "Use find() to locate allocation by recipient"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].title",
          "text": "Release Schedule Generator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[3].hints[0]",
          "text": "Divide duration by intervals to get interval duration"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[0]",
          "text": "Use compound interest formula: A = P(1 + r/n)^(nt)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[1].hints[1]",
          "text": "Convert basis points to decimal by dividing by 10000"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[0]",
          "text": "If delegated_to is Some, voting power is 0 (they gave it away)"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[1]",
          "text": "Use filter to find voters who delegated to a specific address"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[2].hints[2]",
          "text": "Sum staked amounts to calculate delegated power"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].title",
          "text": "Proposal Threshold Calculator Challenge"
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[3].hints[0]",
          "text": "Convert basis points to amount: (supply * bps) / 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[1].title",
          "text": "Constant Product AMM Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].title",
          "text": "Liquidity Provider Calculator Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[2].hints[2]",
          "text": "Rewards are proportional to LP token holdings"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].content",
          "text": "Implement a time-weighted average price oracle."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[0]",
          "text": "Use retain() to filter out old observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[1]",
          "text": "Calculate duration between consecutive observations"
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[3].hints[2]",
          "text": "TWAP is weighted sum divided by total duration"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[0]",
          "text": "Max borrow is collateral value times LTV ratio"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[1]",
          "text": "Position is liquidatable when borrowed exceeds threshold * value"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[1].hints[2]",
          "text": "Health factor shows how close to liquidation (higher is safer)"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].title",
          "text": "Interest Rate Model Challenge"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].content",
          "text": "Implement a utilization-based interest rate model."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[2].hints[0]",
          "text": "Utilization is borrowed divided by supplied"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].content",
          "text": "Implement flash loan validation logic."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[0]",
          "text": "Fee is amount times fee_bps divided by 10000"
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[3].hints[1]",
          "text": "Total repay is principal plus fee"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[1].title",
          "text": "NFT Metadata Parser Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[2].hints[2]",
          "text": "Only verify if collection is complete"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].title",
          "text": "Attribute Rarity Calculator Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].content",
          "text": "Calculate NFT attribute rarity scores."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[0]",
          "text": "Rarity percentage is (count / total) * 100"
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[3].hints[1]",
          "text": "Rarity score is inverse of rarity (1 / rarity)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[1].hints[2]",
          "text": "Use any() to check if address is in restrictions list"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].title",
          "text": "Dynamic NFT Updater Challenge"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].content",
          "text": "Implement dynamic NFT attributes that can evolve over time."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[1]",
          "text": "Update last_updated timestamp after successful update"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[2].hints[2]",
          "text": "Time until update is max(0, next_update - current_time)"
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[3].hints[2]",
          "text": "Filter equipped items by matching type in items list"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[1].hints[2]",
          "text": "Privilege extension: if caller is signer, child can sign too"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[0]",
          "text": "Convert string seeds to bytes using as_bytes()"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[2].hints[1]",
          "text": "Simulate PDA finding by trying different bump values"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[0]",
          "text": "Use HashMap insert to register handlers"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[3].hints[1]",
          "text": "Route by looking up instruction_type in handlers map"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].title",
          "text": "Atomic Swap Orchestrator Challenge"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].content",
          "text": "Implement an atomic swap across multiple programs."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[1].hints[1]",
          "text": "Atomicity requires output_token of step N equals input_token of step N+1"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[2].content",
          "text": "Validate state consistency across multiple CPI calls."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[0]",
          "text": "Push permission into vector to register"
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[3].hints[2]",
          "text": "Use retain() to remove caller from allowed list"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].title",
          "text": "Arbitrage Opportunity Detector Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].content",
          "text": "Detect arbitrage opportunities across DEXes."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[1]",
          "text": "Profit percent is (sell - buy) / buy * 100"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[1].hints[2]",
          "text": "Use max_by to find best opportunity"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].title",
          "text": "Liquidation Opportunity Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[0]",
          "text": "Position is liquidatable when borrowed > threshold * collateral_value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[2].hints[2]",
          "text": "Liquidation profit is bonus percentage of collateral value"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].title",
          "text": "Priority Fee Calculator Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[0]",
          "text": "Urgency factor scales the base fee"
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[3].hints[1]",
          "text": "Execution probability decreases as more fees are higher"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[0]",
          "text": "Tip is percentage of total profit"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[1].hints[1]",
          "text": "Bundle is profitable if profit exceeds tip"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].title",
          "text": "Multi-Hop Arbitrage Finder Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].content",
          "text": "Find multi-hop arbitrage paths across token pairs."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[1]",
          "text": "Two-hop arbitrage goes A -> B -> A through different pools"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[2].hints[2]",
          "text": "Profit is final output minus initial input"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].title",
          "text": "MEV Simulation Engine Challenge"
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].content",
          "text": "Simulate MEV extraction to estimate profitability."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[3].hints[2]",
          "text": "Expected value weights profit by success probability"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[0]",
          "text": "Push config into vector to add"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[1].hints[1]",
          "text": "Use find() to locate config by environment name"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[0]",
          "text": "Compare binary length against MAX_PROGRAM_SIZE"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[2].hints[2]",
          "text": "Compression ratio shows percentage size reduction"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].title",
          "text": "Upgrade Authority Manager Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[0]",
          "text": "Push metadata into vector to register"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[3].hints[1]",
          "text": "can_upgrade checks if authority matches stored authority"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[0]",
          "text": "Track seen stages to enforce ordering constraints"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[1].hints[2]",
          "text": "Can skip build/test if only documentation files changed"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].title",
          "text": "Version Compatibility Checker Challenge"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[1]",
          "text": "Compatibility requires same major, actual >= required"
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[2].hints[2]",
          "text": "Use min_by to find smallest compatible version"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].title",
          "text": "Cross-Chain Messaging Architecture"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].content",
          "text": "Implement VAA (Verified Action Approval) signature verification."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[0]",
          "text": "Check signatures length against MIN_SIGNERS first"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[1].hints[2]",
          "text": "Quorum is 2/3 of total guardians rounded up"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[0]",
          "text": "Increment sequence before creating message"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[2].hints[2]",
          "text": "Verify message sequence is within emitted range"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[0]",
          "text": "Use contains() to check if sequence was processed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[1]",
          "text": "Return error if trying to mark already-processed sequence"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[3].hints[2]",
          "text": "Use retain() to filter out old sequences"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[1].hints[1]",
          "text": "Verify requester matches owner before unlocking"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].title",
          "text": "Wrapped Token Mint Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[2].hints[1]",
          "text": "Check bounds before minting/burning"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].title",
          "text": "Bridge Rate Limiter Challenge"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[0]",
          "text": "Reset window before checking if duration passed"
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[3].hints[1]",
          "text": "Only consume if total won't exceed max"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[1].hints[1]",
          "text": "Confidence ratio: conf / |price| < threshold"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[0]",
          "text": "Multiplier formula: smoothing / (period + 1)"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[1]",
          "text": "First EMA equals first price"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[3].hints[2]",
          "text": "Subsequent EMAs use weighted average formula"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].title",
          "text": "Median Price Calculator Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].content",
          "text": "Calculate median price from multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[1].hints[2]",
          "text": "Use retain() to filter out outliers"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].content",
          "text": "Implement consensus checking across multiple oracle sources."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[0]",
          "text": "Check minimum sources first"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[2].hints[2]",
          "text": "Agreement percent is (agreeing / total) * 100"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].title",
          "text": "Fallback Oracle Manager Challenge"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[0]",
          "text": "Store sources in priority order"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[1]",
          "text": "current_source index tracks which is active"
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[3].hints[2]",
          "text": "Fallback if index > 0 (not primary)"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].title",
          "text": "Proposal Lifecycle Manager Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[1].hints[1]",
          "text": "Voting active only during time window in Active state"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].title",
          "text": "Voting Power Calculator Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[0]",
          "text": "Delegated voters have 0 voting power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[1]",
          "text": "Quadratic voting uses square root of balance"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[2].hints[2]",
          "text": "Apply cap after calculating base power"
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].content",
          "text": "Manage vote delegation between DAO members."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[3].hints[0]",
          "text": "Remove existing delegation before creating new one"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].title",
          "text": "Treasury Spending Limit Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[1].hints[1]",
          "text": "Reset period if duration has passed"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[2].hints[2]",
          "text": "Remove operation from list to cancel"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].title",
          "text": "Automated Action Trigger Challenge"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[1]",
          "text": "Match on condition type to evaluate"
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[3].hints[2]",
          "text": "Only return non-triggered actions that meet conditions"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[1].hints[1]",
          "text": "Turn complete when all players submitted"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].title",
          "text": "Game State Compressor Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[0]",
          "text": "Use bit shifting to pack x in high 4 bits, y in low 4 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[2].hints[2]",
          "text": "Health stored as percentage (0-100) fits in 7 bits"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].title",
          "text": "Player Progression Tracker Challenge"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[0]",
          "text": "XP formula: base * multiplier^(level-1)"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[1]",
          "text": "Keep leveling up while XP exceeds requirement"
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[3].hints[2]",
          "text": "Check contains() before adding achievement"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[1].hints[1]",
          "text": "Verify by recomputing hash from reveal"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[2].hints[2]",
          "text": "4d6 drop lowest: roll 4, sum all, subtract minimum"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[1]",
          "text": "Generate random number in range [0, total)"
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[3].hints[2]",
          "text": "Find item where cumulative weight exceeds roll"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].title",
          "text": "Storage Cost Estimator Challenge"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].content",
          "text": "Estimate Arweave storage costs based on data size."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[2].hints[0]",
          "text": "Calculate winston cost then convert to USD"
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[3].hints[0]",
          "text": "Sort items by priority before bundling"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[0]",
          "text": "Validate tx_id length before adding"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[1].hints[1]",
          "text": "Resolve in order: exact, index, fallback"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[0]",
          "text": "Push item to vector to add"
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[3].hints[1]",
          "text": "Filter items where any tag matches"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].title",
          "text": "Staking Rewards Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[1].hints[0]",
          "text": "Apply commission as (1 - commission) multiplier"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[2].hints[0]",
          "text": "Weight factors: commission 40%, uptime 40%, skip rate 20%"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[0]",
          "text": "Target is total divided by count, clamped to min/max"
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[3].hints[2]",
          "text": "Check all allocations within tolerance percentage"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[1].hints[0]",
          "text": "Sum all cost components"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[2].title",
          "text": "Epoch Schedule Calculator Challenge"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[0]",
          "text": "Only inactive stakes can be activated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[1]",
          "text": "Only active stakes can be deactivated"
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[3].hints[2]",
          "text": "Fully active after warmup_epochs from activation"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[1].hints[0]",
          "text": "Use contains() to check ownership"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[2].hints[1]",
          "text": "Check guardian status before approving"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].title",
          "text": "Session Key Manager Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[0]",
          "text": "Valid if current time before expiration"
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[3].hints[2]",
          "text": "Remaining is max minus used"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].title",
          "text": "Spending Limit Enforcer Challenge"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[0]",
          "text": "Reset counters before checking"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[1]",
          "text": "Check all three limits: per-tx, daily, weekly"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[1].hints[2]",
          "text": "Reset daily if new day, weekly if 7+ days passed"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[2].hints[1]",
          "text": "Check contains() before adding"
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[3].title",
          "text": "Time Lock Enforcer Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[0]",
          "text": "Try bumps from 255 down to 0"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[1].hints[2]",
          "text": "Check if derived address matches expected"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[2].hints[2]",
          "text": "Collect into Vec<Vec<u8>>"
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[3].hints[1]",
          "text": "Signer seeds include all seeds plus bump"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].title",
          "text": "Nested PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].content",
          "text": "Generate PDAs derived from other PDA addresses."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[1].hints[0]",
          "text": "Include parent address in child seeds"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].title",
          "text": "Counter PDA Generator Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].content",
          "text": "Generate unique PDAs using incrementing counters."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[0]",
          "text": "Increment counter after each generation"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[2].hints[2]",
          "text": "Batch generation calls generate_next multiple times"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].title",
          "text": "PDA Collision Detector Challenge"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[0]",
          "text": "Check if seeds match any existing entry"
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[3].hints[1]",
          "text": "Return error if collision detected"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[1]",
          "text": "Compound inflation year over year"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[1].hints[2]",
          "text": "APY is inflation divided by staked percentage"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].title",
          "text": "Fee Burn Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[2].hints[1]",
          "text": "Burn is percentage of total fee"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].title",
          "text": "Rent Economics Calculator Challenge"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[0]",
          "text": "Annual rent is bytes times rate"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[1]",
          "text": "Exemption is annual times threshold years"
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[3].hints[2]",
          "text": "Rent due is annual times period"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].title",
          "text": "Supply Flow Tracker Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[0]",
          "text": "Total excludes burned tokens"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[1]",
          "text": "Apply flow by subtracting from source, adding to destination"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[1].hints[2]",
          "text": "Net flow is inflow minus outflow"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].title",
          "text": "Vesting Schedule Impact Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].content",
          "text": "Calculate token unlock impact on supply."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[0]",
          "text": "0 before cliff, linear after, full at end"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[1]",
          "text": "Monthly unlock is difference between consecutive months"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[2].hints[2]",
          "text": "Check multiple months to find peak"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].title",
          "text": "Protocol Sustainability Score Challenge"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[0]",
          "text": "Net issuance is inflation minus burn"
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[3].hints[1]",
          "text": "Burn ratio is burn divided by inflation"
        }
      ],
      "englishLikeMatches": [
        {
          "path": "courses.solana-fundamentals.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Core execution model, حساب semantics, و معاملة construction patterns you need before writing programs or complex clients."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].content",
          "englishWordCount": 238,
          "excerpt": "# Solana النموذج الذهني Solana development gets much easier once you stop thinking in terms of \"contracts that own state\" و start thinking in terms of \"programs that operate on حسابات.\" On Solana, the durable state of yo..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "On Solana, mutable app state is حساب data. Programs validate و mutate those حسابات but do not hold mutable state internally."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "The runtime checks the message envelope و authorization: fee payer, freshness via blockhash, required signatures, و تعليمة payloads."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[0].blocks[0].questions[2].explanation",
          "englishWordCount": 12,
          "excerpt": "Read/write sets let the runtime detect conflicts و parallelize independent work deterministically."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].content",
          "englishWordCount": 217,
          "excerpt": "# حسابات model تحليل معمق Every on-chain object on Solana is an حساب مع a standard envelope. You can reason about any حساب using a small set of fields: address, lamports, owner, executable flag, و data bytes length/conte..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[1].blocks[1].questions[2].explanation",
          "englishWordCount": 12,
          "excerpt": "SPL token state uses dedicated حساب layouts و authorization rules enforced by the token program."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[2].content",
          "englishWordCount": 265,
          "excerpt": "# معاملات & تعليمات An تعليمة is the smallest executable unit on Solana: `programId + account metas + opaque data bytes`. A معاملة wraps one or more تعليمات plus signatures و message metadata. This التصميم gives you comp..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].content",
          "englishWordCount": 54,
          "excerpt": "# Build a SOL transfer معاملة Implement a deterministic `buildTransferTx(params)` helper in the project file: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` - Use `@solana/web3.js` - Return a معاملة مع ..."
        },
        {
          "path": "courses.solana-fundamentals.modules[0].lessons[3].hints[2]",
          "englishWordCount": 13,
          "excerpt": "Mirror this logic in the real project helper in src/lib/دورات/solana-fundamentals/project/walletManager.ts."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].content",
          "englishWordCount": 218,
          "excerpt": "# Programs: what they are (و aren’t) A Solana program is executable حساب code, not an object that secretly owns mutable storage. Your program receives حسابات from the معاملة, verifies constraints, و writes only to حسابات..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "حساب lists are part of the تعليمة contract; hidden discovery would break determinism و scheduling assumptions."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[1].content",
          "englishWordCount": 213,
          "excerpt": "# عناوين مشتقة من البرنامج (PDAs) A عنوان مشتق من البرنامج (PDA) is a deterministic حساب address derived from seeds plus a program ID, مع one key property: it is intentionally off-curve, so no private key exists ل it. Th..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].content",
          "englishWordCount": 211,
          "excerpt": "# SPL Tokens الاساسيات SPL Token is Solana’s standard token program family ل fungible assets. A token mint حساب defines token-level configuration: decimals, total supply accounting, و authorities such as mint authority o..."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Associated Token حسابات standardize where fungible token balances are stored ل each owner/mint."
        },
        {
          "path": "courses.solana-fundamentals.modules[1].lessons[3].content",
          "englishWordCount": 51,
          "excerpt": "# محفظة Manager CLI-sim Implement a deterministic CLI parser + command executor in: - `src/lib/courses/solana-fundamentals/project/walletManager.ts` Required behavior: - `address` prints the active pubkey - `build-transf..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[0].content",
          "englishWordCount": 320,
          "excerpt": "# Anchor النموذج الذهني Anchor is best understood as a contract between three layers that must agree on shape: your Rust handlers, generated interface metadata (IDL), و client-side تعليمة builders. In raw Solana programs..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[1].content",
          "englishWordCount": 244,
          "excerpt": "# حسابات, constraints, و safety Most serious Solana vulnerabilities come from حساب validation mistakes, not from arithmetic. Anchor’s constraint system exists to turn those checks into declarative, auditable rules. You d..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[2].content",
          "englishWordCount": 225,
          "excerpt": "# PDAs in Anchor عناوين مشتقة من البرنامج are the backbone of predictable حساب topology in Anchor applications. A PDA is derived from seed bytes plus program ID و intentionally lives off the ed25519 curve, so no private ..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].content",
          "englishWordCount": 62,
          "excerpt": "# Initialize Counter PDA (deterministic) Implement deterministic helper functions ل a Counter project: - `deriveCounterPda(programId, authorityPubkey)` - `buildInitCounterIx(params)` This درس validates client-side reason..."
        },
        {
          "path": "courses.anchor-development.modules[0].lessons[3].hints[1]",
          "englishWordCount": 14,
          "excerpt": "The init تعليمة must include four keys in fixed order: counter PDA, authority, payer, system program."
        },
        {
          "path": "courses.anchor-development.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Deterministic تعليمة builders, stable state emulation, و الاختبار strategy that separates pure logic from network integration."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[0].content",
          "englishWordCount": 38,
          "excerpt": "# Increment تعليمة builder + state layout Implement deterministic increment behavior in pure TypeScript: - Build a reusable state representation ل counter data. - Implement `applyIncrement` as a pure transition function...."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[1].content",
          "englishWordCount": 226,
          "excerpt": "# الاختبار strategy without flakiness A reliable Solana curriculum should teach deterministic engineering first, then optional network integration. Flaky tests are usually caused by external dependencies: RPC latency, fa..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[2].content",
          "englishWordCount": 226,
          "excerpt": "# Client composition & UX Once تعليمة layouts و PDA logic are deterministic, client integration becomes a composition exercise: محفظة adapter ل signing, provider/connection ل transport, معاملة builder ل تعليمة packing, و..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].content",
          "englishWordCount": 47,
          "excerpt": "# Counter project checkpoint Compose the full deterministic flow: 1. Derive counter PDA from authority + program ID. 2. Build init تعليمة metadata. 3. Build increment تعليمة metadata. 4. Emulate state transitions: `init ..."
        },
        {
          "path": "courses.anchor-development.modules[1].lessons[3].hints[1]",
          "englishWordCount": 13,
          "excerpt": "Use fixed key order و fixed JSON key order to satisfy strict expected output matching."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[0].content",
          "englishWordCount": 430,
          "excerpt": "# محفظة state + حسابات النموذج الذهني ل UI devs Most Solana frontend bugs are not visual bugs. They are model bugs. A dashboard can look polished while silently computing balances from the wrong حساب class, mixing lampor..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[1].content",
          "englishWordCount": 335,
          "excerpt": "# معاملة lifecycle ل UI: pending/confirmed/finalized, optimistic UI Frontend معاملة UX is a state machine problem. Users press one button, but your app traverses multiple phases: intent creation, معاملة construction, sig..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[2].content",
          "englishWordCount": 349,
          "excerpt": "# Data correctness: dedupe, ordering, idempotency, correction events Frontend teams frequently assume event streams are perfectly ordered و unique. Production systems rarely behave that way. You can receive duplicate eve..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].content",
          "englishWordCount": 31,
          "excerpt": "# Build core state model + reducer from events Implement a deterministic reducer ل dashboard state: - apply event stream transitions ل balances و mint metadata - enforce idempotency by event id - support correction marke..."
        },
        {
          "path": "courses.solana-frontend.modules[0].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Corrections should mark replaced event ids و remove their effects from state transitions."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[0].content",
          "englishWordCount": 27,
          "excerpt": "# Implement event stream simulator + replay timeline + snapshots Build deterministic replay tooling: - replay sorted events by (ts, id) - snapshot every N applied events - compute stable checksum ل replay output - return..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[1].content",
          "englishWordCount": 28,
          "excerpt": "# Implement query layer + computed metrics Implement dashboard query/view logic: - search/filter/sort rows deterministically - compute total و row valueUsd مع fixed-scale integer math - expose stable view model ل UI rend..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[2].content",
          "englishWordCount": 378,
          "excerpt": "# Production UX: caching, pagination, error banners, skeletons, rate limits After model correctness, frontend quality is mostly about user trust under imperfect conditions. Users do not evaluate your dashboard by clean d..."
        },
        {
          "path": "courses.solana-frontend.modules[1].lessons[3].content",
          "englishWordCount": 27,
          "excerpt": "# Emit stable DashboardSummary from fixtures Compose deterministic checkpoint output: - owner, token count, totalValueUsd - top tokens sorted deterministically - recent activity rows - invariants و determinism metadata (..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[0].content",
          "englishWordCount": 501,
          "excerpt": "# AMM الاساسيات on Solana: pools, fees, slippage, و تأثير السعر When users click “Swap,” they usually assume there is one objective truth: the current price. In practice, frontend swap systems compute an estimate from po..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[1].content",
          "englishWordCount": 379,
          "excerpt": "# Quote anatomy: in/out, fees, minOut, و worst-case execution A production quote is not one number. It is a structured object that must tell users what they send, what they likely receive, how much they pay in fees, و wh..."
        },
        {
          "path": "courses.defi-solana.modules[0].lessons[2].content",
          "englishWordCount": 398,
          "excerpt": "# Routing: why two-hop can beat one-hop Users often assume direct pair routes are always best because they are simpler. In fragmented liquidity systems, that assumption fails frequently. A direct SOL -> JUP pool might ha..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[1].content",
          "englishWordCount": 29,
          "excerpt": "# Implement route enumeration و best-route selection Implement deterministic route planner: - enumerate one-hop و two-hop candidates - quote each candidate at exact input size - select best route using stable tie-breaker..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[2].content",
          "englishWordCount": 33,
          "excerpt": "# Implement slippage/minOut, fee breakdown, و safety invariants Implement deterministic safety layer: - apply slippage to compute minOut - simulate route مع virtual reserve updates - return structured errors ل invalid po..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[3].content",
          "englishWordCount": 394,
          "excerpt": "# Production swap UX: stale quotes, protection, و simulation A deterministic route engine is necessary but not sufficient ل production. Users experience DeFi through timing, messaging, و safety affordances. A mathematica..."
        },
        {
          "path": "courses.defi-solana.modules[1].lessons[4].content",
          "englishWordCount": 28,
          "excerpt": "# Produce stable SwapPlan + SwapSummary checkpoint Compose deterministic checkpoint artifacts: - build swap plan from selected route quote - include fixtureHash و modelVersion - emit stable summary مع path, minOut, fee t..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[0].content",
          "englishWordCount": 521,
          "excerpt": "# Solana threat model ل auditors: حسابات, owners, signers, writable, PDAs الامان work on Solana starts مع one non-negotiable fact: تعليمة callers choose the حساب list. Programs do not receive trusted implicit context. Th..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[1].content",
          "englishWordCount": 427,
          "excerpt": "# Evidence chain: reproduce, trace, impact, fix, verify Strong الامان reports are built on evidence chains, not opinions. In the Solana context, that means moving from a claim such as “missing signer check exists” to a d..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].content",
          "englishWordCount": 450,
          "excerpt": "# Common Solana bug classes و mitigations Auditors on Solana repeatedly encounter the same core bug families. The implementation details differ across protocols, but exploit mechanics are surprisingly consistent: identit..."
        },
        {
          "path": "courses.solana-security.modules[0].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "الامان failures are usually adversarial edge cases, so tests must target those edges directly."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[0].content",
          "englishWordCount": 41,
          "excerpt": "# Break it: exploit missing signer + owner checks Implement a deterministic exploit-proof formatter ل signer/owner vulnerabilities. Expected output fields: - scenario - before/after vault balance - before/after recipient..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[1].content",
          "englishWordCount": 28,
          "excerpt": "# Break it: exploit PDA spoof mismatch Implement a deterministic PDA spoof proof output. You must show: - expected PDA - accepted PDA - mismatch boolean - trace hash This درس validates evidence generation ل derivation mi..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[2].content",
          "englishWordCount": 28,
          "excerpt": "# Fix it: validations + invariant suite Implement patch validation output that confirms: - signer check - owner check - PDA check - safe u64 arithmetic - exploit blocked state مع error code Keep output deterministic ل ex..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[3].content",
          "englishWordCount": 440,
          "excerpt": "# Writing audit reports: severity, likelihood, blast radius, remediation A strong audit report is an engineering document, not a narrative essay. It should allow a reader to answer four questions quickly: what failed, ho..."
        },
        {
          "path": "courses.solana-security.modules[1].lessons[4].content",
          "englishWordCount": 27,
          "excerpt": "# Checkpoint: deterministic AuditReport JSON + markdown Create the final deterministic checkpoint payload: - دورة + version - scenario IDs - finding count This checkpoint mirrors the final دورة artifact produced by the s..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[0].content",
          "englishWordCount": 369,
          "excerpt": "# SPL tokens vs Token-2022: what extensions change Token engineering starts مع a clean boundary between base token semantics و configurable policy. Legacy SPL Token gives you a stable fungible primitive: mint metadata, t..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[1].content",
          "englishWordCount": 348,
          "excerpt": "# Mint anatomy: authorities, decimals, supply, freeze, mint A production token launch succeeds or fails on parameter discipline. The mint حساب is a compact policy object: it defines decimal precision, minting authority, ..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[2].content",
          "englishWordCount": 349,
          "excerpt": "# Extension safety pitfalls: fee configs, delegate abuse, default حساب state Token-2022 extensions let teams express policy in a standard token framework, but policy power is exactly where operational failures happen. ال..."
        },
        {
          "path": "courses.token-engineering.modules[0].lessons[3].content",
          "englishWordCount": 35,
          "excerpt": "# Validate token config + derive deterministic addresses offline Implement strict config validation و deterministic pseudo-derivation: - validate decimals, u64 strings, recipient totals, extension fields - derive stable ..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[0].content",
          "englishWordCount": 28,
          "excerpt": "# Build Token-2022 initialization تعليمة plan Create a deterministic offline initialization plan: - create mint حساب step - init mint step مع decimals - append selected extension steps in stable order - base64 encode ste..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[1].content",
          "englishWordCount": 27,
          "excerpt": "# Build mint-to + transfer-fee math + simulation Implement pure simulation ل transfer fees و launch distribution: - fee = min(maxFee, floor(amount * feeBps / 10000)) - aggregate distribution totals deterministically - en..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[2].content",
          "englishWordCount": 346,
          "excerpt": "# Launch checklist: params, upgrade/authority strategy, airdrop/الاختبار plan A successful token launch is an operations exercise as much as a programming task. By the time users see your token in محافظ, dozens of choice..."
        },
        {
          "path": "courses.token-engineering.modules[1].lessons[3].content",
          "englishWordCount": 27,
          "excerpt": "# Emit stable LaunchPackSummary Compose full project output as stable JSON: - normalized authorities و extensions - supply totals و optional fee model examples - deterministic plan metadata و invariants - fixtures hash +..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[0].content",
          "englishWordCount": 311,
          "excerpt": "# Mobile محفظة نظرة عامة Solana Mobile development is built around the Solana Mobile Stack (SMS), a set of standards و tooling designed ل secure, high-quality crypto-native mobile experiences. SMS is more than a hardware..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[1].content",
          "englishWordCount": 219,
          "excerpt": "# MWA Integration Integrating Mobile محفظة Adapter typically starts مع `@solana-mobile/mobile-wallet-adapter` APIs و an interaction pattern built around `transact()`. Within a معاملة session, the app can authorize, reque..."
        },
        {
          "path": "courses.solana-mobile.modules[0].lessons[2].content",
          "englishWordCount": 23,
          "excerpt": "# Build a Mobile معاملة Function Implement a helper that formats a deterministic MWA معاملة request summary string. Expected output format: `<cluster>|<payer>|<instructionCount>` Use this exact order و delimiter."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[0].content",
          "englishWordCount": 243,
          "excerpt": "# dApp Store Submission Publishing to the Solana dApp Store requires more than packaging binaries. Teams should treat submission as a product, compliance, و الامان review process. A strong submission demonstrates safe مح..."
        },
        {
          "path": "courses.solana-mobile.modules[1].lessons[1].content",
          "englishWordCount": 263,
          "excerpt": "# Mobile افضل الممارسات Mobile crypto UX requires balancing speed, safety, و trust. Users make high-stakes decisions on small screens, often on unstable networks. Solana mobile apps should therefore optimize ل explicitne..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[0].content",
          "englishWordCount": 272,
          "excerpt": "# الاختبار Approaches الاختبار Solana programs requires multiple layers because failures can occur in logic, حساب validation, معاملة composition, or network behavior. A production الاختبار strategy usually combines unit ..."
        },
        {
          "path": "courses.solana-testing.modules[0].lessons[1].content",
          "englishWordCount": 218,
          "excerpt": "# Bankrun الاختبار Solana Bankrun provides deterministic, high-speed test execution ل Solana programs from TypeScript environments. It emulates a local bank-like runtime where معاملات can be processed predictably, حسابات..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[0].content",
          "englishWordCount": 235,
          "excerpt": "# Fuzzing مع Trident Fuzzing explores large input spaces automatically to find bugs that handcrafted tests miss. ل Solana و Anchor programs, Trident-style fuzzing workflows generate randomized تعليمة sequences و paramete..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[1].content",
          "englishWordCount": 200,
          "excerpt": "# Devnet الاختبار Devnet الاختبار bridges the gap between deterministic local tests و real-world network conditions. While local مدققون و Bankrun are ideal ل speed و reproducibility, devnet reveals behavior under real RP..."
        },
        {
          "path": "courses.solana-testing.modules[1].lessons[2].content",
          "englishWordCount": 204,
          "excerpt": "# CI/CD Pipeline ل Solana A mature Solana CI/CD pipeline enforces quality gates across code, tests, الامان checks, و النشر workflows. ل program teams, CI is not just linting Rust و TypeScript; it is about protecting on-c..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].content",
          "englishWordCount": 284,
          "excerpt": "# Events model: معاملات, logs, و program تعليمات Indexing Solana starts مع understanding where data lives و how to extract structured events from raw chain data. Unlike EVM chains where events are explicit log topics, So..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Solana programs emit events via logs و state changes, not explicit event topics."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].content",
          "englishWordCount": 198,
          "excerpt": "# Token حساب decoding و SPL layout SPL Token حسابات follow a standardized binary layout that indexers must parse to track balances و mint operations. Understanding this layout enables you to extract meaningful data from ..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[1].blocks[1].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Amounts are stored as little-endian u64 و must be converted using the mint's decimal places."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[2].content",
          "englishWordCount": 46,
          "excerpt": "# Challenge: Decode token حساب + diff token balances Implement deterministic token حساب decoding و balance diffing: - Parse a 165-byte SPL Token حساب layout - Extract mint, owner, و amount fields - Compute balance differ..."
        },
        {
          "path": "courses.solana-indexing.modules[0].lessons[3].content",
          "englishWordCount": 216,
          "excerpt": "# معاملة meta parsing: logs, errors, و inner تعليمات معاملة metadata provides the context needed to index complex operations. Understanding how to parse logs, handle errors, و traverse inner تعليمات enables comprehensive..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[0].content",
          "englishWordCount": 37,
          "excerpt": "# Challenge: Index معاملات to normalized events Implement a معاملة indexer that produces normalized Event objects: - Parse تعليمة logs و identify event types - Extract transfer events مع from/to/amount/mint - Handle mult..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[1].content",
          "englishWordCount": 214,
          "excerpt": "# Pagination, checkpointing, و caching semantics Production indexers must handle large datasets efficiently while maintaining consistency. Pagination, checkpointing, و caching form the backbone of scalable indexing infra..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[2].content",
          "englishWordCount": 200,
          "excerpt": "# Analytics aggregation: per محفظة, per token metrics Raw event data becomes valuable through aggregation. Building analytics pipelines enables insights into user behavior, token flows, و protocol usage patterns. Per-محف..."
        },
        {
          "path": "courses.solana-indexing.modules[1].lessons[3].content",
          "englishWordCount": 49,
          "excerpt": "# Checkpoint: Produce stable JSON analytics summary Implement the final analytics checkpoint that produces a deterministic summary: - Aggregate events into per-محفظة و per-token metrics - Generate sorted, stable JSON out..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[0].content",
          "englishWordCount": 243,
          "excerpt": "# Address validation و memo strategies Payment flows on Solana require robust address validation و thoughtful memo strategies. Unlike traditional payment systems مع حساب numbers, Solana uses base58-encoded public keys th..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[1].content",
          "englishWordCount": 207,
          "excerpt": "# Idempotency keys و replay protection Payment systems must handle network failures gracefully. Idempotency ensures that retrying a failed request produces the same outcome as the original, preventing duplicate charges و..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[2].content",
          "englishWordCount": 46,
          "excerpt": "# Challenge: Create payment intent مع validation Implement a payment intent creator مع full validation: - Validate recipient address format (base58, 32 bytes) - Validate amount (positive, within limits) - Generate determ..."
        },
        {
          "path": "courses.solana-payments.modules[0].lessons[3].content",
          "englishWordCount": 184,
          "excerpt": "# معاملة building و key metadata Building payment معاملات requires careful attention to تعليمة construction, حساب metadata, و program interactions. The goal is creating valid, efficient معاملات that minimize fees while e..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[0].content",
          "englishWordCount": 28,
          "excerpt": "# Challenge: Build transfer معاملة Implement a transfer معاملة builder: - Build SystemProgram.transfer ل SOL transfers - Build TokenProgram.transfer ل SPL transfers - Return تعليمة bundle مع correct key metadata - Includ..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[1].content",
          "englishWordCount": 177,
          "excerpt": "# Webhook signing و verification Webhooks enable asynchronous payment notifications. الامان requires cryptographic signing so recipients can verify webhook authenticity و detect tampering. Webhook signing uses HMAC-SHA25..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[2].content",
          "englishWordCount": 185,
          "excerpt": "# Error state machine و receipt format Payment flows require well-defined state machines to handle the complexity of asynchronous confirmations, failures, و retries. Clear state transitions و receipt formats ensure relia..."
        },
        {
          "path": "courses.solana-payments.modules[1].lessons[3].content",
          "englishWordCount": 43,
          "excerpt": "# Challenge: Verify webhook و produce receipt Implement the final payment flow checkpoint: - Verify signed webhook signature (HMAC-SHA256) - Extract payment details from payload - Generate standardized receipt JSON - Inc..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[0].content",
          "englishWordCount": 269,
          "excerpt": "# Merkle trees ل state compression Compressed NFTs (cNFTs) on Solana use Merkle trees to dramatically reduce storage costs. Understanding Merkle trees is essential ل working مع compressed NFTs و building compression-awar..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[1].content",
          "englishWordCount": 205,
          "excerpt": "# Leaf hashing conventions و metadata Leaf hashing determines how NFT metadata is committed to the Merkle tree. Understanding these conventions ensures compatibility مع compression standards و proper proof generation. Le..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[2].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement Merkle tree insert + root updates Build a Merkle tree implementation مع insertions: - Insert leaves و compute new root - Update parent hashes up the tree - Handle tree growth و depth limits - Retur..."
        },
        {
          "path": "courses.solana-nft-compression.modules[0].lessons[3].content",
          "englishWordCount": 216,
          "excerpt": "# Proof generation و path computation Merkle proofs enable verification of leaf inclusion without accessing the entire tree. Understanding proof generation is essential ل working مع compressed NFTs و building verificatio..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[0].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement proof generation + verifier Build a complete proof system: - Generate proofs from a Merkle tree و leaf index - Verify proofs against a root hash - Handle invalid proofs (wrong siblings, wrong index..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[1].content",
          "englishWordCount": 206,
          "excerpt": "# Collection mints و metadata simulation Compressed NFT collections use a collection mint as the parent NFT, enabling grouping و verification of related assets. Understanding this hierarchy is essential ل building collec..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[2].content",
          "englishWordCount": 247,
          "excerpt": "# Attack surface: invalid proofs و replay Compressed NFTs introduce unique الامان considerations. Understanding attack vectors و mitigations is critical ل building secure compression-aware applications. Invalid proof att..."
        },
        {
          "path": "courses.solana-nft-compression.modules[1].lessons[3].content",
          "englishWordCount": 50,
          "excerpt": "# Checkpoint: Simulate mint + verify ownership proof Complete the compression lab checkpoint: - Simulate minting a cNFT (insert leaf, update root) - Generate ownership proof ل the minted NFT - Verify the proof against cu..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[0].content",
          "englishWordCount": 232,
          "excerpt": "# DAO model: proposals, voting, و execution Decentralized الحوكمة on Solana follows a proposal-based model where token holders vote on changes و the DAO treasury executes approved decisions. Understanding this flow is es..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[1].content",
          "englishWordCount": 179,
          "excerpt": "# Quorum math و vote weight calculation Accurate vote counting is critical ل legitimate الحوكمة outcomes. Understanding quorum requirements, vote weight calculation, و edge cases ensures fair decision-making. Quorum defi..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[0].lessons[2].content",
          "englishWordCount": 161,
          "excerpt": "# Timelock states و execution scheduling Timelocks provide a critical safety layer between الحوكمة approval و execution. Understanding timelock states و transitions ensures reliable proposal execution. Timelock states in..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[0].content",
          "englishWordCount": 159,
          "excerpt": "# Multisig معاملة building و approvals Multisig محافظ provide collective control over treasury funds. Understanding multisig construction, approval flows, و الامان patterns is essential ل treasury operations. Multisig st..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[1].content",
          "englishWordCount": 29,
          "excerpt": "# Challenge: Implement multisig tx builder + approval rules Build a multisig معاملة system: - Create معاملات مع تعليمات - Record signer approvals - Enforce threshold requirements - Handle approval revocation - Generate d..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[2].content",
          "englishWordCount": 175,
          "excerpt": "# Safe defaults: owner checks و replay guards الحوكمة و multisig systems require robust الامان defaults. Understanding common vulnerabilities و their mitigations protects treasury funds. Owner checks validate that معاملا..."
        },
        {
          "path": "courses.solana-governance-multisig.modules[1].lessons[3].content",
          "englishWordCount": 44,
          "excerpt": "# Challenge: Execute proposal و produce treasury diff Complete the الحوكمة simulator checkpoint: - Execute approved proposals مع timelock validation - Apply treasury state changes atomically - Generate execution trace مع..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[0].content",
          "englishWordCount": 210,
          "excerpt": "# Compute model: budgets, costs, و limits Solana's compute model enforces deterministic execution limits through compute budgets. Understanding this model is essential ل building efficient programs that stay within limit..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[1].content",
          "englishWordCount": 177,
          "excerpt": "# حساب layout التصميم و serialization cost حساب data layout significantly impacts compute costs. Well-designed layouts minimize serialization overhead و reduce حساب access costs. Serialization formats affect cost. Borsh ..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[2].content",
          "englishWordCount": 37,
          "excerpt": "# Challenge: Implement estimateCost(op) model Build a compute cost estimation system: - Model costs ل different operation types - حساب ل تعليمة complexity - Include memory access costs - Return baseline measurements - Ha..."
        },
        {
          "path": "courses.solana-performance.modules[0].lessons[3].content",
          "englishWordCount": 144,
          "excerpt": "# تعليمة data size و encoding optimization تعليمة data size directly impacts معاملة cost و throughput. Optimizing encoding reduces fees و increases the operations possible within compute limits. Compact encoding uses min..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[0].content",
          "englishWordCount": 41,
          "excerpt": "# Challenge: Implement optimized layout/codec Optimize an حساب data layout while preserving semantics: - Reduce data size through compact encoding - Maintain all original functionality - Preserve backward compatibility w..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].content",
          "englishWordCount": 163,
          "excerpt": "# Compute budget تعليمة الاساسيات Compute budget تعليمات give developers control over resource allocation و معاملة prioritization. Understanding these tools enables precise optimization. setComputeUnitLimit requests a sp..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 12,
          "excerpt": "Specific limits optimize costs - you pay ل the limit requested, not actual usage."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[2].content",
          "englishWordCount": 156,
          "excerpt": "# Micro-optimizations و tradeoffs الاداء optimization involves balancing competing concerns. Understanding tradeoffs helps make informed decisions about when و what to optimize. Readability vs الاداء is a constant tensio..."
        },
        {
          "path": "courses.solana-performance.modules[1].lessons[3].content",
          "englishWordCount": 37,
          "excerpt": "# Checkpoint: Compare before/after + output perf report Complete the optimization lab checkpoint: - Measure baseline الاداء metrics - Apply optimization techniques - Verify correctness is preserved - Generate الاداء comp..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].content",
          "englishWordCount": 376,
          "excerpt": "# Swap النموذج الذهني: mints, ATAs, decimals, و routes Token swaps on Solana follow a fundamentally different model than centralized exchanges. Understanding the building blocks — mints, associated token حسابات (ATAs), d..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 18,
          "excerpt": "AMM programs interact مع SPL token حسابات. Native SOL must be wrapped into the SPL token format so it can be processed by swap programs."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].content",
          "englishWordCount": 348,
          "excerpt": "# Slippage و تأثير السعر: protecting swap outcomes Slippage is the difference between the expected output amount at quote time و the actual amount received at execution time. In volatile markets مع active trading, pool r..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 18,
          "excerpt": "Token amounts are integers. Floating-point math can produce off-by-one errors that cause معاملة failures or incorrect minimum amounts."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[2].content",
          "englishWordCount": 385,
          "excerpt": "# Route visualization: understanding swap legs و fees Swap routes reveal the path your tokens take through DeFi liquidity. Visualizing routes helps users understand why a multi-hop path might yield more output than a dir..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[0].lessons[3].content",
          "englishWordCount": 64,
          "excerpt": "# Challenge: Build a normalized SwapPlan from a quote Parse a raw aggregator quote response و produce a normalized SwapPlan: - Extract input/output mints و amounts from the quote - Calculate minOutAmount using BigInt sli..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[0].content",
          "englishWordCount": 66,
          "excerpt": "# Challenge: Implement swap UI state machine Build a deterministic state machine ل the swap UI flow: - States: idle → quoting → ready → sending → confirming → success | error - Process a sequence of events و track all st..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[1].content",
          "englishWordCount": 368,
          "excerpt": "# Swap معاملة anatomy: تعليمات, حسابات, و compute A swap معاملة on Solana is a carefully ordered sequence of تعليمات that together achieve an atomic token exchange. Understanding each تعليمة's role, the حساب list require..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[2].content",
          "englishWordCount": 356,
          "excerpt": "# Reliability patterns: retries, stale quotes, و latency Production swap flows must handle the reality of network latency, expired quotes, و معاملة failures. Reliability engineering separates toy swap implementations fro..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].content",
          "englishWordCount": 65,
          "excerpt": "# Checkpoint: Generate a SwapRunReport Build the final swap run report that combines all دورة concepts: - Summarize the route مع leg details و total fees (using BigInt summation) - Compute the effective price as outAmoun..."
        },
        {
          "path": "courses.defi-swap-aggregator.modules[1].lessons[3].hints[2]",
          "englishWordCount": 12,
          "excerpt": "Collect errors from both the state machine result و any additional errors array."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].content",
          "englishWordCount": 619,
          "excerpt": "# CLMM vs constant product: why ticks exist Concentrated Liquidity Market Makers (CLMMs) represent a fundamental evolution in automated market maker التصميم. To understand why they exist, we must first understand the lim..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Ticks provide discrete price points ل position boundaries, liquidity transitions, و efficient fee tracking at tick crossings."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].content",
          "englishWordCount": 530,
          "excerpt": "# Price, tick, و sqrtPrice: core conversions The mathematical foundation of every CLMM rests on three interrelated representations of price: the human-readable price, the tick index, و the sqrtPriceX64. Understanding how..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Token amounts in a CLMM position are linear functions of sqrtPrice, making on-chain computation simpler و more gas-efficient."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[2].content",
          "englishWordCount": 618,
          "excerpt": "# Range positions: in-range و out-of-range dynamics A CLMM position is defined by its lower tick و upper tick. These two boundaries determine the price range in which the position is active, earns fees, و holds a mix of ..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[0].lessons[3].content",
          "englishWordCount": 61,
          "excerpt": "# Challenge: Implement tick/price conversion helpers Implement the core tick math functions used in every CLMM integration: - Convert a tick index to a human-readable price using price = 1.0001^tick - Convert the price t..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[0].content",
          "englishWordCount": 65,
          "excerpt": "# Challenge: Simulate position fee accrual Implement a fee accrual simulator ل a CLMM position over a price path: - Convert lower و upper tick boundaries to prices - Walk through each price in the path و determine in-ran..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].content",
          "englishWordCount": 615,
          "excerpt": "# Range strategies: tight, wide, و rebalancing rules Choosing the right price range is the most important decision a CLMM liquidity provider makes. The range determines capital efficiency, fee income, impermanent loss ex..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "Tight ranges concentrate capital ل higher efficiency و fee share, but the position goes out-of-range more often, requiring active management."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Full-range positions replicate constant product behavior و never go out-of-range, making them suitable ل highly volatile or unpredictable pairs."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[2].content",
          "englishWordCount": 631,
          "excerpt": "# CLMM risks: rounding, overflow, و tick spacing errors Building reliable CLMM integrations requires awareness of precision risks that can cause incorrect calculations, failed معاملات, or lost funds. This درس catalogs th..."
        },
        {
          "path": "courses.defi-clmm-liquidity.modules[1].lessons[3].content",
          "englishWordCount": 64,
          "excerpt": "# Checkpoint: Generate a Position Report Implement a comprehensive LP position report generator that combines all CLMM concepts: - Convert tick boundaries to human-readable prices - Determine in-range or out-of-range sta..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[0].content",
          "englishWordCount": 512,
          "excerpt": "# Lending pool model: supply, borrow, و utilization Lending protocols are the backbone of decentralized finance. They enable users to earn yield on idle assets by supplying them to a shared pool, while borrowers draw fro..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].content",
          "englishWordCount": 425,
          "excerpt": "# Interest rate curves و the kink model Interest rates in lending protocols are not fixed. They adjust dynamically based on pool utilization to balance supply و demand ل liquidity. The piecewise-linear \"kink\" model is th..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 15,
          "excerpt": "Above the kink, slope2 (the jump multiplier) applies, causing borrow rates to spike sharply و discourage further borrowing."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Supply rate = borrowRate * utilization * (1 - reserveFactor). Since utilization < 1 و reserveFactor > 0, the supply rate is always less than the borrow rate."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[2].content",
          "englishWordCount": 424,
          "excerpt": "# Health factor monitoring و liquidation preview The health factor is the single number that determines whether a lending position is safe or subject to liquidation. Monitoring health factors in real time is essential ل ..."
        },
        {
          "path": "courses.defi-lending-risk.modules[0].lessons[3].content",
          "englishWordCount": 83,
          "excerpt": "# Challenge: Compute utilization-based interest rates Implement the kink-based interest rate model used by lending protocols: - Calculate the utilization ratio from total supply و total borrowed - Apply the piecewise-lin..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[0].content",
          "englishWordCount": 73,
          "excerpt": "# Challenge: Compute health factor و liquidation status Implement the health factor computation ل a multi-asset lending position: - Sum collateral و borrow values from an array of position objects - Compute weighted aver..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].content",
          "englishWordCount": 504,
          "excerpt": "# Liquidation mechanics: bonus, close factor, و bad debt Liquidation is the enforcement mechanism that keeps lending protocols solvent. When a borrower's health factor falls below 1.0, external actors called liquidators ..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 16,
          "excerpt": "The liquidation bonus compensates liquidators ل gas costs و risk, ensuring positions are liquidated promptly to protect the protocol."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Bad debt materializes when rapid price drops make collateral worth less than the debt, leaving the protocol مع unrecoverable losses."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].content",
          "englishWordCount": 555,
          "excerpt": "# Oracle risk و stale pricing in lending Lending protocols depend entirely on accurate, timely price feeds to compute collateral values, health factors, و liquidation eligibility. Oracles — the services that bring off-ch..."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[0].explanation",
          "englishWordCount": 18,
          "excerpt": "Using price minus confidence ل collateral gives a conservative valuation, protecting the protocol when oracle publishers disagree or markets are volatile."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[2].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "Operating on stale prices is dangerous. Pausing operations prevents incorrect liquidations و under-collateralized borrows during oracle outages."
        },
        {
          "path": "courses.defi-lending-risk.modules[1].lessons[3].content",
          "englishWordCount": 76,
          "excerpt": "# Checkpoint: Generate a multi-scenario risk report Build the final risk report that combines all دورة concepts: - Evaluate a base case using current position prices - Apply price overrides from multiple named scenarios ..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[0].content",
          "englishWordCount": 598,
          "excerpt": "# Perpetual futures: base positions, entry price, و mark vs oracle Perpetual futures (perps) are synthetic derivatives that let traders gain exposure to an asset's price movement without holding the underlying token. Unl..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].content",
          "englishWordCount": 587,
          "excerpt": "# Funding rates: why they exist و how they accrue Funding rates are the mechanism that tethers a perpetual contract's price to the underlying spot price. Without funding, the perp price could drift arbitrarily far from r..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "A positive premium (mark > oracle) produces a positive funding rate. Longs pay shorts, which discourages excessive long demand و pushes the perp price back toward spot."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[2].content",
          "englishWordCount": 539,
          "excerpt": "# PnL visualization: tracking profit over time Profit و loss (PnL) tracking in perpetual futures requires careful accounting across multiple dimensions: unrealized PnL from price movement, realized PnL from closed portio..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[3].content",
          "englishWordCount": 54,
          "excerpt": "# Challenge: Calculate perpetual futures PnL Implement a PnL calculator ل perpetual futures positions: - Compute unrealized PnL based on entry price vs mark price - Handle both long و short positions correctly - Calculat..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[0].lessons[4].content",
          "englishWordCount": 70,
          "excerpt": "# Challenge: Simulate funding rate accrual Build a funding accrual simulator that processes discrete funding intervals: - Iterate through an array of funding rates و compute the payment ل each period - Longs pay (subtrac..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].content",
          "englishWordCount": 579,
          "excerpt": "# Margin ratio و liquidation thresholds Margin is the collateral that backs a leveraged position. When the margin falls below a critical threshold relative to the position's notional value, the protocol forcibly closes t..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 27,
          "excerpt": "The maintenance buffer ensures that when a position is liquidated, there is still margin left to pay liquidation fees و absorb slippage during the close. Without it, positions could go underwater, creating bad debt."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].content",
          "englishWordCount": 726,
          "excerpt": "# Common bugs: sign errors, units, و funding direction Perpetual futures implementations are mathematically straightforward — the formulas are basic arithmetic. Yet sign errors, unit mismatches, و funding direction bugs ..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 35,
          "excerpt": "When size carries the direction sign, every formula that uses size must حساب ل the sign — not just PnL, but also notional value, funding payments, و liquidation price. Keeping size positive و branching on a separate 'sid..."
        },
        {
          "path": "courses.defi-perps-risk-console.modules[1].lessons[2].content",
          "englishWordCount": 71,
          "excerpt": "# Checkpoint: Generate a Risk Console Report Build the comprehensive risk console report that integrates all دورة concepts: - Calculate unrealized PnL و ROE ل the position - Accumulate funding payments across all provide..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].content",
          "englishWordCount": 497,
          "excerpt": "# Why DeFi معاملات fail: CU limits, size, و blockhash expiry DeFi معاملات on Solana fail ل three primary reasons: compute budget exhaustion, معاملة size overflow, و blockhash expiry. Understanding each failure mode is es..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 12,
          "excerpt": "Solana allocates 200,000 CUs by default. DeFi معاملات almost always need more, requiring an explicit SetComputeUnitLimit تعليمة."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 17,
          "excerpt": "Expired blockhash معاملات are never processed و produce no on-chain record. The client must detect the timeout و resubmit مع a fresh blockhash."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].content",
          "englishWordCount": 427,
          "excerpt": "# Compute budget تعليمات و priority fee strategy The Compute Budget Program provides two critical تعليمات that every serious DeFi معاملة should include: `SetComputeUnitLimit` و `SetComputeUnitPrice`. Together, they contr..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 13,
          "excerpt": "حساب state may change between simulation و execution, causing minor CU variations. A 10% margin absorbs these differences."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[2].content",
          "englishWordCount": 438,
          "excerpt": "# معاملة cost estimation و fee planning Accurate fee estimation is the foundation of a good DeFi user experience. Users need to know what a معاملة will cost before they sign it. مدققون need sufficient fees to prioritize ..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[0].lessons[3].content",
          "englishWordCount": 68,
          "excerpt": "# Challenge: Build a معاملة plan مع compute budgeting Build a معاملة planning function that analyzes a set of تعليمات و produces a complete معاملة plan: - Sum estimatedCU from all تعليمات و add a 10% safety margin (ceili..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[0].content",
          "englishWordCount": 89,
          "excerpt": "# Challenge: Plan Address Lookup Table usage Build a function that determines the optimal Address Lookup Table strategy ل a معاملة: - Collect all unique حساب keys across تعليمات - Check which keys exist in available LUTs..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].content",
          "englishWordCount": 502,
          "excerpt": "# Reliability patterns: retry, re-quote, resend vs rebuild Production DeFi applications must handle معاملة failures gracefully. The difference between a frustrating و a reliable experience comes down to retry strategy: k..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 22,
          "excerpt": "Rebuilding is necessary when the معاملة's blockhash is stale or when on-chain state has changed (e.g., slippage exceeded). Simple network issues only require resending the same bytes."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[1].blocks[0].questions[1].options[0]",
          "englishWordCount": 12,
          "excerpt": "To prevent many clients from retrying at the exact same moment و overwhelming the network"
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[2].content",
          "englishWordCount": 548,
          "excerpt": "# UX: actionable error messages ل معاملة failures Raw Solana error messages are cryptic. \"معاملة simulation failed: Error processing تعليمة 2: custom program error: 0x1771\" tells a developer something but tells a user no..."
        },
        {
          "path": "courses.defi-tx-optimizer.modules[1].lessons[3].content",
          "englishWordCount": 81,
          "excerpt": "# Checkpoint: Generate a send strategy report Build the final send strategy report that combines all دورة concepts into a comprehensive معاملة optimization plan: - Build a tx plan: sum CU estimates مع 10% margin (capped ..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].content",
          "englishWordCount": 665,
          "excerpt": "# Mobile signing reality check: Android vs iOS constraints Mobile محفظة signing on Solana is fundamentally different from browser-based محفظة interactions. The constraints imposed by Android و iOS operating systems shape..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "Android MWA uses foreground services to maintain a persistent communication channel between the dApp و محفظة, enabling multi-request sessions without app switching."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].content",
          "englishWordCount": 653,
          "excerpt": "# محفظة connection UX patterns: connect, reconnect, و recovery محفظة connection on mobile is the first interaction users have مع your dApp. A smooth connection flow builds trust; a broken one drives users away. This درس ..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Network mismatches should be communicated clearly to the user مع تعليمات on how to resolve them, avoiding confusing silent failures."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[2].content",
          "englishWordCount": 599,
          "excerpt": "# Signing session timeline: request, محفظة, و response flow Understanding the complete lifecycle of a mobile signing request is essential ل building reliable dApps. Every sign request passes through multiple stages, each..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].content",
          "englishWordCount": 61,
          "excerpt": "# Challenge: Build a typed sign request Implement a sign request builder ل Mobile محفظة Adapter: - Validate the payload type (معاملة or message) - Validate payload data (base64 ل معاملات, non-empty string ل messages) - S..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[0].lessons[3].hints[2]",
          "englishWordCount": 13,
          "excerpt": "App identity requires at least name و URI. Icon is optional but should default to empty string."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[0].content",
          "englishWordCount": 55,
          "excerpt": "# Challenge: Session persistence و restoration Implement a session persistence manager ل mobile محفظة sessions: - Process a sequence of actions: save, restore, clear, و expire_check - Track محفظة address و last sign requ..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].content",
          "englishWordCount": 570,
          "excerpt": "# Mobile معاملة review: what users need to see معاملة review screens are the last line of defense between a user و a potentially harmful معاملة. On mobile, screen real estate is limited و user attention is fragmented. De..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 16,
          "excerpt": "Token amounts must be converted to human-readable format using the token's decimal configuration و include the symbol ل clarity."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 14,
          "excerpt": "Balance change summaries (e.g., -1.5 SOL, +150 USDC) are the most user-friendly way to communicate what a معاملة will do."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[2].content",
          "englishWordCount": 657,
          "excerpt": "# One-tap retry: handling offline, rejected, و timeout states Mobile environments are inherently unreliable. Users move between WiFi و cellular, enter tunnels, close apps mid-معاملة, و محافظ crash. A robust retry system ..."
        },
        {
          "path": "courses.solana-mobile-signing.modules[1].lessons[3].content",
          "englishWordCount": 57,
          "excerpt": "# Checkpoint: Generate a session report Implement a session report generator that summarizes a complete mobile signing session: - Count total requests, successful signs, و failed signs - Sum retry attempts across all req..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].content",
          "englishWordCount": 550,
          "excerpt": "# Solana Pay النموذج الذهني و URL encoding rules Solana Pay is an open specification ل encoding payment requests into URLs that محافظ can parse و execute. Unlike traditional payment processors that rely on centralized in..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 14,
          "excerpt": "The Solana Pay specification uses the 'solana:' scheme followed immediately by the recipient address مع no slashes."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 15,
          "excerpt": "معاملة requests allow the server to build arbitrarily complex معاملات. Transfer requests only support simple single-token transfers."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].content",
          "englishWordCount": 584,
          "excerpt": "# Transfer request anatomy: recipient, amount, reference, و labels A Solana Pay transfer request URL contains everything a محفظة needs to construct و submit a payment معاملة. Each component of the URL serves a specific p..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "The reference public key is included as a non-signer حساب in the transfer تعليمة. The merchant polls getSignaturesForAddress(reference) to detect when the payment معاملة confirms."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "Solana Pay URLs use human-readable decimal amounts. The محفظة handles the conversion to raw units based on the token's decimal configuration."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[2].content",
          "englishWordCount": 448,
          "excerpt": "# URL builder: live preview of Solana Pay URLs Building Solana Pay URLs correctly requires understanding how each parameter contributes to the final encoded string. In this درس, we walk through the construction process s..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[0].lessons[3].content",
          "englishWordCount": 72,
          "excerpt": "# Challenge: Encode a Solana Pay transfer request URL Build a function that encodes a Solana Pay transfer request URL from input parameters: - Validate the recipient address (must be 32-44 characters of valid base58) - V..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[0].content",
          "englishWordCount": 82,
          "excerpt": "# Challenge: Track payment references through confirmation states Build a reference tracking state machine that processes payment events: - States flow: pending -> found -> confirmed -> finalized (or pending -> expired) ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].content",
          "englishWordCount": 600,
          "excerpt": "# Confirmation UX: pending, confirmed, و expired states The user experience during payment confirmation is the most critical moment in any Solana Pay integration. Between the customer scanning the QR code و the merchant ..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 19,
          "excerpt": "ل coffee-shop-scale payments, confirmed commitment provides a strong enough guarantee. Finalized adds 6-12 seconds of latency و is only necessary when fulfillment is irreversible."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 22,
          "excerpt": "Expired requests should be clearly communicated. The customer may have been in the middle of approving — they need to know the request expired و can try again."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[2].content",
          "englishWordCount": 656,
          "excerpt": "# Error handling و edge cases in payment flows Production payment systems encounter a wide range of failure modes that must be handled gracefully. Solana Pay integrations face challenges unique to blockchain payments: ne..."
        },
        {
          "path": "courses.solana-pay-commerce.modules[1].lessons[3].content",
          "englishWordCount": 76,
          "excerpt": "# Checkpoint: Generate a POS receipt Build the final POS receipt generator that combines all دورة concepts: - Reconstruct the Solana Pay URL from payment data (recipient, amount, spl-token, reference, label) - Generate a..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].content",
          "englishWordCount": 643,
          "excerpt": "# Connection UX that doesn't suck: a التصميم checklist محفظة connection is the first interaction a user has مع any Solana dApp. If this experience is slow, confusing, or error-prone, most users will leave before they eve..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 16,
          "excerpt": "Skeleton UI reserves the layout space ل محفظة-dependent content, preventing jarring shifts when the connection resolves و data loads."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].content",
          "englishWordCount": 675,
          "excerpt": "# Network gating و wrong-network recovery Solana has multiple clusters: mainnet-beta, devnet, testnet, و localnet. Unlike EVM chains where the محفظة controls the network و emits chain-change events, Solana's network sele..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 30,
          "excerpt": "Each Solana cluster has a unique genesis hash. Comparing the RPC's genesis hash against known values is the only reliable detection method, since URL strings can be misleading و محافظ don't always expose network info."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 22,
          "excerpt": "While حساب addresses are identical across clusters, the حساب states (balances, data, existence) are completely different. All cached RPC data must be cleared on network switch."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[2].content",
          "englishWordCount": 578,
          "excerpt": "# Connection state machine: states, events, و transitions محفظة connection logic in most dApps is implemented as a tangle of boolean flags, useEffect hooks, و conditional renders. This approach leads to impossible states..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[0].lessons[3].content",
          "englishWordCount": 69,
          "excerpt": "# Challenge: Implement محفظة connection state machine Build a deterministic state machine ل محفظة connection management: - States: disconnected, connecting, connected, error - Process a sequence of events و track all sta..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[0].content",
          "englishWordCount": 78,
          "excerpt": "# Challenge: Cache invalidation on محفظة events Build a cache invalidation engine that processes محفظة events و invalidates the correct cache entries: - Cache entries have tags: \"حساب\" (محفظة-specific data), \"network\" (c..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].content",
          "englishWordCount": 635,
          "excerpt": "# RPC reads و caching strategy ل محفظة apps Every interaction in a Solana محفظة application ultimately depends on RPC calls: fetching balances, loading token حسابات, reading program state, و confirming معاملات. Without a..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 25,
          "excerpt": "The same حساب address can have completely different state on mainnet vs devnet. Without the network in the key, switching clusters would return stale data from the previous cluster."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 23,
          "excerpt": "SWR prioritizes responsiveness by serving stale data instantly while refreshing in the background. This eliminates loading states ل data that has only slightly exceeded its TTL."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[2].content",
          "englishWordCount": 829,
          "excerpt": "# RPC health monitoring و graceful degradation RPC endpoints are the lifeline of every Solana محفظة application. When they go down, become slow, or return stale data, your app becomes unusable. Production محفظة apps must..."
        },
        {
          "path": "courses.wallet-ux-engineering.modules[1].lessons[3].content",
          "englishWordCount": 69,
          "excerpt": "# Checkpoint: Generate a محفظة UX Report Build the final محفظة UX quality report that combines all دورة concepts: - Count connection attempts (CONNECT events) و successful connections (CONNECTED events) - Calculate succe..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].content",
          "englishWordCount": 767,
          "excerpt": "# Why SIWS exists: replacing connect-و-signMessage Before Sign-In مع Solana (SIWS) became a standard, dApps authenticated محفظة holders using a two-step pattern: connect the محفظة, then call `signMessage` مع an arbitrary..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "Without structured format, محافظ treat signMessage payloads as opaque bytes و cannot validate or warn about the content, making it easy ل malicious dApps to disguise harmful payloads as sign-in requests."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[0].blocks[0].questions[1].explanation",
          "englishWordCount": 23,
          "excerpt": "The server generates a unique nonce ل each sign-in attempt. After successful verification, the nonce is marked as consumed. Any reuse of the same nonce is rejected as a replay attack."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].content",
          "englishWordCount": 796,
          "excerpt": "# SIWS input fields و الامان rules The Sign-In مع Solana input is a structured object that defines every parameter of an authentication request. Each field has specific validation rules, الامان implications, و rendering ..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 23,
          "excerpt": "If the client generates nonces, an attacker can replay a previously captured nonce-signature pair. Server-generated nonces ensure each authentication attempt is unique و controlled by the server."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 19,
          "excerpt": "The domain field must be a plain domain name. Protocol prefixes, paths, ports, و query strings must be rejected to ensure consistent domain matching."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[2].content",
          "englishWordCount": 765,
          "excerpt": "# Message preview: how محافظ render SIWS requests When a dApp sends a SIWS sign-in request to a محفظة, the محفظة transforms the structured input into a human-readable message that the user sees on the approval screen. Un..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[0].lessons[3].content",
          "englishWordCount": 65,
          "excerpt": "# Challenge: Build a validated SIWS sign-in input Implement a function that creates a validated Sign-In مع Solana input: - Validate domain (non-empty, must not include protocol prefix) - Validate nonce (at least 8 charac..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[0].content",
          "englishWordCount": 57,
          "excerpt": "# Challenge: Verify a SIWS sign-in response Implement server-side verification of a SIWS sign-in output: - Check domain matches expected domain - Check nonce matches expected nonce - Check issuedAt is not in the future r..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].content",
          "englishWordCount": 749,
          "excerpt": "# Sessions و logout: what to store و what not to store After a successful SIWS sign-in verification, the server must establish a session so the user does not need to re-authenticate on every request. Session management ل..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[0].explanation",
          "englishWordCount": 29,
          "excerpt": "محفظة addresses are publicly known. Using them as session IDs would allow anyone who knows a user's address to impersonate their session. Random tokens ensure only the authenticated client can present a valid session."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[1].blocks[0].questions[1].explanation",
          "englishWordCount": 21,
          "excerpt": "محفظة disconnection signals the user's intent to end the interaction. The dApp should respect this by invalidating the session, preventing confusion about authentication state."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[2].content",
          "englishWordCount": 847,
          "excerpt": "# Replay protection و nonce registry التصميم Replay attacks are the most critical threat to any signature-based authentication system. In a replay attack, an adversary captures a valid signed message و submits it again t..."
        },
        {
          "path": "courses.sign-in-with-solana.modules[1].lessons[3].content",
          "englishWordCount": 75,
          "excerpt": "# Checkpoint: Generate an auth audit report Build the final auth audit report that combines all دورة concepts: - Process an array of authentication attempts مع address, nonce, و verified status - Track used nonces to det..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].content",
          "englishWordCount": 567,
          "excerpt": "# Fee markets on Solana: what actually moves inclusion Priority fees on Solana are often explained as a simple slider, but production systems need a more precise model. Inclusion is influenced by contention ل compute, مد..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[0].blocks[0].questions[0].explanation",
          "englishWordCount": 13,
          "excerpt": "A large CU request مع weak price can lose inclusion, while aggressive price on oversized CU can overpay."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[1].content",
          "englishWordCount": 516,
          "excerpt": "# Compute budget الاساسيات و common failure modes Most معاملة failures blamed on \"network issues\" are actually planning errors in compute budget و payload sizing. A defensive client treats compute planning as a determini..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[0].lessons[2].content",
          "englishWordCount": 449,
          "excerpt": "# Explorer: compute budget planner inputs to plan Explorers are useful only when they expose policy tradeoffs clearly. ل a fee و compute planner, that means visualizing how input estimates, percentile targets, و confirma..."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[1].content",
          "englishWordCount": 12,
          "excerpt": "Implement policy-based priority fee estimation using synthetic sample arrays و deterministic warnings."
        },
        {
          "path": "courses.priority-fees-compute-budget.modules[1].lessons[3].content",
          "englishWordCount": 14,
          "excerpt": "Build stable markdown output ل a fee strategy summary that users و support teams can review quickly."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[0].content",
          "englishWordCount": 503,
          "excerpt": "# Atomicity concepts و why users assume all-or-nothing Users rarely think in معاملة graphs. They think in intents: \"swap my token\" or \"close my position.\" When a workflow spans multiple معاملات, user expectation remains ..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[1].content",
          "englishWordCount": 488,
          "excerpt": "# Multi-معاملة flows: approvals, ATA creation, swaps, refunds A reliable flow simulator must encode where partial execution risk lives. In practice, risk points cluster at boundaries: before value transfer, during value ..."
        },
        {
          "path": "courses.bundles-atomicity.modules[0].lessons[2].content",
          "englishWordCount": 453,
          "excerpt": "# Explorer: flow graph steps و risk points Flow graph explorers are most valuable when they highlight risk semantics, not just sequence order. A defensive explorer should display each step مع dependency context, idempote..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[0].content",
          "englishWordCount": 512,
          "excerpt": "# What can go wrong between quote و execution A swap quote is a prediction, not a guarantee. Between quote generation و execution, liquidity changes, competing orders land, و network conditions shift. Users often assume ..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[1].content",
          "englishWordCount": 469,
          "excerpt": "# Slippage controls و guardrails Slippage settings are a policy surface, not a cosmetic preference. Defensive swap UX defines explicit bounds, context-aware defaults, و clear consequences when users attempt risky overrid..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[0].lessons[2].content",
          "englishWordCount": 429,
          "excerpt": "# Explorer: quote freshness timer و decision table A quote freshness explorer should make policy behavior obvious under time pressure. Users و engineers need to see when a quote transitions from safe to warning to blocke..."
        },
        {
          "path": "courses.mempool-ux-defense.modules[1].lessons[0].content",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic swap risk grading from quote, slippage, impact, hops, و liquidity inputs."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[0].content",
          "englishWordCount": 490,
          "excerpt": "# Indexing 101: logs, حسابات, و معاملة parsing Reliable indexers are not just fast parsers. They are consistency systems that decide what to trust, when to trust it, و how to recover from changing chain history. On Solan..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[1].content",
          "englishWordCount": 449,
          "excerpt": "# Reorgs و fork choice: why confirmed is not finalized Confirmation labels are useful but often misunderstood in indexing pipelines. A confirmed event has stronger confidence than processed, but it is not equivalent to f..."
        },
        {
          "path": "courses.indexing-webhooks-pipelines.modules[0].lessons[2].content",
          "englishWordCount": 449,
          "excerpt": "# Explorer: ingest to dedupe to confirm to apply A pipeline explorer should explain transformation stages clearly so engineers can inspect where correctness can break. ل indexing reliability, the core stages are ingest, ..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Real-world RPC failure behavior, endpoint selection strategy, و deterministic retry policy modeling."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[0].content",
          "englishWordCount": 502,
          "excerpt": "# RPC failures in real life: timeouts, 429s, stale nodes Reliable client infrastructure begins مع realistic failure assumptions. RPC calls fail ل many reasons: transient network timeouts, provider rate limits, stale node..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[1].content",
          "englishWordCount": 420,
          "excerpt": "# Multi-endpoint strategies: hedged requests و fallbacks Multi-endpoint التصميم is more than adding a backup URL. It is a scheduling problem where each request should be sent to the most suitable endpoint given recent he..."
        },
        {
          "path": "courses.rpc-reliability-latency.modules[0].lessons[2].content",
          "englishWordCount": 444,
          "excerpt": "# Explorer: retry/backoff simulator Retry و backoff policies determine whether clients recover gracefully or amplify outages. A simulator should make schedule behavior explicit so teams can reason about user latency و pr..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[0].content",
          "englishWordCount": 527,
          "excerpt": "# Memory layout: alignment, padding, و why Solana حسابات care Rust layout behavior is deterministic inside one compiled binary but can vary when assumptions are implicit. ل Solana حسابات, this matters because raw bytes a..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[1].content",
          "englishWordCount": 470,
          "excerpt": "# Struct و enum layout pitfalls plus Borsh rules Borsh is widely used because it gives deterministic serialization across languages, but teams still get tripped up by how enums, vectors, و strings map to bytes. Understan..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[0].lessons[2].content",
          "englishWordCount": 421,
          "excerpt": "# Explorer: layout visualizer ل field offsets A layout visualizer turns abstract alignment rules into concrete numbers engineers can review. Instead of debating whether a struct is \"probably fine,\" teams can inspect exac..."
        },
        {
          "path": "courses.rust-data-layout-borsh.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement deterministic layout analysis, encoding/decoding, safe parsing, و compatibility-focused reporting helpers."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[0].content",
          "englishWordCount": 523,
          "excerpt": "# Error taxonomy: recoverable vs fatal Rust encourages explicit error modeling, but teams still produce weak error contracts when they rely on ad hoc strings or inconsistent wrappers. In Solana و Anchor-adjacent systems,..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[1].content",
          "englishWordCount": 501,
          "excerpt": "# Result<T, E> patterns, ? operator, و context Result-based control flow is one of Rust's strongest tools ل building robust services و on-chain-adjacent clients. The key is not merely using Result, but designing error ty..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[0].lessons[2].content",
          "englishWordCount": 445,
          "excerpt": "# Explorer: invariant decision tree An invariant decision tree helps teams reason about guard ordering و failure priority. Not every invariant should be checked in arbitrary order. Early checks should prevent expensive w..."
        },
        {
          "path": "courses.rust-errors-invariants.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement guard helpers, evidence-chain generation, و stable audit reporting ل reliability و incident response."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[0].content",
          "englishWordCount": 470,
          "excerpt": "# الاداء النموذج الذهني: allocations, clones, hashing Rust الاداء work in Solana ecosystems is mostly about data movement discipline. Teams often chase micro-optimizations while ignoring dominant costs such as repeated a..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[1].content",
          "englishWordCount": 453,
          "excerpt": "# Data structures: Vec, HashMap, BTreeMap tradeoffs Data structure choice is one of the highest leverage الاداء decisions in Rust systems. Vec offers compact contiguous storage و predictable iteration speed. HashMap offe..."
        },
        {
          "path": "courses.rust-perf-onchain-thinking.modules[0].lessons[2].content",
          "englishWordCount": 433,
          "excerpt": "# Explorer: cost model sandbox A cost sandbox lets teams test optimization hypotheses without waiting ل full benchmark infrastructure. Provide operation counts, compute weighted costs, و inspect which buckets dominate to..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[0].content",
          "englishWordCount": 485,
          "excerpt": "# Async fundamentals: futures, tasks, channels Rust async systems are built on explicit scheduling rather than implicit thread-per-task models. Futures represent pending work, executors poll futures, و channels coordinat..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[1].content",
          "englishWordCount": 430,
          "excerpt": "# Concurrency limits و backpressure Backpressure is not optional in high-volume pipelines. Without it, producer speed can overwhelm reducers, retries, or storage sinks. A resilient التصميم sets explicit concurrency caps ..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[0].lessons[2].content",
          "englishWordCount": 450,
          "excerpt": "# Explorer: pipeline graph و concurrency Pipeline graphs help teams communicate stage boundaries, concurrency budgets, و retry behaviors. A graph that shows ingest, dedupe, retry, و snapshot stages مع explicit capacities..."
        },
        {
          "path": "courses.rust-async-indexer-pipeline.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Implement deterministic scheduling, retries, dedupe/reducer stages, و report exports ل reorg-safe pipeline operations."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[0].content",
          "englishWordCount": 470,
          "excerpt": "# Macro النموذج الذهني: declarative vs procedural Rust macros come in two broad forms: declarative macros ل pattern-based expansion و procedural macros ل syntax-aware transformation. Anchor relies heavily on macro-driven..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[1].content",
          "englishWordCount": 443,
          "excerpt": "# Safety through codegen: constraint checks Constraint codegen converts compact declarations into explicit runtime guards. Typical constraints include signer presence, حساب ownership, has-one relations, و mutability requ..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[0].lessons[2].content",
          "englishWordCount": 441,
          "excerpt": "# Explorer: constraint builder to generated checks A constraint builder explorer helps engineers see how DSL choices affect generated code و runtime safety outcomes. Input one attribute line, observe parsed AST, generate..."
        },
        {
          "path": "courses.rust-proc-macros-codegen-safety.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Parse DSL constraints, generate checks, run deterministic evaluations, و publish stable safety reports."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[0].content",
          "englishWordCount": 521,
          "excerpt": "# Upgrade authority lifecycle in Anchor programs Anchor makes تعليمة development easier, but upgrade safety still depends on disciplined control of program authority. In production Solana systems, most upgrade incidents ..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[1].content",
          "englishWordCount": 475,
          "excerpt": "# حساب versioning و migration strategy Solana حسابات are long-lived state containers, so program upgrades must respect historical data. In Anchor, adding or changing حساب fields can be safe, risky, or catastrophic depend..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[0].lessons[2].content",
          "englishWordCount": 431,
          "excerpt": "# Explorer: upgrade risk matrix A useful upgrade explorer should show cause-و-effect between release inputs و safety outcomes. If a flag changes, engineers should immediately see how severity و readiness changes. This در..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[1].content",
          "englishWordCount": 431,
          "excerpt": "# Rollback strategy و incident playbooks Even strong upgrade plans can encounter surprises: incompatible downstream clients, unexpected حساب edge cases, or release pipeline mistakes. Teams that recover quickly are the on..."
        },
        {
          "path": "courses.anchor-upgrades-migrations.modules[1].lessons[3].content",
          "englishWordCount": 13,
          "excerpt": "Produce the final deterministic checkpoint artifact مع release tag, readiness flag, و migration batch count."
        },
        {
          "path": "courses.solana-reliability.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Implement fault-tolerance building blocks مع clear failure classification, retry boundaries, و deterministic recovery behavior."
        },
        {
          "path": "courses.solana-reliability.modules[0].lessons[0].content",
          "englishWordCount": 213,
          "excerpt": "Fault tolerance in Solana systems is not just about catching errors. It is about deciding which failures are safe to retry, which should fail fast, و how to preserve user trust while doing both. A عملي reliability model ..."
        },
        {
          "path": "courses.solana-reliability.modules[1].description",
          "englishWordCount": 16,
          "excerpt": "Build resilience mechanisms (circuit breakers, bulkheads, و rate controls) that protect core user flows during provider instability."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[0].content",
          "englishWordCount": 180,
          "excerpt": "Resilience patterns are controls that prevent localized failures from becoming system-wide incidents. On Solana integrations, they are especially important because provider health can change quickly under bursty network ..."
        },
        {
          "path": "courses.solana-reliability.modules[1].lessons[1].content",
          "englishWordCount": 13,
          "excerpt": "Implement a circuit breaker pattern that opens after consecutive failures و closes after a recovery period."
        },
        {
          "path": "courses.solana-testing-strategies.modules[0].lessons[0].content",
          "englishWordCount": 150,
          "excerpt": "الاختبار Solana systems effectively requires layered confidence, not one giant test suite. Unit tests validate pure logic: math, state transitions, و invariant checks. They should be fast, deterministic, و run on every c..."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].description",
          "englishWordCount": 14,
          "excerpt": "Use fuzzing, property-based tests, و mutation-style checks to expose edge-case failures before release."
        },
        {
          "path": "courses.solana-testing-strategies.modules[1].lessons[0].content",
          "englishWordCount": 146,
          "excerpt": "متقدم الاختبار techniques uncover failures that example-based tests rarely find. Fuzzing explores broad random input space to trigger parser edge cases, boundary overflows, و unexpected state combinations. It is especial..."
        },
        {
          "path": "courses.solana-program-optimization.modules[0].lessons[0].content",
          "englishWordCount": 105,
          "excerpt": "Compute units are the hard resource budget that shapes what your Solana program can do in a single معاملة. الاداء optimization starts by treating CU usage as a contract, not an afterthought. A reliable optimization loop ..."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "التصميم memory/storage-efficient حساب layouts مع rent-aware sizing, serialization discipline, و safe migration planning."
        },
        {
          "path": "courses.solana-program-optimization.modules[1].lessons[0].content",
          "englishWordCount": 91,
          "excerpt": "حساب data optimization is both a cost و correctness discipline. Poor layouts increase rent, slow parsing, و make migrations fragile. التصميم principles: - Keep hot fields compact و easy to parse. - Use fixed-size represe..."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Model token allocation و vesting systems مع explicit fairness, unlock predictability, و deterministic accounting rules."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[0].lessons[0].content",
          "englishWordCount": 89,
          "excerpt": "Token distribution is a الامان و credibility decision, not just a spreadsheet exercise. Allocation و vesting rules shape long-term trust in the protocol. A strong distribution model answers: - who receives tokens و why, ..."
        },
        {
          "path": "courses.solana-tokenomics-design.modules[1].lessons[0].content",
          "englishWordCount": 85,
          "excerpt": "Staking و الحوكمة systems must balance participation incentives مع manipulation resistance. Rewarding lock behavior is useful, but poorly tuned models can over-concentrate influence. Core التصميم questions: 1) How is sta..."
        },
        {
          "path": "courses.solana-defi-primitives.modules[0].lessons[0].content",
          "englishWordCount": 93,
          "excerpt": "AMM fundamentals are simple in formula but subtle in implementation quality. The invariant math must be deterministic, fee handling explicit, و rounding behavior consistent across paths. ل constant-product pools, route q..."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Model lending و flash-loan flows مع collateral safety, utilization-aware pricing, و strict repayment invariants."
        },
        {
          "path": "courses.solana-defi-primitives.modules[1].lessons[0].content",
          "englishWordCount": 81,
          "excerpt": "Lending primitives و flash-loan logic are powerful but unforgiving. Safety depends on strict collateral valuation, clear LTV/threshold rules, و deterministic repayment checks. A عملي lending model should define: - collat..."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Build core NFT functionality مع standards-compliant metadata, collection verification, و deterministic asset-state handling."
        },
        {
          "path": "courses.solana-nft-standards.modules[0].lessons[0].content",
          "englishWordCount": 74,
          "excerpt": "NFT architecture on Solana combines token mechanics مع metadata و collection semantics. A correct implementation requires more than minting a token مع supply one. Core components include: - mint/state ownership correctne..."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement متقدم NFT behaviors (soulbound و programmable flows) مع explicit policy controls و safe update semantics."
        },
        {
          "path": "courses.solana-nft-standards.modules[1].lessons[0].content",
          "englishWordCount": 67,
          "excerpt": "متقدم NFT features introduce policy complexity that must be explicit. Soulbound behavior, programmable restrictions, و dynamic metadata updates all expand failure surface. ل soulbound models, non-transferability must be ..."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Build CPI fundamentals مع strict حساب/signer checks, ownership validation, و safe PDA signing boundaries."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[0].lessons[0].content",
          "englishWordCount": 77,
          "excerpt": "استدعاء بين البرامج (CPI) is where Solana composability becomes عملي و where many الامان failures appear. The caller controls حساب lists, so every CPI boundary must be treated as untrusted input. Safe CPI التصميم require..."
        },
        {
          "path": "courses.solana-cpi-patterns.modules[1].lessons[0].content",
          "englishWordCount": 86,
          "excerpt": "Multi-program composition introduces sequencing و consistency risk. Even when each CPI call is correct in isolation, combined flows can violate business invariants if ordering or rollback assumptions are weak. Robust com..."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand MEV mechanics و معاملة ordering realities, then model opportunities و risks مع deterministic safety-aware policies."
        },
        {
          "path": "courses.solana-mev-strategies.modules[0].lessons[0].content",
          "englishWordCount": 156,
          "excerpt": "Maximal Extractable Value (MEV) on Solana is fundamentally about معاملة ordering under limited blockspace. Whether you are building trading tools, liquidation infrastructure, or user-facing apps, you need a realistic mod..."
        },
        {
          "path": "courses.solana-mev-strategies.modules[1].lessons[0].content",
          "englishWordCount": 115,
          "excerpt": "متقدم معاملة-ordering strategies require disciplined orchestration, not just faster opportunity scans. Bundle-oriented execution is valuable because it can express dependency sets و all-or-nothing intent, but bundle التص..."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[0].lessons[0].content",
          "englishWordCount": 126,
          "excerpt": "Solana النشر is not one command; it is a release system مع environment-specific risk. Localnet, devnet, و mainnet each serve different validation goals, و production quality depends on using them intentionally. A reliabl..."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].description",
          "englishWordCount": 13,
          "excerpt": "Build CI/CD pipelines that enforce build/test/الامان gates, compatibility checks, و controlled rollout/rollback evidence."
        },
        {
          "path": "courses.solana-deployment-cicd.modules[1].lessons[0].content",
          "englishWordCount": 111,
          "excerpt": "CI/CD ل Solana should enforce release quality, not just automate command execution. A عملي pipeline includes staged gates: 1) static quality gate (lint/type/الامان checks), 2) deterministic unit/integration tests, 3) bui..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[0].lessons[0].content",
          "englishWordCount": 131,
          "excerpt": "Cross-chain messaging is a trust-boundary problem before it is a transport problem. In Wormhole-style systems, messages are observed, attested, و consumed across different chain environments, each مع independent failure ..."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement asset-bridging patterns مع strict supply/accounting invariants, replay protection, و reconciliation workflows."
        },
        {
          "path": "courses.solana-cross-chain-bridges.modules[1].lessons[0].content",
          "englishWordCount": 113,
          "excerpt": "Token bridging requires strict supply و state invariants. Lock-و-mint و burn-و-mint models both rely on one central rule: represented supply across chains must remain coherent. Critical controls include: - single-consume..."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand oracle data semantics (price, confidence, staleness) و enforce deterministic validation before business logic."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[0].lessons[0].content",
          "englishWordCount": 108,
          "excerpt": "Oracle integration is a risk-control problem, not a data-fetch problem. Price feeds must be evaluated ل freshness, confidence, و contextual fitness before they drive protocol decisions. A safe oracle validation pipeline ..."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "التصميم multi-oracle aggregation و consensus policies that reduce single-source failure risk while remaining explainable و testable."
        },
        {
          "path": "courses.solana-oracle-pyth.modules[1].lessons[0].content",
          "englishWordCount": 103,
          "excerpt": "Multi-oracle aggregation reduces single-point dependency but adds policy complexity. The goal is not to average blindly; it is to produce a robust decision value مع clear confidence in adverse conditions. Common strategi..."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Implement الحوكمة mechanics مع explicit proposal lifecycle rules, voting-power logic, و deterministic state transitions."
        },
        {
          "path": "courses.solana-dao-tooling.modules[0].lessons[0].content",
          "englishWordCount": 101,
          "excerpt": "DAO الحوكمة architecture is a system of enforceable process rules. Proposal creation, voting, و execution must be deterministic, auditable, و resistant to manipulation. A robust الحوكمة model defines: 1) proposal lifecyc..."
        },
        {
          "path": "courses.solana-dao-tooling.modules[1].lessons[0].content",
          "englishWordCount": 103,
          "excerpt": "DAO treasury management is where الحوكمة intent becomes real financial action. Treasury tooling must therefore combine flexibility مع strict policy constraints. Core controls include: - spending limits و role-based autho..."
        },
        {
          "path": "courses.solana-gaming.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "التصميم game state و turn logic مع deterministic transitions, storage efficiency, و anti-cheat validation boundaries."
        },
        {
          "path": "courses.solana-gaming.modules[0].lessons[0].content",
          "englishWordCount": 127,
          "excerpt": "On-chain game التصميم on Solana is a systems-engineering tradeoff between fairness, responsiveness, و cost. The best designs keep critical rules verifiable while minimizing expensive state writes. Core architecture decis..."
        },
        {
          "path": "courses.solana-gaming.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement fairness-oriented randomness و integrity controls that keep gameplay auditable و dispute-resistant."
        },
        {
          "path": "courses.solana-gaming.modules[1].lessons[0].content",
          "englishWordCount": 113,
          "excerpt": "Randomness is one of the hardest fairness problems in blockchain games because execution is deterministic. Robust designs avoid naive pseudo-randomness tied directly to manipulable context. عملي fairness patterns include..."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Understand permanent-storage architecture و build deterministic linking between Solana state و external immutable content."
        },
        {
          "path": "courses.solana-permanent-storage.modules[0].lessons[0].content",
          "englishWordCount": 116,
          "excerpt": "Permanent storage integration is a data durability contract. On Solana, storing full content on-chain is often impractical, so systems rely on immutable external storage references anchored by on-chain metadata. A robust..."
        },
        {
          "path": "courses.solana-permanent-storage.modules[1].lessons[0].content",
          "englishWordCount": 93,
          "excerpt": "Manifests turn many stored assets into one navigable root, but they introduce their own integrity responsibilities. A manifest is only trustworthy if path mapping و referenced content IDs are validated consistently. Key ..."
        },
        {
          "path": "courses.solana-staking-economics.modules[0].lessons[0].content",
          "englishWordCount": 101,
          "excerpt": "Solana staking economics is an incentives system connecting delegators, مدققون, و network الامان. Good delegation decisions require more than chasing headline APY. Delegators should evaluate: 1) مدقق الاداء consistency, ..."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Analyze مدقق-side economics, operational cost pressure, و incentive alignment ل long-term network health."
        },
        {
          "path": "courses.solana-staking-economics.modules[1].lessons[0].content",
          "englishWordCount": 98,
          "excerpt": "مدقق economics balances revenue opportunities against operational costs و reliability obligations. Sustainable مدققون optimize ل long-term trust, not short-term extraction. Revenue sources include inflation rewards و fee..."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Build smart-محفظة fundamentals including multisig و social-recovery designs مع clear trust و failure boundaries."
        },
        {
          "path": "courses.solana-account-abstraction.modules[0].lessons[0].content",
          "englishWordCount": 107,
          "excerpt": "حساب abstraction on Solana shifts control from a single key to programmable policy. Smart محافظ can enforce richer authorization logic, but policy complexity must be managed carefully. A robust smart-محفظة التصميم define..."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].description",
          "englishWordCount": 12,
          "excerpt": "Implement programmable validation policies (limits, allowlists, time/risk rules) مع deterministic enforcement و auditability."
        },
        {
          "path": "courses.solana-account-abstraction.modules[1].lessons[0].content",
          "englishWordCount": 99,
          "excerpt": "Programmable validation is where smart محافظ deliver real value, but it is also where subtle policy bugs appear. Typical controls include spending limits, destination allowlists, time windows, و risk-score gates. These c..."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].description",
          "englishWordCount": 13,
          "excerpt": "Build strong PDA foundations مع deterministic derivation, canonical seed composition, و collision-resistant namespace strategy."
        },
        {
          "path": "courses.solana-pda-mastery.modules[0].lessons[0].content",
          "englishWordCount": 106,
          "excerpt": "عناوين مشتقة من البرنامج (PDAs) are deterministic authority و state anchors on Solana. Their power comes from predictable derivation; their risk comes from inconsistent seed discipline. A strong PDA التصميم standard defi..."
        },
        {
          "path": "courses.solana-pda-mastery.modules[1].lessons[0].content",
          "englishWordCount": 97,
          "excerpt": "متقدم PDA patterns solve real scaling و composability needs but increase التصميم complexity. Nested PDAs, counter-based PDAs, و multi-tenant PDA namespaces each require explicit invariants around uniqueness, lifecycle, و..."
        },
        {
          "path": "courses.solana-economics.modules[0].description",
          "englishWordCount": 12,
          "excerpt": "Understand Solana macro token economics (inflation, burn, rewards, fees) مع deterministic scenario modeling."
        },
        {
          "path": "courses.solana-economics.modules[0].lessons[0].content",
          "englishWordCount": 109,
          "excerpt": "Solana economics is the interaction of issuance, burn, staking rewards, و usage demand. Sustainable protocol decisions require understanding these flows as a system, not isolated metrics. Core mechanisms include: 1) infl..."
        },
        {
          "path": "courses.solana-economics.modules[1].description",
          "englishWordCount": 15,
          "excerpt": "Model token flow dynamics و sustainability signals using supply categories, unlock events, و behavior-driven liquidity effects."
        },
        {
          "path": "courses.solana-economics.modules[1].lessons[0].content",
          "englishWordCount": 111,
          "excerpt": "Token flow analysis turns abstract economics into operational insight. The key is to track where tokens are (staked, circulating, locked, treasury, pending unlock) و how they move over time. Useful flow metrics include: ..."
        }
      ],
      "totals": {
        "exactEnglishCount": 866,
        "englishLikeCount": 332
      }
    }
  ],
  "uiHardcodedStrings": [],
  "summary": {
    "uiHardcodedCount": 0,
    "byLocale": {
      "es": {
        "exactEnglishCount": 866,
        "englishLikeCount": 457
      },
      "pt-BR": {
        "exactEnglishCount": 866,
        "englishLikeCount": 459
      },
      "fr": {
        "exactEnglishCount": 931,
        "englishLikeCount": 454
      },
      "it": {
        "exactEnglishCount": 942,
        "englishLikeCount": 456
      },
      "de": {
        "exactEnglishCount": 916,
        "englishLikeCount": 477
      },
      "zh-CN": {
        "exactEnglishCount": 866,
        "englishLikeCount": 332
      },
      "ar": {
        "exactEnglishCount": 866,
        "englishLikeCount": 332
      }
    }
  }
}
