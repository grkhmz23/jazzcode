import type { Challenge, Course, Lesson, Module } from "@/types/content";
import {
  lesson3Hints,
  lesson3SolutionCode,
  lesson3StarterCode,
  lesson3TestCases,
} from "@/lib/courses/solana-payments/challenges/lesson-3-payment-intent";
import {
  lesson5Hints,
  lesson5SolutionCode,
  lesson5StarterCode,
  lesson5TestCases,
} from "@/lib/courses/solana-payments/challenges/lesson-5-transfer-tx";
import {
  lesson8Hints,
  lesson8SolutionCode,
  lesson8StarterCode,
  lesson8TestCases,
} from "@/lib/courses/solana-payments/challenges/lesson-8-webhook-receipt";

const lesson1: Lesson = {
  id: "payments-v2-address-validation",
  slug: "payments-v2-address-validation",
  title: "Address validation and memo strategies",
  type: "content",
  xpReward: 40,
  duration: "45 min",
  content: `# Address validation and memo strategies

Payment flows on Solana require robust address validation and thoughtful memo strategies. Unlike traditional payment systems with account numbers, Solana uses base58-encoded public keys that must be validated before any value transfer.

Address validation involves three layers: format validation, derivation check, and ownership verification. Format validation ensures the string is valid base58 and decodes to 32 bytes. Derivation check optionally verifies the address is on the Ed25519 curve (for wallet addresses) or off-curve (for PDAs). Ownership verification confirms the account exists and is owned by the expected program.

Memos attach metadata to payments. The SPL Memo program enables attaching UTF-8 strings to transactions. Common use cases include: order IDs, invoice references, customer identifiers, and compliance data. Memos are not encrypted and are visible on-chain, so never include sensitive information.

Memo best practices: keep under 256 bytes for efficiency, use structured formats (JSON) for machine parsing, include versioning for future compatibility, and hash sensitive identifiers rather than storing them plaintext. Consider using deterministic memo formats that can be regenerated from payment context for idempotency checks.

Address poisoning is an attack vector where attackers create addresses visually similar to legitimate ones. Countermeasures include: displaying addresses with checksums, using name services (Solana Name Service, Bonfida) where appropriate, and implementing confirmation steps for large transfers.

## Merchant-safe memo template

A practical memo format is:
\`v1|order:<id>|shop:<merchantId>|nonce:<shortHash>\`

This keeps memos short, parseable, and versioned while avoiding direct storage of sensitive user details.

## Checklist
- Validate base58 encoding and 32-byte length
- Distinguish between on-curve and off-curve addresses
- Verify account ownership for program-specific payments
- Use SPL Memo program for structured metadata
- Implement address poisoning protections

## Red flags
- Transferring to unvalidated addresses
- Storing sensitive data in plaintext memos
- Skipping ownership checks for token accounts
- Trusting visually similar addresses without verification
`,
  blocks: [
    {
      type: "quiz",
      id: "payments-v2-l1-quiz",
      title: "Concept Check",
      questions: [
        {
          id: "payments-v2-l1-q1",
          prompt: "What is the purpose of SPL Memo in payments?",
          options: [
            "Attach metadata like order IDs to transactions",
            "Encrypt payment amounts",
            "Replace transaction signatures",
          ],
          answerIndex: 0,
          explanation: "SPL Memo allows attaching public metadata to transactions for reference and tracking.",
        },
        {
          id: "payments-v2-l1-q2",
          prompt: "What should never be included in a memo?",
          options: [
            "Sensitive private information",
            "Order reference numbers",
            "Timestamp data",
          ],
          answerIndex: 0,
          explanation: "Memos are public on-chain; sensitive data should be hashed or kept off-chain.",
        },
      ],
    },
  ],
};

const lesson2: Lesson = {
  id: "payments-v2-idempotency",
  slug: "payments-v2-idempotency",
  title: "Idempotency keys and replay protection",
  type: "content",
  xpReward: 45,
  duration: "50 min",
  content: `# Idempotency keys and replay protection

Payment systems must handle network failures gracefully. Idempotency ensures that retrying a failed request produces the same outcome as the original, preventing duplicate charges and inconsistent state.

Idempotency keys are unique identifiers generated by clients for each payment intent. The server stores processed keys and their outcomes, returning cached results for duplicate submissions. Keys should be: globally unique (UUID v4), client-generated, and persisted with sufficient TTL to handle extended retry windows.

Key generation strategies include: UUID v4 with timestamp prefix, hash of payment parameters (amount, recipient, timestamp), or structured keys combining merchant ID and local sequence numbers. The key must be stable across retries but unique across distinct payments.

Replay protection prevents malicious or accidental re-execution. Beyond idempotency, transactions should include: recent blockhash freshness (prevents old transaction replay), durable nonce for offline signing scenarios, and amount/time bounds where applicable.

Error classification affects retry behavior. Network errors warrant retries with exponential backoff. Validation errors (insufficient funds, invalid address) should fail fast without retry. Timeout errors require careful handling - the payment may have succeeded, so query status before retrying.

## Checklist
- Generate unique idempotency keys for each payment intent
- Store processed keys with outcomes for deduplication
- Implement appropriate TTL based on retry windows
- Use recent blockhash for transaction freshness
- Classify errors for appropriate retry strategies

## Red flags
- Allowing duplicate payments from retries
- Generating idempotency keys server-side only
- Ignoring timeout ambiguity in status checking
- Storing keys without expiration
`,
  blocks: [
    {
      type: "terminal",
      id: "payments-v2-l2-flow",
      title: "Payment Flow",
      steps: [
        {
          cmd: "POST /v1/payment-intents",
          output: '{"id":"pi_123","idempotency_key":"uuid-v4","status":"pending"}',
          note: "Create payment intent with idempotency key",
        },
        {
          cmd: "POST /v1/payment-intents/pi_123/confirm",
          output: '{"id":"pi_123","status":"processing"}',
          note: "Confirm triggers transaction building",
        },
        {
          cmd: "GET /v1/payment-intents/pi_123",
          output: '{"id":"pi_123","status":"succeeded","signature":"abc123"}',
          note: "Poll for final status",
        },
      ],
    },
  ],
};

const lesson3: Challenge = {
  id: "payments-v2-payment-intent",
  slug: "payments-v2-payment-intent",
  title: "Challenge: Create payment intent with validation",
  type: "challenge",
  xpReward: 55,
  duration: "45 min",
  language: "typescript",
  content: `# Challenge: Create payment intent with validation

Implement a payment intent creator with full validation:

- Validate recipient address format (base58, 32 bytes)
- Validate amount (positive, within limits)
- Generate deterministic idempotency key
- Return structured payment intent object
- Handle edge cases (zero amount, invalid address)

Your implementation will be tested against various valid and invalid inputs.`,
  starterCode: lesson3StarterCode,
  testCases: lesson3TestCases,
  hints: lesson3Hints,
  solution: lesson3SolutionCode,
};

const lesson4: Lesson = {
  id: "payments-v2-tx-building",
  slug: "payments-v2-tx-building",
  title: "Transaction building and key metadata",
  type: "content",
  xpReward: 45,
  duration: "45 min",
  content: `# Transaction building and key metadata

Building payment transactions requires careful attention to instruction construction, account metadata, and program interactions. The goal is creating valid, efficient transactions that minimize fees while ensuring correctness.

Instruction construction follows a pattern: identify the program (System Program for SOL transfers, Token Program for SPL transfers), prepare account metas with correct writable/signer flags, serialize instruction data according to the program's layout, and compute the transaction message with all required fields.

Account metadata is critical. For SOL transfers, you need: from (signer + writable), to (writable). For SPL transfers: token account from (signer + writable), token account to (writable), owner (signer), and potentially a delegate if using delegated transfer. Missing or incorrect flags cause runtime failures.

Fee optimization strategies include: batching multiple payments into one transaction (up to compute unit limits), using address lookup tables (ALTs) for accounts referenced multiple times, and setting appropriate compute unit limits to avoid overpaying for simple operations.

Transaction validation before submission: verify all required signatures are present, check recent blockhash is fresh, estimate compute units if possible, and validate instruction data encoding matches the expected layout.

## Checklist
- Set correct writable/signer flags on all accounts
- Use appropriate program for transfer type (SOL vs SPL)
- Validate instruction data encoding
- Include recent blockhash for freshness
- Consider batching for multiple payments

## Red flags
- Missing signer flags on fee payer
- Incorrect writable flags on recipient accounts
- Using wrong program ID for token type
- Stale blockhash causing transaction rejection
`,
  blocks: [
    {
      type: "explorer",
      id: "payments-v2-l4-tx-structure",
      title: "Transaction Structure",
      explorer: "AccountExplorer",
      props: {
        samples: [
          {
            label: "Transfer Instruction",
            address: "Instruction1111111111111111111111111111111",
            lamports: 5000,
            owner: "SystemProgram11111111111111111111111111111111",
            executable: false,
            dataLen: 12,
          },
        ],
      },
    },
  ],
};

const lesson5: Challenge = {
  id: "payments-v2-transfer-tx",
  slug: "payments-v2-transfer-tx",
  title: "Challenge: Build transfer transaction",
  type: "challenge",
  xpReward: 60,
  duration: "50 min",
  language: "typescript",
  content: `# Challenge: Build transfer transaction

Implement a transfer transaction builder:

- Build SystemProgram.transfer for SOL transfers
- Build TokenProgram.transfer for SPL transfers
- Return instruction bundle with correct key metadata
- Include fee payer and blockhash
- Support deterministic output for testing`,
  starterCode: lesson5StarterCode,
  testCases: lesson5TestCases,
  hints: lesson5Hints,
  solution: lesson5SolutionCode,
};

const lesson6: Lesson = {
  id: "payments-v2-webhooks",
  slug: "payments-v2-webhooks",
  title: "Webhook signing and verification",
  type: "content",
  xpReward: 45,
  duration: "45 min",
  content: `# Webhook signing and verification

Webhooks enable asynchronous payment notifications. Security requires cryptographic signing so recipients can verify webhook authenticity and detect tampering.

Webhook signing uses HMAC-SHA256 with a shared secret. The sender computes: signature = HMAC-SHA256(secret, payload). The signature is included in a header (e.g., X-Webhook-Signature). Recipients recompute the HMAC and compare, using constant-time comparison to prevent timing attacks.

Payload canonicalization ensures consistent signing. JSON objects must be serialized with: sorted keys (alphabetical), no extra whitespace, consistent number formatting, and UTF-8 encoding. Without canonicalization, {"a":1,"b":2} and {"b":2,"a":1} produce different signatures.

Idempotency in webhooks prevents duplicate processing. Webhook payloads should include an idempotency key or event ID. Recipients store processed IDs and ignore duplicates. This handles retries from the sender and network-level duplicates.

Security best practices: rotate secrets periodically, use different secrets per environment (dev/staging/prod), include timestamps and reject old webhooks (e.g., >5 minutes), and verify IP allowlists where feasible. Never include sensitive data like private keys or full card numbers in webhooks.

## Checklist
- Sign webhooks with HMAC-SHA256 and shared secret
- Canonicalize JSON payloads with sorted keys
- Include event ID for idempotency
- Verify signatures with constant-time comparison
- Implement timestamp validation

## Red flags
- Unsigned webhooks trusting sender IP alone
- Non-canonical JSON causing verification failures
- Missing idempotency handling duplicate events
- Including secrets or sensitive data in payload
`,
  blocks: [
    {
      type: "quiz",
      id: "payments-v2-l6-quiz",
      title: "Concept Check",
      questions: [
        {
          id: "payments-v2-l6-q1",
          prompt: "Why is JSON canonicalization important for webhooks?",
          options: [
            "Different key orders produce different signatures",
            "It makes payloads smaller",
            "It encrypts the data",
          ],
          answerIndex: 0,
          explanation: "Canonicalization ensures consistent serialization so signatures match regardless of object construction order.",
        },
        {
          id: "payments-v2-l6-q2",
          prompt: "What algorithm is standard for webhook signing?",
          options: ["HMAC-SHA256", "MD5", "RSA-512"],
          answerIndex: 0,
          explanation: "HMAC-SHA256 provides strong security and is widely supported across languages.",
        },
      ],
    },
  ],
};

const lesson7: Lesson = {
  id: "payments-v2-error-states",
  slug: "payments-v2-error-states",
  title: "Error state machine and receipt format",
  type: "content",
  xpReward: 40,
  duration: "40 min",
  content: `# Error state machine and receipt format

Payment flows require well-defined state machines to handle the complexity of asynchronous confirmations, failures, and retries. Clear state transitions and receipt formats ensure reliable payment tracking.

Payment states typically include: pending (intent created, not yet submitted), processing (transaction submitted, awaiting confirmation), succeeded (transaction confirmed, payment complete), failed (transaction failed or rejected), and cancelled (intent explicitly cancelled before submission). Each state has valid transitions and terminal states.

State transition rules: pending can transition to processing, cancelled, or failed; processing can transition to succeeded or failed; succeeded and failed are terminal. Invalid transitions (e.g., succeeded â†’ failed) indicate bugs or data corruption.

Receipt format standardization enables interoperability. A payment receipt should include: payment intent ID, transaction signature (if submitted), amount and currency, recipient address, timestamp, status, and verification data (e.g., explorer link). Receipts should be JSON with canonical ordering for deterministic hashing.

Explorer links provide transparency. For Solana, construct explorer URLs using: https://explorer.solana.com/tx/{signature}?cluster={network}. Include these in receipts and webhook payloads so users can verify transactions independently.

## Checklist
- Define clear payment states and valid transitions
- Implement state machine validation
- Generate standardized receipt JSON
- Include explorer links for verification
- Handle all terminal states appropriately

## Red flags
- Ambiguous states without clear definitions
- Missing terminal state handling
- Non-deterministic receipt formats
- No explorer links for verification
`,
  blocks: [
    {
      type: "terminal",
      id: "payments-v2-l7-states",
      title: "State Machine",
      steps: [
        {
          cmd: "State: pending",
          output: "Transitions: processing, cancelled, failed",
          note: "Initial state after intent creation",
        },
        {
          cmd: "State: processing",
          output: "Transitions: succeeded, failed",
          note: "Transaction submitted, awaiting confirmation",
        },
        {
          cmd: "State: succeeded",
          output: "Terminal state",
          note: "Payment complete, generate receipt",
        },
      ],
    },
  ],
};

const lesson8: Challenge = {
  id: "payments-v2-webhook-receipt",
  slug: "payments-v2-webhook-receipt",
  title: "Challenge: Verify webhook and produce receipt",
  type: "challenge",
  xpReward: 70,
  duration: "50 min",
  language: "typescript",
  content: `# Challenge: Verify webhook and produce receipt

Implement the final payment flow checkpoint:

- Verify signed webhook signature (HMAC-SHA256)
- Extract payment details from payload
- Generate standardized receipt JSON
- Include explorer link and verification data
- Ensure deterministic, sorted output

This validates the complete payment flow from intent to receipt.`,
  starterCode: lesson8StarterCode,
  testCases: lesson8TestCases,
  hints: lesson8Hints,
  solution: lesson8SolutionCode,
};

const module1: Module = {
  id: "payments-v2-foundations",
  title: "Payment Foundations",
  description:
    "Address validation, idempotency strategy, and payment intent design for reliable checkout behavior.",
  lessons: [lesson1, lesson2, lesson3, lesson4],
};

const module2: Module = {
  id: "payments-v2-implementation",
  title: "Implementation & Verification",
  description:
    "Transaction building, webhook authenticity checks, and deterministic receipt generation with clear error-state handling.",
  lessons: [lesson5, lesson6, lesson7, lesson8],
};

export const solanaPaymentsCourse: Course = {
  id: "course-solana-payments",
  slug: "solana-payments",
  title: "Solana Payments & Checkout Flows",
  description:
    "Build production-grade Solana payment flows with robust validation, replay-safe idempotency, secure webhooks, and deterministic receipts for reconciliation.",
  difficulty: "intermediate",
  duration: "10 hours",
  totalXP: 400,
  tags: ["payments", "checkout", "webhooks", "transactions", "solana"],
  imageUrl: "/images/courses/solana-payments.svg",
  modules: [module1, module2],
};
